{
  "articles": [
    {
      "path": "index.html",
      "title": "Curso R",
      "description": "Aprecie todo o material contido nesse site, como se fosse seu. Zele, propague, critique, contribua. Será um prazer compartilharmos nossas experiências e experienciarmos juntos esse conhecimento! \n",
      "author": [],
      "contents": "\r\n\r\nSumário\r\n Sobre o autor\r\n Proposta do curso\r\nProgramação em R (Nível Básico)\r\nProgramação em R (Nível Intermediário)\r\nProgramação em R (Nível Avançado)\r\nReferências do curso\r\nOnde encontrar nossos materiais\r\nPacotes R utilizados para esse curso\r\n\r\n Instalação do R e do RStudio\r\nSO Windows\r\nSO Linux (Ubuntu)\r\nSO MAC\r\n\r\n\r\n Sobre o autor \r\nNatural da cidade de Pau dos Ferros/RN. Formado em Engenharia Agronômica pela Universidade Federal Rural do Semiárido (UFERSA), Mossoró/RN. Pós-Graduação (Mestrado e Doutorado) e Pós-Doutorado em Estatística e Experimentação Agropecuária pela Universidade Federal de Lavras (UFLA), Lavras/MG. Atualmente estou como Professor de Estatística pela Universidade de São João Del-Rei (UFSJ), campus Alto Paraopeba, Ouro Branco/MG. Minhas linhas de pesquisas se concentram em Estatística e Probabilidade, Estatística Experimental, Estatística Computacional (linguagem R), densenvolvimento de pacotes R para análises de dados e ensino da Estatística. Mais detalhes, acesse minha página.\r\nA motivação para estudar a linguagem R se deve a algumas fases experienciadas na vida acadêmica. A primeira foi a paixão pela Estatística. Estando no terceiro período do curso de Agronomia (UFERSA), concorri a tão sonhada monitoria de Estatística, orientada pelo Prof. Janilson Pinheiro de Assis (UFERSA). Nessa fase houve muitas conversas e conselhos para seguir em uma pós-graduação na área da Estatística. Se tornou amor quando fui impulsionado pelas leituras de apostilas e o encanto por um programa estatístico chamado SISVAR, do Prof. Daniel Furtado Ferreira (UFLA), Figura 1. Isso resultou em todo amadurecimento profissional durante o mestrado e doutorado sob a orientação do Prof. Daniel, e até hoje, estamos em constante processo de desenvolvimento de pesquisa, com o objetivo de propagar conhecimento.\r\n\r\n\r\n\r\nFigure 1: Daniel Furtado na Serra da Bocaina (Lavras/MG).1\r\n\r\n\r\n\r\nAinda durante a graduação, além de conhecer os materiais de Estatística do Professor Daniel, comecei a ler os materiais introdutórios em R, que costumeiramente, ele postava em sua página institucional. Mas o passo inicial para me guiar ao estudo do R, foi idealizado por uma apostila do Professor Paulo Justiniano Ribeiro Júnior (UFPR), intitulada Introdução ao Ambiente Estatístico R. As primeiras leituras desse material, me trouxe um bom conhecimento inicial, sobre a linguagem R, ao mestrado na UFLA.\r\nTudo isso me levou a essa outra grande paixão hoje que é estudar essa linguagem. Com o apoio inicial do Prof. Daniel Furtado, durante a pós-graduação, e agora na UFSJ, com os alunos que trabalham comigo de iniciação científica, juntos com mais alguns outros parceiros de estrada, chegamos a publicação de alguns pacotes R sob o CRAN, segue em ordem de publicação, SMR, midrangeMCP, TVMM, cppcor, MCPtests. Para projetos futuros, temos os pacotes statscience, meupacoter, leem (Laboratório de Ensino à Estatística e Matemática) dentre outros ainda não disponíveis.\r\n\r\n Proposta do curso \r\nO curso R não tem como objetivo principal de ensinar análise de dados. Mas sim, proporcionar a você um conhecimento sobre a linguagem R, de modo que consiga usufruir todos os recursos que ela possa lhe proporcionar.\r\nAinda como complemento, não queremos nesse material, convencê-lo a utilizar a linguagem R, pois a melhor linguagem é aquela que você domina. Contudo, pretendemos lhe mostrar que os recursos utilizados pelo R não estão mais limitados a própria análise de dados. Um exemplo é esse material, que nesse momento usufruo do R para repassar as minhas experiências sem ao menos ter o domínio sobre linguagens do tipo HTML, CSS, JavaScript, dentre outras, necessárias para uma boa criação de página web.\r\nDessa forma, propormos um entendimento sobre a sintaxe e semântica de como a linguagem R é desenvolvida. Com isso, você será capaz após esse curso, estudar um pouco mais sobre essa ciência que nos últimos anos vem ganhando mais evidência, que é a Estatística. Tudo isso devido ao grande volume de informações obtidos nessa era tecnológica. Juntamente com ela, o R se tornará uma poderosa ferramenta com o qual você poderá entender os padrões que estão por trás dos dados, que por sinal, é a moeda valiosa do momento, ou melhor, sempre foi!\r\nMas não só apenas análise de dados, aprenderemos também recursos diversos na área da computação, como programação defensiva, desenvolvimento de interfaces gráficas, paralelização. Ensinaremos também o desenvolvimento de materiais como artigos, livros, websites, blogs, dashboards. Por fim, chegaremos a maior cobiça de um programador R, desenvolver seu próprio pacote R.\r\n\r\n\r\n Repararam que em muitos momentos utilizamos o artigo “o” para a linguagem R. Pois é, isso ocorre porque ela também é considerada um software. Daí, também podemos chamá-la de software R, ou preferivelmente, ambiente R. \r\n\r\n\r\nO material curso R apresentará três módulos:\r\nProgramação em R (Nível Básico)\r\nProgramação em R (Nível Intermediário)\r\nProgramação em R (Nível Avançado)\r\nA seguir, explanaremos sobre cada um dos módulos.\r\nProgramação em R (Nível Básico)\r\nO primeiro módulo compreenderá um breve histórico sobre a linguagem, o conhecimento da sintaxe e semântica da linguagem R, compreendendo as estruturas bases da linguagem, sobre o que é um objeto e como construir uma função, o entendimento sobre fluxos de controle. O que é um pacote, carregar e anexar um pacote, e quem são as pessoas que fazem parte da manutenção dessa linguagem, também serão assuntos desse primeiro módulo. Caminhos de busca, ambientes e namespaces, teremos noções básicas. Algo muito interessante, que pode mudar a sua vida como programação em R são as boas práticas para a escrita de um código R, tema também abordado nesse módulo.\r\nPara acessar o material, segue: Programação em R (Nível Básico).\r\nProgramação em R (Nível Intermediário)\r\nEm contrução…\r\nProgramação em R (Nível Avançado)\r\nEm contrução…\r\nReferências dos curso\r\nCitaremos alguns livros e materiais utilizados para o desenvolvimento desse curso, tais como:\r\nAn Introduction to R\r\nR Language Definition\r\nR Internals\r\nAdvanced R (Wickham 2019)\r\nAdvanced R Solutions (Grosser, Buman, and Wickham 2021)\r\nR Packages (Wickham 2015)\r\nExtending R (Chambers 2016)\r\nSoftware for Data Analysis: Programming with R (Chambers 2008)\r\nR in a Nutshell (Adler 2012)\r\nOnde encontrar os nossos materiais\r\nTemos dedicado uma parte do nosso trabalho no desenvolvimento de materiais em R, dos quais podem ser encontrados em: Ciencia e Progresso, Github e página pessoal.\r\nPacotes R utilizados para esse curso\r\n\r\n\r\nSegue uma lista dos pacotes utilizados para o desenvolvimento do material desse curso:\r\nPacote\r\nObjetivo para o curso\r\nlobstr\r\nAuxilia no estudo sobre a sintaxe do pacote\r\ncodetools\r\nAuxilia no estudo sobre a sintaxe do pacote\r\nXR\r\nAuxilia no estudo sobre a sintaxe do pacote\r\nrlang\r\nAuxilia no estudo sobre a sintaxe do pacote\r\nsloop\r\nAuxilia a compreender interativamente a programação orientada a objetos\r\ndistill\r\nCriação da página\r\n Instalação do R e do RStudio\r\nA seguir, apresentaremos as subseções para a instalação da linguagem R e do RStudio. Em todo nosso curso utilizaremos o sistema operacional Windows. Contudo, se esse não é o seu sistema operacinal, não haverá problema no entendimento sobre o R. Assim, convencionaremos a todos a utilização do RStudio, uma vez que poderá ser instalado nas principais plataformas de sistema operacional.\r\nSO Windows\r\nPara a instalação do R e do RStudio, como também do rtools, convidaremos para a seção Instalação do R e do RStudio do primeiro módulo desse curso, que é Programação em R (nível básico).\r\n\r\n\r\nSO Linux (Ubuntu)\r\nUm vídeo produzido pelo nosso canal do Youtube/Ben Dêivide, mostra falcilmente como realizar a instalação do R e o RStudio pelo Linux: \r\nUma outra opção pode ser um vídeo produzido pelo Canal PPGC UFSC (Youtube), mostra falcilmente como realizar a instalação do R e o RStudio pelo Linux: \r\nSO MAC\r\nUm vídeo produzido pelo Canal PPGC UFSC (Youtube), mostra falcilmente como realizar a instalação do R e o RStudio pelo MAC:\r\n\r\n\r\n\r\n\r\n\r\nAdler, Joseph. 2012. R in a Nutshell. Sebastopol: O’Reilly Media.\r\n\r\n\r\nChambers, John M. 2008. Extending R. Statistics and Computing. New York: Springer.\r\n\r\n\r\n———. 2016. Extending R. The R Series. Boca Raton, Florida: Chapman; Hall/CRC.\r\n\r\n\r\nGrosser, Malte, Henning Buman, and Hadley Wickham. 2021. Advanced R Solutions. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\nWickham, Hadley. 2015. R Packages. 2nd ed. O’Reilly Media. https://r-pkgs.org/index.html.\r\n\r\n\r\n———. 2019. Advanced R. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\n———. 2019. Advanced R. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\nFonte das fotos: Acervo pessoal de Daniel Furtado↩︎\r\n",
      "last_modified": "2021-03-04T15:05:44-03:00"
    },
    {
      "path": "nbasico.html",
      "title": "Programação em R (Nível Básico)",
      "description": "Esse módulo terá o objetivo de apresentar de forma introdutória a **sintaxe** e **semântica** da linguagem `R`, enfatizando definições importantíssimas para a linguagem como **objeto**, **função** e **pacote**, como também outras definições\n",
      "author": [],
      "contents": "\r\nSumário\r\n Materiais para este módulo\r\nSlides de Aulas\r\nScripts\r\nExercícios e Scripts via Shiny\r\n\r\n Apresentação do curso\r\n Instalação do R e RStudio para o SO Windows\r\n Como utilizar o R e o RStudio\r\n História do R\r\n Como o R trabalha\r\n Comandos no R e Ambiente Global\r\n Arquivos .Rdata e .Rhistory\r\n Criando e salvando um script\r\n Objetos\r\n Vetores\r\n Matrizes bidimensionais\r\n Matrizes multidimencionais\r\n Listas de dados\r\n Quadro de dados\r\n Importantdo/Exportando dados\r\n\r\n Materiais para este módulo\r\nSlides de Aulas\r\nAula 00: Apresentação do Curso\r\nAula 01: Instalação do R e do RStudio\r\nAula 02: Passos iniciais para a utilização do R e do RStudio\r\nAula 03: História do R\r\nAula 04: Como o R trabalha\r\nAula 05: Comandos no R e Ambiente Global\r\nAula 06: Arquivos .RData e .Rhistory\r\nAula 07: Criando e salvando um Script\r\nAula 08: Objetos\r\nAula 09: Vetores\r\nAula 10: Matrizes\r\nAula 11: Arrays\r\nAula 12: Lists\r\nAula 13: Data frames\r\nAula 14: Importando/Exportando dados\r\nAula 15: Funções\r\nAula 16: Boas práticas de como escrever um código\r\nAula 17: Como criar funções\r\nAula 18: Controle de fluxos (Loops)\r\nAula 19: Pacotes\r\nAula 20: Carregando e Anexando pacotes\r\nAula 21: Quando devemos utilizar os operadores :: e :::\r\nAula 22: Namespace de um pacote\r\nAula 23: Ambientes e Caminhos de busca\r\nAula 24: Interface com outras linguagens\r\nAula 25: Considerações e Preparação para a Programação em R (Nível Intermediário)\r\nScripts\r\nScript 00: ~\r\nScript 01: ~\r\nScript 02: ~\r\nScript 03: Escopo léxico\r\nScript 04: ~\r\nScript 05: Comandos\r\nScript 06: ~\r\nScript 07: .RData e .Rhistory\r\nScript 08:\r\nScript 09:\r\nScript 10:\r\nScript 11:\r\nScript 12:\r\nScript 13:\r\nExercícios e Scripts via Shiny\r\nCurso R via Shiny\r\n Apresentação do curso\r\n\r\n\r\nO Curso R será todo aprensentado no formato online, sendo que as aulas terão vídeos como suporte, postados no canal Youtube/Ben Dêivide divulgados ao longo do material. Os vídeos serão bem objetivos de curta duração para que usem como suporte com o material escrito. Como complemento desse material, disponibilizaremos os scripts com os comandos utilizados em cada aula e sua versão em Shiny para os que não quiserem realizar inicialmente a instalação do R e do RStudio, poderão utilizar uma versão online do material juntamente com a linguagem R.\r\n\r\n\r\n Instalação do R e RStudio para o SO Windows\r\n\r\n\r\nA linguagem R é o objetivo principal desse curso. Assim, faremos inicialmente a sua instalação, uma vez que o RStudio é apenas uma GUI, e sem o R, não há sentido instalá-lo.\r\nDessa forma, seguem os passos para a instalação:\r\nInstalação do R: https://cran.r-project.org/bin/windows/base/\r\nInstalação do RStudio: https://rstudio.com/products/rstudio/download/#download\r\nJustificamos a utilizamos do RStudio, pela quantidade de recursos disponíveis e a diversidade de usuários R, que hoje o perfil não é apenas de um programador, mas um usuário que necessita de uma ferramenta estatística para análise de seus dados. Dessa forma, até por questão de praticidade, e de uso pessoal, não deixaremos de repassar o entendimento sobre a linguagem R com o uso do RStudio.\r\n Como utilizar o R e o RStudio\r\n\r\n\r\nA primeira ideia que temos sobre a linguagem R é a linha de comando no R, que é simbolizada pelo prompt de comando “>.” Este símbolo significa que o R está pronto para receber os comandos do usuário. O prompt de comando está localizado no console do R. Vejamos o console do R a seguir, que é o local que recebe as linhas de comando do usuário.\r\n\r\n\r\n\r\nFigure 1: Console do R (Versão 4.0.3).\r\n\r\n\r\n\r\nO R ao ser iniciado está pronto para ser inserido as linhas de comando desejadas. Uma forma simples de armazernar os seus comandos é por meio de um script, isto é, um arquivo de texto com extensão .R. Para criar basta ir em: Arquivo > Novo script.... Muitas outras informações iremos ver ao longo do curso.\r\nO RStudio se apresenta como uma interface para facilitar a utilização do R, tendo por padrão quatro quadrantes, apresentados na Figura 2.\r\n\r\n\r\n\r\nFigure 2: Interface do RStudio (Versão 1.4.1103).\r\n\r\n\r\n\r\nMuitas coisas na interface do R podem se tornar problemas para os usuários, uma vez que janelas gráficas, janelas de scripts, dentre outras, se sobrepõe. Uma vantagem no RStudio foi essa divisão de quadrantes, que torna muito mais organizado as atividades realizadas no R. De um modo geral, diremos que o primeiro quadrante é responsável pela entrada de dados, comandos, isto é, o input. O segundo quadrante, que é o console do R, representa tanto entrada como saída de informações (input/output). Dependendo as atividades as abas podem aumentar. O terceiro quadrante representa informações básicas como objetos no ambiente global, a memória de comandos na aba History, dentre outras, e também representa entrada como saída de informações (input/output). Por fim, o quarto quadrante é responsável por representação gráficas, instalação de pacotes, renderização de páginas web.\r\n História do R\r\n\r\n\r\nA linguagem R tem a sua primeira aparição científica publicada em 1996, com o artigo intitulado R: A Language for Data Analysis and Graphics, cujos os autores são os desenvolvedores da linguagem, George Ross Ihaka e Robert Clifford Gentleman.\r\n\r\n\r\n\r\nFigure 3: Criadores do R.1\r\n\r\n\r\n\r\nDurante a época em que estes professores trabalhavam na Universidade de Auckland, Nova Zelândia, desenvolvendo uma implementação alternativa da lingugagem S, desenvolvida por John Chambers, que comercialmente era o S-PLUS, nasceu em 1991, o projeto da linguagem R, em que em 1993 o projeto é divulgado e em 1995, o primeiro lançamento oficial, como software livre com a licença GNU. Devido a demanda de correções da linguagem estava acima da capacidade de atualização em tempo real, foi criado em 1997, um grupo central voluntário, responsável por essas atualizações, o conhecido R Development Core Team2, que hoje está em 20 membros: Douglas Bates, John Chambers, Peter Delgaard, Robert Gentleman, Kurt Hornik, Ross Ihaka, Tomas kalibera, Michael Lawrence, Friedrich Leish, Uwe Ligges, Thomas Lumley, Martin Maechler, Martin Morgan, Paul Murrel, Martyn Plummer, Brian Ripley, Deepayan Sarkarm, Duncan Temple Lang, Luke Tierney e Simon Urbanek.\r\nPor fim, o CRAN (Comprehensive R Archive Network) foi oficialmente anunciado em 23 de abril de 19973. O CRAN é um conjunto de sites (espelhos) que transportam material idêntico, com as contribuições do R de uma forma geral.\r\nR é uma linguagem de programação e ambiente de software livre e código aberto (open source). Entendemos4:\r\nSoftware livre: software que respeita a liberdade e sendo de comunidade dos usuários, isto é, os usuários possuem a liberdade de executar, copiar, distribuir, estudar, mudar, melhorar o software. Ainda reforça que um software é livre se os seus usuários possuem quatro liberdades:\r\nLiberdade 0 - A liberdade de executar o programa como você desejar, para qualquer propósito;\r\nLiberdade 1 - A liberdade de estudar como o programa funciona, e adaptá-la as suas necessidades;\r\nLiberdade 2 - A liberdade de redistribuir cópias de modo que você possa ajudar outros;\r\nLiberdade 3 - A liberdade de distribuir cópias de suas versões modificadas a outros.\r\n\r\nAlgo que deve está claro é que um software livre não significa não comercial. Sem esse fim, o software livre não atingiria seus objetivos.\r\nAgora perceba que, segundo Richard Stallman5, a ideia de software livre faz campanha pela liberdade para os usuários da computação. Por outro lado, o código aberto valoriza principalmente a vantagem prática e não faz campanha por princípios.\r\nCódigo aberto: Para Richard Stallman6 código aberto apoia critérios um pouco mais flexíveis que os do software livre. Todos os códigos abertos de software livre lançados se qualificariam como código aberto. Quase todos os softwares de código aberto são software livre, mas há exceções, como algumas licenças de código aberto que são restritivas demais, de forma que elas não se qualificam como licenças livres. Nesse contexto, o autor cita muitas situações que diferenciam os dois termos. Vale a pena a leitura.\r\nA linguagem R é uma combinação da linguagem S com a semântica de escopo léxico da linguagem Scheme. Dessa forma, a linguagem R se diferencia em dois aspectos principais7:\r\nGerenciamento de memória: usando as próprias palavras de Ross Ihaka8, em R, alocamos uma quantidade fixa de memória na inicialização e a gerenciamos com um coletor de lixo dinâmico. Isso significa que há muito pouco crescimento de heap e, como resultado, há menos problemas de paginação do que os vistos em S.\r\nEscopo: na linguagem R, as funções acessam as variáveis criadas pelo no corpo da própria função, como também as variáveis contidas no ambiente que a função foi criada. No caso da linguagem S, isso não ocorre, assim, como por exemplo na linguagem C, em que as funções acessam apenas variáveis definidas globalmente.\r\nVejamos alguns exemplos para entendimento (Se você ainda não está ambientado ao R, estude esse módulo primeiro, e depois reflita sobre esses exemplos). Antes de executar as linhas de comando, instale o pacote lobstr como segue:\r\n\r\n\r\n# Instale o pacote lobstr\r\ninstall.packages(\"lobstr\")\r\n\r\n\r\n\r\nExemplo 1: As funções têm acesso ao escopo em que foram criadas.\r\n\r\n\r\n# Criando um nome \"n\" associado a um objeto 10 no escopo da funcao\r\nn <- 10\r\n\r\n# Criando um nome \"funcao\" associado a um objeto que eh uma funcao\r\nfuncao <- function() {\r\n  print(n)\r\n}\r\n\r\n# Imprimindo 'funcao'\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n\r\nExemplo 2: As variáveis criadas ou alteradas dentro de uma função, permanecem na função.\r\n\r\n\r\n# Criando um nome \"n\" associado a um objeto 10 no escopo da funcao\r\nn <- 10\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0x9029058\"\r\n\r\n# Criando um nome \"funcao\" associado a um objeto que eh uma funcao\r\nfuncao <- function() {\r\n  # Imprimindo n\r\n  print(n)\r\n  # Criando um nome \"n\" associado a um objeto 15 no corpo da funcao\r\n  n <- 15\r\n  # Imprimindo n\r\n  print(n)\r\n}\r\n# Imprimindo 'funcao'\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n[1] 15\r\n\r\n# Imprimindo 'n'\r\nn\r\n\r\n\r\n[1] 10\r\n\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0x9029058\"\r\n\r\nExemplo 3: As variáveis dentro de uma função permanecem nelas, exceto no caso em que a atribuição ao escopo seja explicitamente solicitada.\r\n\r\n\r\n# Criando um nome \"n\" associado a um objeto 10 no escopo da funcao\r\nn <- 10\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0xdf1c150\"\r\n\r\n# Criando um nome \"funcao\" associado a um objeto que eh uma funcao\r\nfuncao <- function() {\r\n  # Imprimindo n\r\n  print(n)\r\n  # Criando um nome \"n\" associado a um objeto 15 no corpo da funcao\r\n  n <<- 15\r\n  # Imprimindo n\r\n  print(n)\r\n}\r\n# Imprimindo 'funcao'\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n[1] 15\r\n\r\n# Observe que depois de usar a superatribuicao (\"<<-\") dentro da funcao,\r\n#o nome \"n\" passou a estar associado ao numero 15 e nao mais ao numero 10, observe\r\nn\r\n\r\n\r\n[1] 15\r\n\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0xdf1c070\"\r\n\r\nExemplo 4: Por fim, embora a linguagem R tenha um escopo padrão, chamado ambiente global, os escopos de funções podem ser alterados.\r\n\r\n\r\n# Criando um nome 'n' associado a um objeto 10 no escopo da funcao (ambiente global)\r\nn <- 10\r\n# Criando um nome 'funcao' associado a um objeto que eh uma função criado no ambiete global\r\nfuncao <- function() {\r\n  # Imprimindo n\r\n  print(n)\r\n}\r\n# Imprimindo 'funcao' no ambiente global\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n\r\n# Criando um novo ambiente\r\nnovo_ambiente <- new.env()\r\n# Criando um nome \"n\" associado ao objeto 20 no ambiente  'novo_ambiente'\r\nnovo_ambiente$n <- 20\r\n# Criando um objeto funcao no ambiente 'novo_ambiente'\r\nenvironment(funcao) <- novo_ambiente\r\n# Imprimindo 'funcao' no ambiente 'novo_ambiente'\r\nfuncao()\r\n\r\n\r\n[1] 20\r\n\r\nComo a linguagem S é também uma linguagem interpretada cuja base é a linguagem FORTRAN, a linguagem R também é uma linguagem interpretada e baseada além da linguagem S, tem como base as linguagens de baixo nível C e FORTRAN e a própria linguagem R.\r\nEmbora o R tenha uma interface baseada em linhas de comando, existem muitas interfaces gráficas ao usuário com destaque ao RStudio, criado por Joseph J. Allaire, Figura 4.\r\n\r\n\r\n\r\nFigure 4: J. J. Allaire, o criador do RStudio9.\r\n\r\n\r\n\r\nEssa interface tornou o R mais popular, pois além de produzir pacotes de grande utilização hoje como a família de pacotes tidyverse, rmarkdown, shiny, dentre outros, permite uma eficiente capacidade de trabalho de análise de utilização do R. Uma vez que o RStudio facilita a utilização de muitos recursos por meio de botões, como por exemplo, a criação de um pacote R, a quem diga que para um iniciante em R que não inicie a linguagem por meio dela. Cremos, que o problema não é o RStudio, e sim, o caminho onde deseja chegar com a linguagem R.\r\nNo Brasil, o primeiro espelho do CRAN foi criado na UFPR, pelo grupo do Prof. Paulo Justiniano. Inclusive um dos primeiros materiais mais completos sobre a linguagem R produzidos no Brasil, foi dele, iniciado em 2005, intitulado Introdução ao Ambiente Estatístico R. Vale a pena assistirmos o evento a palestra: R Releflões: um pouco de história e experiências com o R, proferida pelo Prof. Paulo Justiniano Ribeiro Júnior, no R Day - Encontro nacional de usuários do R, ocorrido em 2018 em Curitiba/UFPR, do qual o vídeo está disponível no Canal (Youtube) LEG UFPR.\r\n\r\n\r\nPara quem não sabe, o Prof. Paulo Justiniano (Figura 5) e sua equipe trouxeram o primeiro espelho do R para o Brasil e foi o desenvolvedor de um dos 100 primeiros pacotes submetidos ao CRAN10. Devido a sua ida para Lancaster/Inglaterra para fazer o doutorado, em 1997, se deparou com o início dos estudos sobre o R fora do país. Isso porque havia uma necessidade muito grande de um programa para ser utilizado nas plataforma UNIX. Nesse momento a linguagem S estava sendo uma saída para isso, porém, o uso de memória que a linguagem consumia nos computadores, na criação das rotinas, era muito grande (Claro que grande para aquela época!). Não satisfeito, ao voltar para o Brasil, em 2002, se depara com alguns usuários da linguagem S, porém, certo como mudança de cultura na utilização de linguagem R, passou a densevolver materiais didáticos da linguagem, para as disciplinas do departamento de Estatística (UFPR).\r\n\r\n\r\n\r\nFigure 5: Foto de divulgação de Paulo Justiniano11 no R Day.\r\n\r\n\r\n\r\n\r\n Como o R trabalha\r\n\r\n\r\nIniciamos a discussão por uma afirmação de John McKinley Chambers, do qual afirmou que o R tem três princípios (Chambers 2016):\r\n\r\n\r\n\r\nFigure 6: John Chambers12, o criador da linguagem S.\r\n\r\n\r\n\r\n\r\n\r\nPrincípio do Objeto: Tudo que existe em R é um objeto;\r\nPrincípio da Função: Tudo que acontece no R é uma chamada de função;\r\nPrincípio da Interface: Interfaces para outros programas são parte do R.\r\n\r\nAo longo de todo o curso, para os três módulos, iremos nos referir a esses princípios. Vamos inicialmente observar uma adaptação da ilustração feita por Paradis (2005), mostrando como o R trabalha, Figura 7.\r\n\r\n\r\n\r\nFigure 7: Esquema de como o R funciona.\r\n\r\n\r\n\r\nToda ação que acontece no R é uma chamada de função (Operadores e funções), que por sua vez é armazenada na forma de um objeto, e este se associa a um nome. A forma de execução de uma função é baseada em argumentos (dados, fórmulas, expressões, etc), que são entradas, ou argumentos padrões que já são pré-estabelecidos na criação da função. Esses tipos de argumentos podem ser modificados na execução da função. Por fim, a saída é o resultado, que é também um objeto, e pode ser usado como argumento de outras funções.\r\nNa Figura 7, observamos que todas as ações realizadas sobre os objetos ficam armazenadas na memória ativa do computador. Esses objetos são criados por comandos (teclado ou mouse) através de funções ou operadores (chamada de função), dos quais leem ou escrevem arquivo de dados do disco rígido, ou leem da própria internet. Por fim, o resultado desses objetos podem ser apresentados no console (memória ativa), exportados em formato de imagem, página web, etc. (disco rígido), ou até mesmo ser reaproveitado como argumento de outras funções, porque o resultado também é um objeto.\r\n Comandos no R e Ambiente Global\r\n\r\n\r\nConsole e Prompt de comando\r\nComo falado anteriormente, o R é uma linguagem baseada em linhas de comando, e as linhas de comando, são executadas uma de cada vez, no console. Assim que o prompt de comando está visível na tela do console, o R indica que o usuário está pronto para inserir as linhas de comando. O símbolo padrão do prompt de comando é “>,” porém ele pode ser alterado. Para isso, use a linha de comando, por exemplo:\r\n\r\n\r\noptions(prompt = \"R>\")\r\n# Toda vez que o console iniciar, começarar por 'R>'\r\n10\r\n\r\n\r\n[1] 10\r\n\r\nO conjunto de símbolos que podem ser utilizados no R depende do sistema operacional e do país em que o R está sendo executado. Basicamente, todos os símbolos alfanuméricos podem ser utilizados, mas para evitar problemas quanto ao uso das letras aos nomes, opte pelos caracteres ASCII.\r\nA escolha do nome associado a um objeto tem algumas regras:\r\nDeve consistir em letras, dígitos, . e _;\r\nOs nomes devem ser iniciado por uma letra ou um ponto não seguido de um número, isto é, Ex.: .123, 1n, dentre outros;\r\nAs letras maiúsculas se distinguem das letras minúsculas;\r\nNão pode inicia por _ ou dígito, é retornado um erro no console caso isso ocorra;\r\nNão pode usar qualquer uma das palavras reservadas pela linguagem, isto é, TRUE, FALSE, if, for, dentre outras, que pode ser consultado usando o comando ?Reserved().\r\nUm nome que não segue essas regras é chamado de um nome não sintático. Um comando que pode ser usado para converter nomes não sintatícos em nomes sintáticos é make.names.\r\n\r\n\r\n\r\nApesar dessas justificativas, algumas situações como as apresentadas nos exemplos anteriores são possíveis, ver Wickham (2019) na Seção 2.2.1\r\nComandos elementares\r\nOs comandos elementares podem ser divididos em expressões e atribuições. Por exemplo, podemos está interessados em resolver a seguinte expressão \\(10 + 15 = 25\\). No console quando passamos pelo comando:\r\n\r\n\r\n10 + 15\r\n\r\n\r\n[1] 25\r\n\r\nO R avalia essa expressão internamente e imprime o resultado na tela, após apertar o botão ENTER do teclado. Esse fato é o que ocorre no segundo princípio mencionado por Chambers (2016), tudo em R acontece por uma chamada de função. Na realidade o símbolo + é uma função interna do R, que chamamos de função primitiva, porque foi implementada em outra linguagem. Assim, essa é o resultado de três objetos (“10,” “+,” “15”) que são avaliados internamente, do qual a função + é chamada, e em seguida o resuldo é impresso no console.\r\nDo mesmo modo, se houver algum problema em algum dos objetos o retorno da avaliação pode ser uma mensagem de erro. Um caso muito prático é quando utilizamos o separador de casas decimais para os números sendo a vírgula. Quando na realidade deve ser um ponto “.” respeitando o sistema internacional de medidas. A vírgula é utilizada para separar elementos, argumentos em uma função, etc. Vejamos o exemplo:\r\n\r\n10,5 + 15,5\r\nError: <text>:1:3: ',' inesperado\r\n1: 10,\r\n      ^\r\n\r\nPorém, tem que ficar claro que uma expressão é qualquer comando repassado no console. Este comando é avaliado e seu resultado impresso, há menos que explicitamente o usuário queira torná-lo invisível13. Caso algum elemento do comando não seja reconhecido pelo R, há um retorno de alguma mensagem em forma de “erro” ou “alerta,” tentando indicar o possível problema. Todos esses processos ocorrem na memória ativa do computador, e uma vez o resultado impresso no console, o valor é perdido, há menos que você atribua essa expressão a um nome, que erroneamento usamos o termo: “criamos um objeto!” A atribuição dessa expressão será dada pela junção de dois símbolos “<-,” falado mais a frente. Um comando em forma de atribuição também avalia a sua expressão, um nome se associa ao seu resultado, e o resultado será mostrado, se posteriormente, após a execução você digitar o “nome” atribuído a esse resultado. Vejamos um exemplo:\r\n\r\n\r\n# Foi criado um objeto do tipo caractere e o nome \"meu_nome\" foi associado a ele\r\n# O 'R' avalia essa expressão, mas não imprime no console!\r\nmeu_nome <- \"Ben\"\r\n\r\n# Para imprimir o resultado da expressão, digitamos o nome \"meu_nome\" no console\r\n# e apertamos o botão ENTER do teclado!\r\nmeu_nome\r\n\r\n\r\n[1] \"Ben\"\r\n\r\nExecução dos comandos\r\nQuando inserimos um comando no console, executamos uma linha de comando por vez ou separados por “;” em uma mesma linha. Vejamos\r\n\r\n\r\n# Uma linha de comando por vez\r\nmeu_nome <- \"Ben\" # Criamos e associamos um nome ao objeto\r\nmeu_nome # Imprimos o objeto\r\n\r\n\r\n[1] \"Ben\"\r\n\r\n# Tudo em uma linha de comando\r\nmeu_nome <- \"Ben\"; meu_nome\r\n\r\n\r\n[1] \"Ben\"\r\n\r\nSe um comando for muito grande e não couber em uma linha, ou caso deseje completar um comando em mais de uma linha, após a primeira linha haverá o símbolo “+” iniciando a linha seguinte ao invés do símbolo de prompt de comando (“>”), até que o comando esteja sintaticamente completo. Vejamos:\r\n\r\n\r\n# Uma linha de comando em mais de uma linha\r\n(10 + 10) /\r\n  2\r\n\r\n\r\n[1] 10\r\n\r\nPor fim, todas linhas de comando quando iniciam pelo símbolo jogo da velha, “#” indica um comentário e essa linha de comando não é avaliada pelo console, apenas impressa na tela. E ainda, as linhas de comandos no console são limitadas a aproximadamente 4095 bytes (não caracteres).\r\nChamada e correção de comandos anteriores\r\nUma vez que um comando foi executado no console, esse comando por ser recuperado usando as teclas de setas para cima e para baixo do teclado, recuperando os comandos anteriorermente executados, e que os caracteres podem ser alterados usando as teclas esquerda e direita do teclado, removidas com o botão Delete ou Backspace do teclado, ou acrescentadas digitando os caracteres necessários. Uma outra forma de completar determinados comandos já existentes, como por exemplo, uma função que já existe nas bibliotecas de instalação do R, usando o botão Tab do teclado. O usuário começa digitando as iniciais, e para completar o nome aperta a tecla Tab. Posteriormente, basta completar a linha de comando e apertar ENTER para executá-la. Vejamos um exemplo a seguir.\r\n\r\n\r\nUsando esses recursos no RStudio são mais dinâmicos e vão mais além. Por exemplo, quando usamos um objeto do tipo função, estes apresentam o que chamamos de argumento(s) dentro do parêntese de uma função, do qual são elementos necessários, para que a função seja executada corretamente. Nesse caso, ao inseri o nome dessas funções no console, usando o RStudio, ao iniciá-la com a abertura do parêntese, abre-se uma janela informano todos os argumentos possíveis dessa função. Isso torna muito dinâmico escrever linhas de comando, porque não precisaremos estar lembrando do nome dos argumentos de uma função, mas apenas entender o objetivo dessa função. Vejamos um exemplo a seguir.\r\n\r\n\r\nAmbiente Global (ou área de trabalho, Workspace)\r\nQuando usamos um comando de atribuição no console, o R armazena o nome associado ao objeto criado na área de trabalho (Workspace), que nós chamamos de Ambiente Global. Teremos uma seção introdutória na seção Ambientes e caminhos de busca, mas entendamos inicialmente que o objetivo de um ambiente é associar um conjunto de nomes a um conjunto de valores. Por exemplo:\r\n\r\n\r\n# Nomes criados no ambiente \r\nx <- 10 - 6; y <- 10 + 4; w <- \"Maria Isabel\"\r\n# Verificando o nomes contidos no ambiente global\r\nls()\r\n\r\n\r\n[1] \"funcao\"        \"meu_nome\"      \"n\"             \"novo_ambiente\"\r\n[5] \"rlink\"         \"rstudio\"       \"w\"             \"x\"            \r\n[9] \"y\"            \r\n\r\nObserve que todos os objetos criados até o momento estão listados, e o que é mais surpreendente é que ambientes podem conter outros ambientes e até mesmo se conter. Observe o objeto meu_nome é um ambiente e está contido no Ambiente global. Será sempre dessa forma que recuperaremos um objeto criado no console do R. Caso contrário, se no console esse comando não for de atribuição esse objeto é perdido.\r\n Arquivos .Rdata e .Rhistory\r\n\r\n\r\nAo final do que falamos até agora, todo o processo ao inserir linhas de comando do console, e desejarmos finalizar os trabalhos do ambiente R, dois arquivos são criados, sob a instrução do usuário em querer aceitar ou não, um .RData e outro .Rhistory, cujas finalidades são:\r\n.RData: salvar todos os objetos criados que estão atualmente disponíveis;\r\n.Rhistory: salvar todas as linhas de comandos inseridas no console.\r\nAo iniciar o R no mesmo diretório onde esses arquivos foram salvos, é carregado toda a sua área de trabalho anteriomente, bem como o histórico das linhas de comando utilizadas anteriormente.\r\n Criando e salvando um script\r\n\r\n\r\nA melhor forma de armazenarmos nossas linhas de código inseridas no console é criando um Script. Este é um arquivo de texto com a extensão “.R.” Uma vez criada, poderemos ao final salvar o arquivo e guardá-lo para utilizar futuramente.\r\nNo R, ao ser iniciado poderemos ir no menu em Arquivo > Novo script.... Posteriormente, pode ser inserido as linhas de comando, executadas no console pela tecla de atalho F5. As janelas do Script e console possivelmente ficarão sobrepostas. Para uma melhor utilização, estas janelas podem ficar lado a lado, configurando-as no menu em Janelas > Dividir na horizontal (ou Dividir lado a lado).\r\nNo RStudio, poderemos criar um Script no menu em File > New File > R Script, ou diretamente no ícone abaixo da opção File no menu, cujo o símbolo é um arquivo com o símbolo “+” em verde, que é o ícone do New File, e escolher R Script. Esse arquivo abrirá no primeiro quadrante na interface do RStudio.\r\nPara salvar, devemos clicar no botão com o símbolo de disquete (R/RStudio), escolher o nome do arquivo e o diretório onde o arquivo será armazenado no seu computador. Algumas ressalvas devem ser feitas:\r\nEscolha sempre um nome sem caracteres especiais, com acentos, etc.;\r\nEscolha sempre um nome curto ou abreviado, que identifique a finalidade das linhas de comando escritas;\r\nEvite espaços se o nome do arquivo for composto. Para isso, use o símbolo underline “_”;\r\nQuando escrever um código, evite também escrever caracteres especiais, exceto em casos de necessidade, como imprimir um texto na tela, títulos na criação de gráficos, dentre outras. Nos referimos especificamente, nos comentários do código.\r\nUm ponto bem interessante é o diretório. Quando criamos um Script a primeira vez, e trabalhamos nele a pós a criação, muitos erros podem ser encontrados de início. Um problema clássico é a importação de dados. O usuário tem um conjunto de de dados e deseja fazer a importação para o R, porém, mesmo com todos os comandos corretos, o console retorna um erro, informando que não existe esse arquivo que contém os dados para serem informados. Isso é devido ao diretório de trabalho atual. Para verificar qual o diretório que está trabalhando no momento, use a linha de comando:\r\n\r\n\r\ngetwd()\r\n\r\n\r\n\r\nPara alterar o diretório de trabalho, o usuário deve usar a seguinte função setwd(\"Aqui, deve ser apontado para o local desejado!\"). Supomos que salvamos o nosso Script tem sido em C:\\meus_scripts_r. Assim, usamos a função setwd e ao apontarmos o local, as barras devem ser inseridas de modo invertido, isto é, setwd(\"C:/meu_scripts_r\"), além de estar entre aspas.\r\nNo RStudio, isso pode ser feito em Session > Set Working Directory > To Source File Location. Isso levará ao diretório corrente do Script. Se desejar escolher outro diretório, vá em Session > Set Working Directory > Choose Directory.... Porém, uma vez criado um Script, e utilizado novamente, se o usuário estiver abrindo o RStudio também naquele primeiro momento, por padrão, o diretório de trabalho corrente será o mesmo do diretório do Script. Isso acaba otimizando o trabalho.\r\nDevemos estar atentos também, quando trabalhamos utilizando Scripts ou arquivos de banco de dados, em locais diferentes do diretório corrente. Um outro recurso interessante é a função source(), que tem o objetivo de executar todas as linhas de comando de um Script sem precisar abri-lo. Isso pode ser útil, quando criamos funções para as nossas atividades, porém elas não se encontram no Script de trabalho para o momento. Assim, podemos criar um Script auxiliar que armazenas todas as funções criadas para as análises desejadas, e no Script corrente, poderemos chamá-las sem precisar abri o Script auxiliar. Todos os objetos passam a estar disponíveis no ambiente global.\r\n\r\nPor fim, algo de muita importância para um programador, comente suas linhas de comando. Mas faça isso a partir do primeiro dia em que você criou o seu primeiro Script. Isso criará um hábito, uma vez que o arquivo não está sendo criado apenas para um momento, mas para futuras consultas. E quando voltamos a Scripts com muitas linhas de comando, principalmente depois de algum tempo, e sem comentários, possivelmente você passará alguns instantes para tentar entender o que foi escrito.\r\nOutra coisa importante, é a boa prática de escrita de um código, e o RStudio nos proporciona algumas ferramentas interessantes. Mas isso será visto mais a frente.\r\n Objetos\r\n\r\n\r\nDefinimos um objeto como uma entidade no ambiente R com características internas contendo informações necessárias para interpretar sua estrutura e conteúdo. Essas características são chamadas de atributos. Vamos entender o termo estrutura como a disposição de como está o seu conteúdo. Por exemplo, a estrutura de um objeto mais simples no R é um vetor atômico, pois os elementos contidos nele, apresenta o mesmo modo, um tipo de atributo. Falaremos nisso, mais à frente. De forma didática, adaptaremos a representação dos objetos no formato de diagrama.\r\nVejamos o seguinte código:\r\n\r\n\r\nx <- 10\r\n\r\n\r\n\r\nTodo mundo que tem uma certa noção sobre a linguagem R afirmaria: “criei um objeto x que recebe o valor 10.” Para Wickham (2019) essa afirmação é imprecisa e pode levar um entendimento equivocado sobre o que acontece de fato. Para o mesmo autor, o correto é afirmar que o objeto 10 está se ligando a um nome. E de fato, o objeto não tem um nome, mas o nome tem um objeto. O símbolo que associa um objeto a um nome é o de atribuição, <-, isto é, a junção do símbolo desigualdade menor e o símbolo de menos. Para ver qual objeto associado ao nome, o usuário precisa apenas digitar o nome no console e apertar a tecla ENTER.\r\nRepresentaremos em termos de diagrama, um nome se ligando a um objeto, na Figura 8.\r\n\r\n\r\n\r\nFigure 8: Dizemos que o nome 'x' se liga ao objeto do tipo (estrutura) vetor.\r\n\r\n\r\n\r\nO identificador na memoría ativa desse objeto pode ser obtida por:\r\n\r\n\r\nlobstr::obj_addr(x)\r\n# [1] \"0xf8a104fc20\"\r\n\r\n\r\n\r\nO diagrama explica que o nome criado “x” se associou com um objeto do tipo (estrutura) vetor (vector) e modo numérico (numeric)14, cuja identificação na memória ativa do seu computador foi <0xf8a104fc20>. É claro que para cada vez que o usuário abri o ambiente R e executar novamente esse comando, ou repeti o comando, esse identificador irá alterar.\r\nEssa outra representação ficará mais claro para a afirmação feita anteriormente, no segundo diagrama, Figura 9, que representa a ligação do nome “y” ao mesmo objeto. Os termos nos diagramas, serão usados de acordo com a sintaxe da linguagem com os termos em inglês para melhor compreensão e fixação dos termos utilizados em R, uma vez que os termos na linguagem são baseados nesse idioma.\r\n\r\n\r\ny <- x\r\nlobstr::obj_addr(y)\r\n# [1] \"0xf8a104fc20\"\r\n\r\n\r\n\r\nObservem que não houve a criação de um outro objeto, mas apenas a ligação de mais um nome ao objeto existente, pois o identificador na memória ativa para o objeto não alterou, é o mesmo. Logo, não temos um outro objeto, mais dois nomes que se ligam ao mesmo objeto.\r\n\r\n\r\n\r\nFigure 9: Dizemos que o nome 'x' e ‘y’ se ligam ao objeto do tipo (estrutura) vetor.\r\n\r\n\r\n\r\nMais especificamente, acrescentamos um outro diagrama, Figura 10, mostrando a representação do ambiente global (.GlobalEnv, nome associado ao objeto que representa o ambiente global).\r\n\r\n\r\n\r\nFigure 10: Dizemos que o nome 'x' e 'y' se ligam ao objeto do tipo (estrutura) vetor e essa ligação fica armazenada no ambiente global.\r\n\r\n\r\n\r\nDe todo modo, deixaremos para o módulo Programação em R (Nível Intermediário), uma abordagem mais profunda sobre o assunto.\r\nO símbolo de atribuição poderá ser representado na direção da esquerda para à direita ou vice-versa, isto é,\r\n\r\n\r\nx <- 10\r\n10 -> x\r\n\r\n\r\n\r\nEssas duas linhas de comando anteriores podem ter passado despercebidas pelo leitor em uma situação. Se na segunda linha tivéssemos alterado o valor do objeto de 10 para 30, por exemplo, a associação de x seria ao objeto 30. Isso significa que se o nome já existe, ele será apagado da memória ativa do computador e associado ao novo objeto. Veja,\r\n\r\n\r\nlobstr::obj_addr(x)\r\n# [1] \"0xf8a104fc20\"\r\nx <- 30\r\nlobstr::obj_addr(x)\r\n# [1] \"0x42db6dbb50\"\r\n\r\n\r\n\r\nUma outra forma menos convencional é usar o comando assign, veja:\r\n\r\n\r\nassign(\"m\", 15)\r\nm\r\n\r\n\r\n[1] 15\r\n\r\nAo invés do símbolo de atribuição, muitos usuários utilizam o símbolo da igualdade “=” para associarmos nomes aos objetos, que o ambiente R compreenderá. Contudo, discutiremos mas adiante, em Boas práticas de como escrever um código, que o uso da igualdade deverá em R ser usado apenas para a utilização em argumentos de uma função.\r\nQuando desejamos executar mais de uma linha de comando por vez, separamos estas pelo símbolo “;” isto é,\r\n\r\n\r\nx <- 10; w <- 15; x; w\r\n\r\n\r\n[1] 10\r\n[1] 15\r\n\r\nNeste caso, executamos quatro comandos em uma linha. Associamos dois nomes a dois objetos e imprimimos os seus valores.\r\nPor questão de comodidade, iremos a partir de agora, sempre nos referir a um objeto pelo nome associado a ele, para não está sempre se expressando como “um nome associado a um objeto.” Mas que fique claro a discussão realizada anteriormente sobre esses conceitos.\r\nNesse momento, nos limitaremos a falar sobre objetos que armazenam dados, do tipo caracteres, números e operadores lógicos (TRUE/FALSE).\r\nAtributos\r\nTodos os objetos, terão pelo menos dois tipos de atributos, chamados de atributos intrínsecos. Os demais atributos, quando existem, podem ser verificados pela função attributes(). A ideia dos atributos pode ser pensada como metadados, isto é, um conjunto de informações que caracterizam o objeto.\r\nDiremos também que todos os objetos R tem uma classe, e por meio dessas classes, determinadas funções podem ter comportamento diferente a objetos com classes diferentes. Agora, devemos deixar claro essa informação, apesar do R seguir o princípio do Objeto, nem tudo é orientado a objetos, como por exemplo, observamos na linguagens C++ e Java. Deixemos esse tópico para o módulo Programação em R (Nível Intermediário).\r\nA forma de se verificar a classe de um objeto é pela função class(). Contudo, os objetos internos do R (base), quando solicitado sua classe pela função class(), acabam retornando, algumas vezes, resultados equivocados. Uma alternativa é utilizar a função sloop::s3_class() do pacote sloop. Isso também será discutido no módulo Programação em R (Nível Intermedirário).\r\nDevemos estar atentos a uma questão. Existe um atributo também chamado classe (“class”), e nem todos os objetos necessariamente tem esse atributo, apenas aqueles orientados a objetos, como é o caso do objeto com atributo classe . Por exemplo, é devido a classe factor no objeto criado pela função factor() que apesar do seu resultado ser numérico, este não se comporta como numérico. Isto significa que o atributo classe muda o comportamento de como funções veem esse objeto.\r\nPara verificarmos se tal objeto tem o atributo class, usamos a função attributes(). Quando este atributo existe, ele é coincidente com o resultado obtido também pela função class().\r\nO tipo das classes podem ser numeric, logical, character, list, matrix, array, factor e data.frame. Por enquanto, nos concentraremos nas classes de objetos que armazenam dados para uso em análises.\r\nPara remover o efeito da classe, usamos a função unclass() para tal.\r\nPor exemplo, quando criamos um objeto da classe data.frame, vejamos o seu comportamento:\r\n\r\n\r\n# Criamos um objeto de classe 'data.frame'\r\ndados <- data.frame(a = 1:3, b = LETTERS[1:3])\r\n\r\n# Imprimindo na tela\r\ndados\r\n\r\n\r\n  a b\r\n1 1 A\r\n2 2 B\r\n3 3 C\r\n\r\n# Verificando sua classe\r\nclass(dados)\r\n\r\n\r\n[1] \"data.frame\"\r\n\r\n# Verificando o efeito do objeto 'dados',\r\n# sem o efeito da classe\r\ndados2 <- unclass(dados); dados2\r\n\r\n\r\n$a\r\n[1] 1 2 3\r\n\r\n$b\r\n[1] \"A\" \"B\" \"C\"\r\n\r\nattr(,\"row.names\")\r\n[1] 1 2 3\r\n\r\n# Qual a classe desse objeto sem o efeito da\r\n# classe 'data.frame'\r\nclass(dados2)\r\n\r\n\r\n[1] \"list\"\r\n\r\nObserve que sem o atributo class= 'data.frame', o objeto tem classe list. Isto significa que, o objeto tem uma estrutura em forma de list, mas se comporta como um data.frame, que se apresenta como mostrado anteriormente.\r\nVeremos no módulo Programação em R (Nível Intermediário) como criar atributos, classes, e mostrar que não conseguiremos mostrar todos os tipos de classes, pois a todo momento se cria classes em objetos R no desenvolvimento de pacotes.\r\nAtributos intrínsecos\r\nTodos os objetos tem dois atributos intrínsecos: o modo e comprimento. O modo representa a natureza dos elementos objetos. Para o caso dos vetores atômicos, o modo dos vetores podem ser cinco, numérico (numeric), lógico (logic), caractere15 (character), complexo (complex) ou bruto (`raw``). Este último, não daremos evidência para esse momento. O comprimento mede a quantidade de elementos no objeto.\r\nPara determinarmos o modo de um objeto, usamos a função mode(). Vejamos:\r\n\r\n\r\n# Objeto modo caractere\r\nx <- \"Ben\"; mode(x)\r\n\r\n\r\n[1] \"character\"\r\n\r\n# Objeto modo numerico\r\ny <- 10L; mode(y)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\n# Objeto modo numerico\r\ny2 <- 10; mode(y2)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\n# Objeto modo logico\r\nz <- TRUE; mode(z)\r\n\r\n\r\n[1] \"logical\"\r\n\r\n# Objeto modo complexo\r\nw <- 1i; mode(w)\r\n\r\n\r\n[1] \"complex\"\r\n\r\nContudo, essa função mode() se baseou nos atributos baseados na linguagem S. Temos uma outra função para verificarmos o modo do objeto que é typeof(). O atributo modo retornado de um objeto para esta última função, está relacionado a tipagem de variáveis da linguagem C, uma vez que boa parte das rotinas no R está nessa linguagem, principalmente as funções do pacote base. Existem 25 tipos que serão detalhados no módulo Programação em R (Nível Intermedirário).\r\n\r\n\r\n# Objeto modo caractere\r\nx <- \"Ben\"; typeof(x)\r\n\r\n\r\n[1] \"character\"\r\n\r\n# Objeto modo numerico (Inteiro)\r\ny <- 10L; typeof(y) \r\n\r\n\r\n[1] \"integer\"\r\n\r\n# Objeto modo numerico (Real)\r\ny2 <- 10; typeof(y2)\r\n\r\n\r\n[1] \"double\"\r\n\r\n# Objeto modo logico\r\nz <- TRUE; typeof(z)\r\n\r\n\r\n[1] \"logical\"\r\n\r\n# Objeto modo complexo\r\nw <- 1i; typeof(w)\r\n\r\n\r\n[1] \"complex\"\r\n\r\nObservamos que apesar de alguns vetores serem vazios, estes ainda tem um modo, observe nas seguintes linhas de comando:\r\n\r\n\r\n# Vetor numérico vazio de comprimento 1\r\nnumeric(0)\r\n\r\n\r\nnumeric(0)\r\n\r\n# Verificando o seu modo\r\nmode(numeric(0))\r\n\r\n\r\n[1] \"numeric\"\r\n\r\ntypeof(numeric(0))\r\n\r\n\r\n[1] \"double\"\r\n\r\n# Vetor caractere vazio de comprimento 1\r\ncharacter(0)\r\n\r\n\r\ncharacter(0)\r\n\r\n# Verificando o seu modo\r\nmode(character(0))\r\n\r\n\r\n[1] \"character\"\r\n\r\ntypeof(character(0))\r\n\r\n\r\n[1] \"character\"\r\n\r\nA diferença existente nos objetos y e y2 para as funções mode() e typeof() se referem apenas como o R armazena essas informações na memória do computador. Podemos perguntar ao R se dois números são iguais, assim:\r\n\r\n\r\n# 10 eh igual a 10L ?\r\n10 == 10L\r\n\r\n\r\n[1] TRUE\r\n\r\nVeja que o resultado é TRUE, isto é, sim eles são iguais. Agora, veja a próxima linha de comando:\r\n\r\n\r\n# 10 eh igual a 10L ?\r\nidentical(10, 10L)\r\n\r\n\r\n[1] FALSE\r\n\r\nO retorno agora foi FALSE, que significa que o armazenamento dessas informações não são iguais. Posteriormente, entenderemos no que isso reflete no código usuário, uma vez que um código escrito pode uma perda de desempenho simplesmente pela não necessidade de determinados objetos ou cópias realizadas.\r\nO termo double retornado pela função typeof() significa dupla precisão na linguagem de programação, que acaba tenho uma exigência de mais memória do que o objeto de modo integer. Esses termos são utilizados na linguagem C. Já a linguagem S não os diferencia, utiliza tudo como numeric.\r\nAqui vale um destaque para o termo numérico, que no R podem ter três significados:\r\nPode significar um número real, isto é, para a computação um número de dupla precisão (numeric e double seriam iguais nesse aspecto). Veja linha de código:\r\n\r\n\r\n# Criacao de dois objetos de modo numerico\r\na <- numeric(1); b <- double(1)\r\n# Verificando o modo\r\nmode(a); mode(b)\r\n\r\n\r\n[1] \"numeric\"\r\n[1] \"numeric\"\r\n\r\n# Verificando se 'a' e 'b' sao identificos\r\nidentical(a, b)\r\n\r\n\r\n[1] TRUE\r\n\r\nnos sistemas S3 e S4 (orientação a objetos), o termo numérico é usado como atalho para o modo integer ou double. Esse ponto veremos no módulo Programação em R (Nível Básico). Contudo, veja a linha de código:\r\n\r\n\r\nsloop::s3_class(1)\r\n\r\n\r\n[1] \"double\"  \"numeric\"\r\n\r\nsloop::s3_class(1L)\r\n\r\n\r\n[1] \"integer\" \"numeric\"\r\n\r\nPode ser utilizado (is.numeric()) para verificar se determinados objetos tem o modo numérico. Por exemplo, temos um objeto de classe factor que é importante para a área da estatística experimental, representando os níveis de um fator em um experimento. Os elementos desse objeto pode ser número ou caracteres, mas serão representados como sempre por números. Entretanto, não se comportam como numérico. Veja a linha de comando:\r\n\r\n\r\n# Criando um objeto de atributo classe 'factor':\r\nfator <- factor(\"a\"); fator\r\n\r\n\r\n[1] a\r\nLevels: a\r\n\r\n# O atributo classe muda a forma dos elementos. Veja quando retiramos o atributo \r\n# classe 'factor', o objeto retorna o valor 1\r\nunclass(fator)\r\n\r\n\r\n[1] 1\r\nattr(,\"levels\")\r\n[1] \"a\"\r\n\r\n# Para confirmar essa afirmacao anterior, vejamos o modo\r\nmode(fator)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\ntypeof(fator)\r\n\r\n\r\n[1] \"integer\"\r\n\r\n# Apesar do resultado retornar 1, veja que ele nao se comporta como numerico\r\nis.numeric(fator)\r\n\r\n\r\n[1] FALSE\r\n\r\nis.integer(fator)\r\n\r\n\r\n[1] FALSE\r\n\r\nUma tabela a seguir, mostra o retorno dos seis principais modos de um objeto do tipo (estrutura) de vetores atômicos (Os modos apresentados baseiam-se apenas quanto a característica dos dados do objeto. É claro que um objeto não armazena apenas dados. Existem outras naturezas, que serão omitidas nesse momento):\r\ntypeof\r\nmode\r\nlogical\r\nlogical\r\ninteger\r\nnumeric\r\ndouble\r\nnumeric\r\ncomplex\r\ncomplex\r\ncharacter\r\ncharacter\r\nraw\r\nraw\r\nO comprimento do objeto é informado pela função lenght(), do qual a representação em diagrama informa esse atributo. Vejamos as linhas de comando a seguir.\r\n\r\n\r\n# Vetor de comprimento 5\r\nv1 <- 1:5\r\n\r\n# Vetor de comprimento 3\r\nv2 <- c(\"Ben\", \"Maria\", \"Lana\")\r\n\r\n# Vetor de comprimento quatro\r\nv3 <- c(TRUE, FALSE, TRUE, TRUE)\r\n\r\n# Vejamos o comprimento dos vetores\r\nlength(v1)\r\n\r\n\r\n[1] 5\r\n\r\nlength(v2)\r\n\r\n\r\n[1] 3\r\n\r\nlength(v3)\r\n\r\n\r\n[1] 4\r\n\r\nUm diagrama apresentando esses três objetos no ambiente global, pode ser apresentado na Figura 11. Observe que acrescentamos agora o comprimento dos objetos no diagrama entre colchetes, ao lado do atributo modo.\r\n\r\n\r\n\r\nFigure 11: Objetos v1, v2 e v3.\r\n\r\n\r\n\r\nUm resumo as funções mensionadas podem ser refletidas com as seguintes indagações:\r\nbase::class() e loop::c3_class(): Qual o tipo de objeto?\r\nbase::mode(): Qual o tipo de dados baseados na linguagem S?\r\nbase::typeof(): Qual o tipo de dados baseados na linguagem C?\r\nbase::attributes(): O objeto tem atributos?\r\nbase::length(): Qual o comprimento do objeto?\r\nUsamos essa sintaxe pacote::nome_função() para entedermos qual o pacote da função que utilizamos. Contudo, essa forma tem uma importância no sentido de acesso a funções em um pacote sem necessitar anexá-lo no caminho de busca. Assunto abordado mais a frente.\r\nCoersão\r\nComo falamos anteriormente, os vetores atômicos armazenam um conjunto de elementos de mesmo modo. A coerção é a forma como o R coage o modo dos objetos. Por exemplo, se um elemento de modo caractere estiver em um vetor, todos os demais elementos serão convertidos para esse modo. Veja:\r\n\r\n\r\n# Criando um objeto x e imprimindo o seu resultado\r\nx <- c(\"Nome\", 3, 4, 5);x\r\n\r\n\r\n[1] \"Nome\" \"3\"    \"4\"    \"5\"   \r\n\r\nObserva que todos os elementos ganharam aspas, isto é, se tornaram um caractere ou uma cadeia de caracteres. A coersão entre vetores de modo numeric, character e logical será sempre assim:\r\n\r\n\r\nNo caso dos vetores lógicos, todo TRUE se converterá em 1, e FALSE em 0. Porém, os modos dos vetores podem ser coagidos pelo usuário, usando as funções do tipo as.<modo ou tipo>() com prefixo as., isto é, se desejarmos que um objeto meu_objeto tenha o modo “character,” basta usar as.character(meu_objeto). Para desejar saber se um objeto é de um determinado modo, usamos as funções do tipo is.<modo ou tipo>(), com o prefixo is.. Vejamos,\r\n\r\n\r\n# Objeto de modo numerico\r\nminha_idade <- 35\r\nmode(minha_idade)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\n# Coersão do objeto para modo caractere (`string`)\r\nminha_idade <- as.character(minha_idade)\r\nmode(minha_idade)\r\n\r\n\r\n[1] \"character\"\r\n\r\n# Verificando se o objeto tem modo 'character'\r\nis.character(minha_idade)\r\n\r\n\r\n[1] TRUE\r\n\r\nTipo de objetos\r\nPor fim, pretendemos falar sobre os principais tipos de objetos. O tipo vamos entender como a estrutura de como os dados estão organizados em um objeto, relacionados aos seus atributos. Falamos anteriormente sobre a estrutura mais simples, que é o vetor atômico. Mas entendemos que um vetor em R podem ser considerados: atômicos ou listas. Podemos então subdividi-los em:\r\nVetores atômicos:\r\nLógicos, Numéricos e Caracteres;\r\nMatrizes unidimensionais (Matrix) e multidimensionais (Arrays);\r\n\r\nVetores em listas:\r\nListas (Lists);\r\nQuadro de dados (Data frames);\r\n\r\nExistem outros, mas para esse módulo, exploraremos estes nas seções seguintes. As funções para as coersões realizadas pelos usuários, são similares as funções de coersão para modo, isto é, usar as funções prefixadas as.<tipo>.\r\nDaremos uma visão geral dos objetos apresentados até o momento na Tabela a seguir.\r\nObjeto\r\nClasse\r\nModo\r\nSão possíveis vários modos no mesmo objeto?\r\nVetor\r\nnumeric (integer ou double), character, complex, logical, raw\r\nnumeric (integer ou double), character, complex, logical, raw\r\nNão\r\nMatriz\r\nmatrix\r\nnumeric (integer ou double), character, complex, logical, raw\r\nNão\r\nArray\r\narray\r\nnumeric (integer ou double), character, complex, logical, raw\r\nNão\r\nlista\r\nlist\r\nnumeric (integer ou double), character, complex, logical, raw, expression, function\r\nSim\r\nQuadro de dados\r\ndata.frame\r\nnumeric (integer ou double), character, complex, logical, raw\r\nSim\r\n Vetores\r\nPodemos dizer que existem três tipos principais de vetores atômicos:\r\nNuméricos (numeric):\r\nInteiro (integer);\r\nReal (double);\r\n\r\nLógico (logical);\r\nCaractere (character)\r\nExistem dois tipos raros que são os complexos (complex) e brutos (raw), que falaremos no módulo seguinte.\r\nEscalares\r\nO menor comprimento de um vetor é de tamanho um, conhecido também como um escalar. Porém, para o R tudo é observado como um vetor. As sintaxes para os tipos especiais são: - os vetores lógicos assumem valores: TRUE ou FALSE, ou abreviados, T ou F, respectivamente. Existem valores especiais devido a precisão de operações na programação, que são os chamados pontos flutuantes. Nesse caso temos: Inf, -Inf e NaN, quando o resultados tende a \\(\\infty\\), \\(-\\infty\\), sem número, respectivamente;\r\n\r\n\r\n# divisao de um numero por zero (+ infinito)\r\nx <- 50 / 0; x\r\n\r\n\r\n[1] Inf\r\n\r\n# divisao de um numero por zero (- infinito)\r\n-50 / 0\r\n\r\n\r\n[1] -Inf\r\n\r\n# Resultado sem número do tipo NaN\r\nx - x\r\n\r\n\r\n[1] NaN\r\n\r\nos vetores numéricos do tipo double podem ser representados de forma decima (0.123), científica (1.23e5), ou hexadecimal (3E0A);\r\nos vetores numéricos do tipo integer são representados pela letra L ao final do número inteiro, isto é, 1L, 1.23e5L, etc.;\r\nos caracteres são representados pelas palavras, letras, números ou caracteres especiais entre aspas, isto é, \"Ben\", \"a\". Pode ser utilizado também aspa simples, 'Ben', 'a', etc.\r\nVetores longos\r\nOs vetores longos podem ser criados pela função c() a incial da palavra concatenar, que significa agrupar. Vejamos alguns exemplos:\r\n\r\n\r\n# Criando um vetor 'double'\r\nvetor.num <- c(1, 2, 3, 4, 5); vetor.num\r\n\r\n\r\n[1] 1 2 3 4 5\r\n\r\ntypeof(vetor.num)\r\n\r\n\r\n[1] \"double\"\r\n\r\nUma coisa interessante é que por padrão, a função c() sempre cria um vetor de modo double, a menos que o usuário determine que estes elementos sejam inteiros, isto é,\r\n\r\n\r\n# Criando um vetor 'integer'\r\nvetor.num2 <- c(1L, 2L, 3L, 4L, 5L); vetor.num; typeof(vetor.num2)\r\n\r\n\r\n[1] 1 2 3 4 5\r\n[1] \"integer\"\r\n\r\nUma forma mais eficiente para criarmos um vetor com elementos de sequências regulares, é por meio da função primitiva (:), isto é, <menor valor da sequência>:<maior valor da sequência>. Vejamos:\r\n\r\n\r\n# Criando uma sequência de 1 a 5\r\nvetor.num3 <- 1:5; vetor.num3; typeof(vetor.num3)\r\n\r\n\r\n[1] 1 2 3 4 5\r\n[1] \"integer\"\r\n\r\nVeremos mais a frente outras funções para construir sequências regulares. Se verificarmos os três objetos, veremos que todos eles são iguais:\r\n\r\n\r\n\r\n\r\n\r\nvetor.num == vetor.num2\r\n\r\n\r\n[1] TRUE TRUE TRUE TRUE TRUE\r\n\r\nvetor.num == vetor.num3\r\n\r\n\r\n[1] TRUE TRUE TRUE TRUE TRUE\r\n\r\nvetor.num2 == vetor.num3\r\n\r\n\r\n[1] TRUE TRUE TRUE TRUE TRUE\r\n\r\nO que vai difenrenciá-los é a forma de armazená-lo (double ou integer), e por consequência, o espaço na memória ativa. Veja:\r\n\r\n\r\n# Objetos:\r\nvetor.num <- c(1, 2, 3, 4, 5)\r\nvetor.num2 <- c(1L, 2L, 3L, 4L, 5L)\r\nvetor.num3 <- 1:5\r\n# Memoria:\r\nlobstr::obj_size(vetor.num)\r\n\r\n\r\n96 B\r\n\r\nlobstr::obj_size(vetor.num2)\r\n\r\n\r\n80 B\r\n\r\nlobstr::obj_size(vetor.num3)\r\n\r\n\r\n680 B\r\n\r\nO que podemos observar é que o vetor de modo double precisa de mais memória do que o objeto de modo integer. O último objeto aparentemente ocupou mais memória. Contudo, essa função apresenta um recurso interessante apresentado nas versões posteriores R (3.5.0), que é chamado de abreviação alternativa. Esse recurso faz com que a sequência de números não seja armazenada completamente, apenas os extremos. Isso significa que para qualquer tamanho de sequência, a ocupação de memória do objeto será sempre a mesma. Outras formas de criar sequência de números é usando as funções rep() e seq(), do qual a ajuda pode ser realizada usando no console ?rep() e ?seq(), respectivamente.\r\nDessa forma, poderemos ter com o último objeto (vetor.num3) uma economia de memória, dependendo do tamanho do seu vetor, quando se compara com as outras opções. Veja:\r\n\r\n\r\n# Tamanho de memoria dos objetos\r\nlobstr::obj_size(1:10)\r\n\r\n\r\n680 B\r\n\r\nlobstr::obj_size(1:10000)\r\n\r\n\r\n680 B\r\n\r\nlobstr::obj_size(1:1000000)\r\n\r\n\r\n680 B\r\n\r\nlobstr::obj_size(c(1:10))\r\n\r\n\r\n96 B\r\n\r\nlobstr::obj_size(c(1:10000))\r\n\r\n\r\n40,048 B\r\n\r\nlobstr::obj_size(c(1:1000000))\r\n\r\n\r\n4,000,048 B\r\n\r\nManipulando vetores\r\nQuando algum elemento de um vetor não está disponível, representamos pela constante lógica NA, que pode ser coagida para qualquer outro modo de vetor, exceto para raw. Podemos ter constantes lógicas NA específicas para modos específicos: NA_integer_, NA_real_ (o equivalente para o modo double), NA_complex_ e NA_character_. Entretando, dependendo de onde o NA é inserido, o atributo modo no objeto já converte para NA específico de acordo com o seu atributo modo. Essa constante contido no vetor não altera o modo do vetor, isto é,\r\n\r\n\r\ntypeof(c(1, 2, 3, NA))\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(c(1, 2, 3, NA))\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(c(\"c\", \"b\", \"a\", NA))\r\n\r\n\r\n[1] \"character\"\r\n\r\nPodemos criar vetores atômicos iniciais sem nenhuma elemento, por meio das funções numeric(0), character(0) e logical(0), isto é,\r\n\r\n\r\n# Vetor numerico de comprimento 0\r\nv1 <- numeric(0); length(v1)\r\n\r\n\r\n[1] 0\r\n\r\nv2 <- character(0); length(v2)\r\n\r\n\r\n[1] 0\r\n\r\nv3 <- logical(0); length(v2)\r\n\r\n\r\n[1] 0\r\n\r\nPara inserirmos valores a esses vetores usamos o sistema de indexação, que no caso da linguagem R, o contador começa a partir do número 116. Vejamos,\r\n\r\n[1] 0\r\n[1] 0\r\n[1] 0\r\n\r\n\r\n\r\n# Vetor numerico de comprimento 0\r\nv1 <- numeric(0)\r\nv2 <- character(0)\r\nv3 <- logical(0)\r\n# Inserimos 3 elementos em v1 e depois imprimos o seu resultado\r\nv1[1] <- 5; v1[2] <- 3; v1[3] <- 10; v1; length(v1)\r\n\r\n\r\n[1]  5  3 10\r\n[1] 3\r\n\r\nAssim, como exercício vocês podem completar para os dois outros vetores. Uma vez criado o vetor, se desejarmos acessar os seus elementos, usamos também o sistema de indexação:\r\n\r\n\r\n# Vetor numerico de comprimento 0\r\nv1 <- numeric(0)\r\nv2 <- character(0)\r\nv3 <- logical(0)\r\n\r\n# Inserimos 3 elementos em v1 e depois imprimos o seu resultado\r\nv1[1] <- 5; v1[2] <- 3; v1[3] <- 10\r\n\r\n# Imprimindo apenas o primeiro valor\r\nv1[1]\r\n\r\n\r\n[1] 5\r\n\r\n# Imprimindo os dois ultimos\r\nv1[2:3]; v1[c(2, 3)]\r\n\r\n\r\n[1]  3 10\r\n[1]  3 10\r\n\r\n# Imprimindo todos\r\nv1\r\n\r\n\r\n[1]  5  3 10\r\n\r\nAritmética e outras operações\r\nAs operações com vetores não necessariamente são as operações realizadas baseadas na álgebra de matrizes. O que a linguagem R faz é realizar as operações elemento a elemento, mantendo o comprimento de tamanho igual ao tamanho do maior vetor na operação. Vejamos as operações aritméticas entre vetores de tamanho 1:\r\n\r\n\r\n# Soma de dois vetores\r\n2 + 3\r\n\r\n\r\n[1] 5\r\n\r\n# Exceto pela sintaxe, '+' eh uma chamada de funcao\r\n`+`(2, 3)\r\n\r\n\r\n[1] 5\r\n\r\n# Subtracao de dois vetores\r\n3 - 2\r\n\r\n\r\n[1] 1\r\n\r\n# Exceto pela sintaxe, '-' eh uma chamada de funcao\r\n`-`(3, 2)\r\n\r\n\r\n[1] 1\r\n\r\n# Multiplicacao de dois vetores\r\n3 * 2\r\n\r\n\r\n[1] 6\r\n\r\n# Exceto pela sintaxe, '*' eh uma chamada de funcao\r\n`*`(3, 2)\r\n\r\n\r\n[1] 6\r\n\r\n# Divisao de dois vetores\r\n3 / 2\r\n\r\n\r\n[1] 1.5\r\n\r\n# Exceto pela sintaxe, '/' eh uma chamada de funcao\r\n`/`(3, 2)\r\n\r\n\r\n[1] 1.5\r\n\r\nEssas mesmas operações podem ser realizadas elemento a elemento para vetores de comprimento maior que 1, observe:\r\n\r\n\r\n# Soma de vetores\r\nc(4, 5, 6) + c(1, 2, 3)\r\n\r\n\r\n[1] 5 7 9\r\n\r\n# Subtracao de  vetores\r\nc(4, 5, 6) + c(1, 2, 3)\r\n\r\n\r\n[1] 5 7 9\r\n\r\n# Multiplicacao dois vetores\r\nc(4, 5, 6) * c(1, 2, 3)\r\n\r\n\r\n[1]  4 10 18\r\n\r\n# Divisao de dois vetores\r\nc(4, 5, 6) / c(1, 2, 3)\r\n\r\n\r\n[1] 4.0 2.5 2.0\r\n\r\nQuando os vetores não têm mesmo comprimento, o R completará de forma sequencial o menor vetor até que ele atinja o tamanho do maior vetor, observe:\r\n\r\n\r\n# Soma de vetores de comprimento diferente\r\n1:10 + 3:10\r\n\r\n\r\n [1]  4  6  8 10 12 14 16 18 12 14\r\n\r\nO segundo vetor recebeu os elementos 3, 4, 5, isto é, os três primeiros elementos do vetor, para que o seu comprimento se tornasse igual ao comprimento do primeiro vetor. Após isso, foi realizado a soma elemento a elemento. Esse provedimento ocorre com os demais tipos de operações.\r\nDemais operações podem ser realizadas de acordo com as funções apresentadas na Tabela abaixo.\r\nFunção (Ou operador)\r\nFinalidade\r\n+\r\nSoma unária, por exemplo (+ 4), ou binária entre dois vetores\r\n-\r\nSubtração unária, por exemplo (- 3), ou binária entre dois vetores\r\n*\r\nMultiplicação entre dois vetores\r\n/\r\nDivisão entre dois vetores\r\n^ ou **\r\nExpoenciação binária, isto é 2^3 ou 2 ** 3\r\n%/%\r\nDivisão inteira\r\n%%\r\nRestante da divisão\r\nsum()\r\nSoma de elementos do vetor\r\nprod()\r\nProdutório dos elementos do vetor\r\nsqrt()\r\nRaiz quadrada dos elementos de um vetor\r\nlog()\r\nFunção Logaritmo neperiano\r\nlog10()\r\nFunção Logaritmo na base 10\r\nexp()\r\nFunção exponencial\r\nmean()\r\nMédia dos elementos de um vetor\r\nsd()\r\nDesvio padrão dos elementos de um vetor\r\nvar()\r\nVariância dos elementos de um vetor\r\nmedian()\r\nMediana dos elementos de um vetor\r\nround()\r\nArredondamento de vetor numérico. Outros tipos são: trunc(), floor() e ceiling().\r\nDemais funções podem ser procuradas no manual An Introduction to R, ou execute no console ?Arithmetic.\r\nOperadores lógicos\r\nOs operadores lógicos têm a função de avaliar determinada condição e retornar TRUE/FALSE. São eles:\r\nOperador Lógico\r\nSintaxe\r\nPergunta\r\n<\r\na < b\r\na é menor que b?\r\n>\r\na > b\r\na é maior que b?\r\n==\r\na == b\r\na é igual b?\r\n!=\r\na != b\r\na é diferente b?\r\n>=\r\na >= b\r\na é maior ou igual a b\r\n<=\r\na <= b\r\na é menor ou igual a b?\r\n%in%\r\n\"a\" %in% c(\"a\", \"b\", \"c\")\r\nO elemento \"a\" está no vetor c(\"a\", \"b\", \"c\")?\r\nA operação binária significa que a função exige dois argumentos (ou operandos), isto é, <Argumento 1> <Operador> <Argumento 2>. Para mais detalhes, use no console ?Syntax.\r\nVejamos alguns exemplos:\r\n\r\n\r\n# Operador '>' entre vetores de comprimento 1\r\n1 > 3\r\n\r\n\r\n[1] FALSE\r\n\r\n# Operador '<' com vetor de comprimento maior que 1\r\n1 < c(0, 1, 3)\r\n\r\n\r\n[1] FALSE FALSE  TRUE\r\n\r\n# Operador '==' entre vetores\r\nc(1, 2, 3) == c(3, 2, 1)\r\n\r\n\r\n[1] FALSE  TRUE FALSE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\n1 %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\nc(1, 2) %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE FALSE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\nc(1, 2, 3) %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE FALSE  TRUE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\nc(1, 2, 3, 4) %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE FALSE  TRUE  TRUE\r\n\r\nO que é interessante nesse operador %in%, que na realidade é uma função com dois argumentos, constitui uma forma de criar operadores binários especiais do tipo %<nome_sintatico>%, que esse tipo de função é uma das mais conhecidas hoje na análise de dados usando o operador pipe (%>%) do pacote magrittr da família de pacotes Tidyverse. A diferença no operador pipe é que o segundo operando (Argumento 2) é uma função que recebe no primeiro argumento o operando 1 (Argumento 1). Por fim, o operador %>% acaba sendo um operado unário. Veremos mais detalhes na seção sobre criação de funções.\r\nOperadores Booleanos\r\nO operadores booleanos avaliam diversas operações lógicas (condições) para ao final retornar um TRUE/FALSE. Vejamos a Tabela a seguir, com esses operadores e suas indagações.\r\nOperador Booleano (ou Função)\r\nSintaxe\r\nPergunta\r\n& ou &&\r\ncond1 & cond2\r\nAs cond1 e cond2 são verdadeiras?\r\n| ou ||\r\ncond1 | cond2\r\nA cond1 ou cond2 é verdadeira?\r\nxor()\r\nxor(cond1, cond2)\r\nApenas a cond1 ou a cond2 é verdadeiro?\r\n!\r\n!cond1\r\nÉ falso a cond1 ?\r\nany()\r\nany(cond1, cond2, ...)\r\nAlguma das condições são verdadeiras?\r\nall()\r\nall(cond1, cond2, ...)\r\nTodas as condições são verdadeiras?\r\nVejamos alguns exemplos:\r\n\r\n\r\n# Criando objetos\r\nx <- 1:3\r\ny <- 1:3\r\nz <- c(1, 2, 4)\r\n\r\n# Primeira condicao\r\nx == y\r\n\r\n\r\n[1] TRUE TRUE TRUE\r\n\r\n# Segunda condicao\r\ny == z\r\n\r\n\r\n[1]  TRUE  TRUE FALSE\r\n\r\n# Terceira condicao\r\nx == y & y == z\r\n\r\n\r\n[1]  TRUE  TRUE FALSE\r\n\r\nFica como sugestão de exercício os leitores criarem condições para os demais operadores booleanos.\r\n Matrizes bidimensionais\r\nA apresentação dos próximos objetos daqui pra frente, desde matrizes até quadro de dados (data frame) não é apresentar todas as manipulações possíveis sobre esses objetos. Mas mostrar a sua estrutura e condições básicas imposta sobre eles. Assim, não apresentaremos funções para manipulações com matrizes, por exemplo, porque isso não é o propósito do curso. Daremos a ideia de uma matriz é na realidade um vetor bidimensional, assim como um quadro de dados que na realidade é uma lista.\r\nQuando usamos um atributo chamado dim em um vetor atômico, criamos na realidade vetores bi ou multidimencionais, isto é, objetos do tipo matrizes ou arrays. Observe o que falados anteriormente, o atributo pode mudar a estrutura do objeto.\r\nVejamos alguns exemplos:\r\n\r\n\r\n# Criando um vetor atomico\r\nx <- 1:6; x\r\n\r\n\r\n[1] 1 2 3 4 5 6\r\n\r\n# Verificando se o objeto 'x' tem atributo adicionado\r\nattributes(x)\r\n\r\n\r\nNULL\r\n\r\n# Vamos verificar a classe do objeto x\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"integer\" \"numeric\"\r\n\r\n# Adicionando o atributo dim\r\ndim(x) <- c(2, 3) # 2 x 3 = 6 (Comp do vetor)\r\n# attr(x, \"dim\") <- c(2, 3)\r\n\r\n# Observando agora o comportamento do objeto 'x'\r\nx\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n# Verificando novamente se 'x' tem atributo\r\nattributes(x)\r\n\r\n\r\n$dim\r\n[1] 2 3\r\n\r\n# Verificando a classe do objeto\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"matrix\"  \"integer\" \"numeric\"\r\n\r\nO atributo dim recebeu uma informação bidimensional, isto é, o número de linhas e colunas, respectivamente. Uma outra forma para construir uma matriz é usando a função matrix, que de modo similar, temos:\r\n\r\n\r\n# Criando uma matriz\r\nmatrix(1:6, 2, 3)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Criando uma matriz\r\nmatrix(1:6, 2, 3, byrow = TRUE)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    2    3\r\n[2,]    4    5    6\r\n\r\nSe desejássemos que os números fossem inserido em linhas e não iniciados pelas colunas, usaríamos o argumento byrow = TRUE, isto é,\r\n\r\n\r\n# Criando uma matriz\r\nmatrix(1:6, 2, 3, byrow = TRUE)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    2    3\r\n[2,]    4    5    6\r\n\r\nPara acessarmos ou alterarmos os elementos de uma matriz, usamos o sistema de indexação similar ao vetor, porém, devemos indexar as linhas e colunas. Por exemplo, o elemento da primeira linha e primeira coluna pode ser obtido por x[1, 1], e assim por diante. Todos os elementos da linha 1, x[1,], ou todos os elementos da coluna 1, x[,1].\r\n Matriz multidimencional\r\nA ideia do objeto matriz multidimencional (ou array) é similar ao da matriz, a diferença é que agora é um vetor atômico de mais de duas dimensões. Vejamos,\r\n\r\n\r\n# Criando um vetor atomico\r\nx <- 1:12; x\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\r\n\r\n# Verificando se o objeto 'x' tem atributo adicionado\r\nattributes(x)\r\n\r\n\r\nNULL\r\n\r\n# Vamos verificar a classe do objeto x\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"integer\" \"numeric\"\r\n\r\n# Adicionando o atributo dim\r\ndim(x) <- c(2, 3, 2) # 2 x 3 x 2 = 12 (Comp do vetor x)\r\n# attr(x, \"dim\") <- c(2, 3, 2)\r\n\r\n# Observando agora o comportamento do objeto 'x'\r\nx\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n\r\n# Verificando novamente se 'x' tem atributo\r\nattributes(x)\r\n\r\n\r\n$dim\r\n[1] 2 3 2\r\n\r\n# Verificando a classe do objeto\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"array\"   \"integer\" \"numeric\"\r\n\r\nObserve que criamos duas matrizes de dimensão (2 x 3). Para acessar os elementos desse objeto, usaremos também o sistema de indexação, agora acrescentando a terceira dimensão. Por exemplo, para acessar o elemento da linha 1, coluna 1, matriz 1, temos x[1, 1, 1], ou todos os elementos da linha 1, matriz 1, temos x[1, , 1].\r\nUma outra forma de criar um objeto array é usar a função array(). De modo similar, temos:\r\n\r\n\r\n# Criando um array\r\narray(1:12, c(2, 3, 2))\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n\r\nUm exercício para os leitores seria, como poderíamos criar um array de 4 dimensões?\r\nMostramos um quadro resumo de funções que podem ser utilizadas (Wickham (2019)). Para auxílio nas funções, use sempre o símbolo de interrogação antes das funções e execute no console. Por exemplo, ajuda da função names(), use ?names().\r\nVetor\r\nMatriz\r\nArray\r\nnames()\r\nrownames(), colnames()\r\ndimnames()\r\nlength()\r\nnrow(), ncol()\r\ndim()\r\nc()\r\nrbind(), cbind()\r\nabind::abind()\r\n-\r\nt()\r\naperm()\r\nis.null(dim(x))\r\nis.matrix()\r\nis.array\r\n Listas de dados\r\nAs listas são como vetores atômicos, porém mais complexos, isto é, os elementos de uma lista são vetores atômicos, como também outras listas, funções, expressões. Esta última é o que chamamos de objetos recursivos. A forma de se obter uma lista é pela função list(). Vejamos os comandos a seguir.\r\n\r\n\r\n# Criando uma lista\r\nl0 <- list(1:3, letters[5], list(1, 2, 3),\r\n           mean, expression(x ~ y))\r\n# Imprimindo a lista\r\nl0\r\n\r\n\r\n[[1]]\r\n[1] 1 2 3\r\n\r\n[[2]]\r\n[1] \"e\"\r\n\r\n[[3]]\r\n[[3]][[1]]\r\n[1] 1\r\n\r\n[[3]][[2]]\r\n[1] 2\r\n\r\n[[3]][[3]]\r\n[1] 3\r\n\r\n\r\n[[4]]\r\nfunction (x, ...) \r\nUseMethod(\"mean\")\r\n<bytecode: 0x0000000009386b30>\r\n<environment: namespace:base>\r\n\r\n[[5]]\r\nexpression(x ~ y)\r\n\r\nPodemos acessar ou alterar os elementos de uma lista por meio do operador $, ou pelo sistema de indexação, que diferencia um pouco da indexação dos vetores. Por exemplo, o primeiro elemento desse vetor pode ser acessado por l0[[1]], o terceiro l0[[3]], e assim por diante. Para acessar informações específicas dentro dos elementos, usamos l0[[3]][2], isto é, imprimimos o segundo valor do segundo elemento. Os elementos de um lista são na realidade outros objetos, do qual conseguimos acessar também os elementos desses objetos.\r\nQuando nominamos os objetos contidos nas listas, podemos utilizar o operador $, para acessar esses objetos. Vejamos,\r\n\r\n\r\n# Criando uma lista\r\nl0 <- list(l01 = 1:3, \r\n           l02 = letters[5], \r\n           l03 = list(1, 2, 3),\r\n           l04 = mean, \r\n           l05 = expression(x ~ y))\r\n# Imprimindo o primeiro elemento (objeto) da lista 'l0'\r\nl0$l01\r\n\r\n\r\n[1] 1 2 3\r\n\r\n# Imprimindo o segundo\r\nl0$l02\r\n\r\n\r\n[1] \"e\"\r\n\r\nAs listas têm importâncias diversas dentro da linhagem R, por exemplo, o atributo em um objeto é armazenado em forma de lista. A coerção sempre força um vetor atômico a uma lista. Vejamos as linhas de comando a seguir.\r\n\r\n\r\n# Vejamos as linhas de comando\r\nl1 <- list(list(1, 2), c(3, 4))\r\nl2 <- c(list(1, 2), c(3, 4))\r\n# Vejamos as suas estruturas\r\nstr(l1)\r\n\r\n\r\nList of 2\r\n $ :List of 2\r\n  ..$ : num 1\r\n  ..$ : num 2\r\n $ : num [1:2] 3 4\r\n\r\nstr(l2)\r\n\r\n\r\nList of 4\r\n $ : num 1\r\n $ : num 2\r\n $ : num 3\r\n $ : num 4\r\n\r\nObservamos no objeto l1, temos uma lista cujos elementos são outra lista, o elemento 3 e o elemento 4. O vetor c(3, 4) se transformou em dois elementos de l1. No objeto l2, poderíamos pensar que como a lista está dentro da função c(), os elementos da lista fariam parte dos elementos de um vetor. Porém isso não ocorre. O que temos é uma coerção em que a lista força ao vetor a se tornar lista. Por fim, temos em l2 quatro elementos em uma lista.\r\n Quadro de dados\r\nO objeto quadro de dados (Data frame) é uma lista com classe data.frame, em que contém dois atributos. Porém, com algumas restrições:\r\nOs componentes devem ser vetores uni ou multidimencionais, listas ou até mesmo quadro de dados;\r\nAs colunas das matrizes, listas ou quadro de dados são inseridas como colunas do quadro de dados;\r\nA partir da versão R (4.0.0), os vetores terão mesmo modo no quadro de dados. Antes os vetores em modo caractere eram convertidos em objeto do tipo fator. Para convertê-lo automaticamente use o argumento stringsAsFactors = TRUE. Por sugestão, prefira a mudança usando a função factor(), para ter um maior controle dos níveis;\r\nOs objetos inseridos no quadro de dados devem ter o mesmo comprimento.\r\nPara criarmos um objeto do tipo quadro de dados (data frame), usamos a função data.frame(). Assim, como nas listas podemos inserir os objetos no quadro de dados inserindo o nome nas colunas ou não. A forma de acessar os elementos é interessante, podemos usar a sintaxe de indexação de uma lista ou de uma matriz. Vejamos os exemplos a seguir.\r\n\r\n\r\n# Criando um quadro de dados\r\ndados <- data.frame(x = 1:10, \r\n                    y = letters[1:10],\r\n                    z = rep(c(TRUE, FALSE), 5))\r\n# Imprimindo dados\r\ndados\r\n\r\n\r\n    x y     z\r\n1   1 a  TRUE\r\n2   2 b FALSE\r\n3   3 c  TRUE\r\n4   4 d FALSE\r\n5   5 e  TRUE\r\n6   6 f FALSE\r\n7   7 g  TRUE\r\n8   8 h FALSE\r\n9   9 i  TRUE\r\n10 10 j FALSE\r\n\r\n# Acessando os elementos de forma de lista\r\ndados[[1]]\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\ndados$x\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\n# Acessando os elementos em forma de matriz\r\ndados[1, ] # Coluna 1\r\n\r\n\r\n  x y    z\r\n1 1 a TRUE\r\n\r\ndados[1, 1] # Elemento da linha 1 coluna 1\r\n\r\n\r\n[1] 1\r\n\r\ndados[, 1] # Linha 1 \r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nQuando importamos um conjunto de dados, por exemplo usando a função read.table(), o objeto que armazena esses dados é um quadro de dados. Assunto discutido mais a frente.\r\nA semelhança com a forma retangular de uma matriz, faz com que algumas funções utilizadas em matrizes sejam utilizadas em quadro de dados:\r\nAs funções rownames() e colnames(), retornam ou inserem os nomes das linhas e colunas, respectivamente. A função names() retorna o nome das colunas.\r\nA dimensão das linhas e colunas podem ser obtidas pelas funções nrow() e ncol(), respectivamente. A função length() retorna o número de colunas.\r\nEm algumas situações, estamos interessados em otimizar o nosso tempo de programação, e achamos muito demorado ou não conveniente a utilização da sintaxe objeto$elemento para acessar os elementos de uma lista. Dessa forma, poderemos utilizar a função attach() para que os elementos do quadro de dados estejam disponíveis (anexados) no caminho de busca, e assim, possamos acessar os elementos (ou objetos) do quadro de dados sem precisar mencioná-lo. Vejamos,\r\n\r\n\r\n# Criando um quadro de dados\r\ndados <- data.frame(x = 1:10, \r\n                    y = letters[1:10],\r\n                    z = rep(c(TRUE, FALSE), 5))\r\n# Usando a funcao attach()\r\nattach(dados)\r\n\r\n# Acessando os elementos\r\nx; y; z\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n[1] 1 2 3\r\n[1] 1 2 4\r\n\r\n# Desanexando dados\r\ndetach(dados)\r\n\r\n\r\n\r\nEssa função attach() tem implicações, quando por exemplo se deseja inseri-la na construção de um pacote R. Iremos discutir esse ponto mais a frente. Para desanexar o quadro de dados, use detach(). A função attach() é genérica e pode ser usada em qualquer objeto de modo list ser anexado no caminho de busca.\r\n Importantdo/Exportando dados\r\nA importação/exportação de dados era algo que em poucas linhas conseguíamos explicar sobre o ambiente R, no sentido de análise de dados. Entretanto, observando o terceiro princípio do R, afirmado por Chambers (2016):\r\n\r\n\r\nPrincípio da Interface: Interfaces para outros programas são parte do R\r\n\r\nHoje é uma realidade a interação que o ambiente R tem com outras interfaces (programas, linguagens, etc.). A facilidade em utilizar outras linguagens dentro do ambiente R torna assim mais complexo a importação/exportação de dados, uma vez que o objetivo do R, apesar do R Core Team ainda limitar a sua definição como o ambiente para a computação estatística, a ferramenta se tornou tão versátil, que hoje torna humilde essa definição. Para mais detalhes acesse o manual R Data Import/Export. Um outro fator e tema atual é a era dos grandes bancos de dados (Big Data), do qual se tem um grande conjunto de variáveis e necessitamos fazer a importação por APIs, por exemplo, ou outras vias. Temas como esses, abordaremos no módulo Programação em R (Nível Avançado).\r\nNesse momento, limitaremos esse assunto ao objetivo de termos um conjunto de dados em arquivos de texto (extensões do tipo .txt, .csv, xls), formato binário (.xls ou .xlsx) ou digitados manualmente pelo teclado do computador. Assim, a primeira forma de como os dados estão dispostos, precisaremos importá-los e armazená-los em um quadro de dados (data frame), para que esteja disponível na área de trabalho (ambiente global) do R, e dessa forma, possamos utilizá-lo. Ao final do tratamento dos dados, podemos exportar essas informações para arquivos externos, e daí também, usaremos os arquivos de textos e o formato binário (.xls), mensionados anteriormente.\r\nPreparação dos dados\r\nA primeira coisa que devemos entender quando desejamos construir o arquivo de dados, é entender que sempre organizaremos as variáveis em colunas, com os seus valores em linhas, Figura 12. Sempre a primeira linha das colunas representarar o nome das variáveis. Esse é outro ponto importante, pois devemos ter a noção que alguma linguagem irá ler esse banco de dados. Assim, quanto mais caracteres diferentes do padrão ASCII, mais difícil será a leitura desses dados. Assim, sugerimos alguns padrões:\r\nEvitem símbolos fora do padrão alfanumérico;\r\nEvitem mistura de letras minúsculas com letras maiúsculas. Isso facilitará o acesso a essas variáveis. Contudo, lembre-se do padrão de nomes sintéticos permissíveis do R;\r\nLembre-se que o banco de dados será utilizado para que um programa faça a sua leitura, portanto, deixe a formatação da apresentação dos dados para arquivos específico. Sendo assim, evitem comentários nesses arquivos, ou qualquer outro tipo de informação que não seja o banco de dados;\r\nEvitem palavras longas, por exemplo, segundavariavel (má escolha), segvar (boa escolha), seg_var (boa escolha);\r\nEvitem palavras compostas com espaço entre elas. Para isso use o símbolo _, por exemplo, var 2 (má escolha), var2 (boa escolha), var_2 (boa escolha);\r\n\r\n\r\n\r\nFigure 12: Modelo estrutural de um banco de dados.\r\n\r\n\r\n\r\nImportando dados\r\nA função primária responável pela importação de dados é a função scan(). Por exemplo, funções como read.table(), read.csv() e read.delim(), usam a função scan() em seu algoritmo.\r\nA primeira ideia sobre importação de dados pode ser inserindo-os pelo teclado no próprio ambiente R. Para isso, usaremos a função scan(). Vejamos,\r\n\r\n\r\n# Criando e inserido os elementos do objeto dados\r\nx <- scan()\r\n\r\n\r\n\r\nApós executado essa linha de comando, aparecerá no console 1: que significa, digitar o primeiro valor do objeto x, e depois clicar em ENTER. Depois 2:, que significa digitar o segundo valor, e clicar em ENTER. Depois de inserido todos os valores necessários, aperte a tecla ENTER duas vezes no console, para sair da função scan().\r\nO mais tradicional é usar programa para criação de banco de dados e deixá-lo pronto para o R lê-lo. O tipo de arquivo de texto que melhor controla a separação de variáveis é com a extensão .csv, uma vez que separamos as variáveis por “;” é o padrão. O arquivo de texto com extensão .txt, geralmente usa espaços. Isso acaba gerando problema de leitura no R, porque muitos usuários usam nomes de variáveis muito grandes, palavras compostas, de forma a desalinhar as colunas das variáveis. Daí, como a separação das variáveis é por meio de espaços, acaba gerando problema de leitura. Uma outra forma, é fazer importação de dados gerados pelo próprio R, extensão .RData.\r\nTemos a opção de usar um editor de banco de dados para essas extensões por meio de programas como MS Excel, Libre Office, dentre outros. Estes exportam arquivos binários do tipo .xls, .xlsx, dentre outros. Uma sugestão para diminuir complicações, é exportar os bancos de dados para arquivos de texto sitados acima, que também é possível ser exportado por esses programas. Isso evita a necessidade de ser instalado mais pacotes e dor de cabeça. Porém, para quem ainda deseja enfrentar, sugerimos a leitura do pacote readr, como exemplo, porém existem diversos outros pacotes para este mesmo fim.\r\nUma vez que o banco de dados está pronto, a leitura destes pode ser feita por alguns caminhos. Mostraremos o mais trivial que é o botão Import Dataset, terceiro quadrante, aba Environment, na IDE do RStudio. Veja na Figura 13.\r\n\r\n\r\n\r\nFigure 13: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nPosteriormente, indique o arquivo para leitura. Aparece algumas opções de tipo de arquivo. Em nosso caso, usaremos a opção From Text (base), que significa realizar a leitura para os tipos de arquivo .txt ou .csv. Daí os passos seguintes são:\r\nEscolher o arquivo para leitura dos dados;\r\n\r\n\r\n\r\nFigure 14: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nConfigurar a leitura do banco de dados. Uma prévia pode ser vista no quadro Data Frame. Se for visualizado, algum problema, isso significa que deve ser informado opções adicionais como separador de variáveis (Separator), símbolo para casas decimais (Decimal), dentre outras opções. Por fim, digitar o nome associado ao objeto (Name) que será criado do tipo quadro de dados (data frame), e clicar no botão Import;\r\n\r\n\r\n\r\nFigure 15: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nUma vez inserido, o RStudio apresenta a linha de comando utilizada para importar os dados no console (2º quadrante), o conjunto de dados (1º quadrante), e a ligação entre o nome e o objeto no ambiente global (3º quadrante).\r\n\r\n\r\n\r\nFigure 16: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nA outra forma é utilizar linhas de comando. Para isso utilizaremos a função read.table(). Antes de importarmos o banco de dados, algo interessante é inserir o arquivo de dados no diretório de trabalho no ambiente R. Para verificar o ambiente de trabalho use a função getwd(). Para alterar o local do ambiente de trabalho use setwd(). Se esse procedimento não for realizado, o usuário deve informar na função read.table(), o local exato do arquivo de texto.\r\nVamos usar como diretório o local C:\\cursor. Lembre-se que no R a barra deve ser invertida. Vamos inserir nesse diretório três arquivos alfafa.txt, datast1980.txt e producao.csv.\r\nOs três conjuntos de dados são:\r\nalfafa.txt\r\n\r\nTRAT\r\nBLOCO\r\nPROD\r\nA\r\nI\r\n2.89\r\nA\r\nII\r\n2.88\r\nA\r\nIII\r\n1.88\r\nA\r\nIV\r\n2.90\r\nA\r\nV\r\n2.20\r\nA\r\nVI\r\n2.65\r\nB\r\nI\r\n1.58\r\nB\r\nII\r\n1.28\r\nB\r\nIII\r\n1.22\r\nB\r\nIV\r\n1.21\r\nB\r\nV\r\n1.30\r\nB\r\nVI\r\n1.66\r\nC\r\nI\r\n2.29\r\nC\r\nII\r\n2.98\r\nC\r\nIII\r\n1.55\r\nC\r\nIV\r\n1.95\r\nC\r\nV\r\n1.15\r\nC\r\nVI\r\n1.12\r\nD\r\nI\r\n2.56\r\nD\r\nII\r\n2.00\r\nD\r\nIII\r\n1.82\r\nD\r\nIV\r\n2.20\r\nD\r\nV\r\n1.33\r\nD\r\nVI\r\n1.00\r\n\r\ndatast1980.txt\r\n\r\ntrt\r\ny\r\n1\r\n19.4\r\n1\r\n32.6\r\n1\r\n27.0\r\n1\r\n32.1\r\n1\r\n33.0\r\n2\r\n17.7\r\n2\r\n24.8\r\n2\r\n27.9\r\n2\r\n25.2\r\n2\r\n24.3\r\n3\r\n17.0\r\n3\r\n19.4\r\n3\r\n9.1\r\n3\r\n11.9\r\n3\r\n15.8\r\n4\r\n20.7\r\n4\r\n21.0\r\n4\r\n20.5\r\n4\r\n18.8\r\n4\r\n18.6\r\n5\r\n14.3\r\n5\r\n14.4\r\n5\r\n11.8\r\n5\r\n11.6\r\n5\r\n14.2\r\n6\r\n17.3\r\n6\r\n19.4\r\n6\r\n19.1\r\n6\r\n16.9\r\n6\r\n20.8\r\n\r\nproducao.csv\r\n\r\nx\r\ny\r\n1\r\n6.7\r\n2\r\n7.9\r\n3\r\n9.1\r\n4\r\n6.6\r\n5\r\n7.5\r\n6\r\n8.8\r\n7\r\n7.7\r\n8\r\n7.6\r\n9\r\n6.5\r\n10\r\n7.9\r\n11\r\n8.7\r\n12\r\n6.2\r\n13\r\n7.9\r\n14\r\n7.4\r\n15\r\n9.7\r\n16\r\n6.2\r\n17\r\n4.9\r\n18\r\n5.6\r\n19\r\n7.0\r\n20\r\n6.0\r\n\r\n\r\n\r\n# Diretorio\r\ngetwd()\r\n\r\n\r\n[1] \"E:/BEN_PROD/CURSOS E PALESTRAS/CURSOS/SITE/Curso_R\"\r\n\r\n# Verificando os arquivos no diretorio de trabalho\r\nlist.files()\r\n\r\n\r\n [1] \"_images\"            \"_site.yml\"          \"aulas\"             \r\n [4] \"biblio.bib\"         \"cursor.Rproj\"       \"dados\"             \r\n [7] \"DESCRIPTION\"        \"docs\"               \"images\"            \r\n[10] \"index.Rmd\"          \"navancado.Rmd\"      \"nbasico.Rmd\"       \r\n[13] \"nintermediario.Rmd\" \"R\"                  \"scripts\"           \r\n\r\n\r\n\r\n\r\n\r\nChambers, John M. 2016. Extending R. The R Series. Boca Raton, Florida: Chapman; Hall/CRC.\r\n\r\n\r\nParadis, Emmanuel. 2005. “R for Beginners.” https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf.\r\n\r\n\r\nWickham, Hadley. 2019. Advanced R. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\n———. 2019. Advanced R. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\nFonte das fotos: Robert Gentleman do site: https://biocasia2020.bioconductor.org/ e Ross Ihaka do site: https://www.stat.auckland.ac.nz/en/about/news-and-events-5/news/news-2017/2017/12/ross-ihaka-retires.html↩︎\r\nFontes: https://cran.r-project.org/doc/html/interface98-paper/paper_2.html e https://www.r-project.org/contributors.html↩︎\r\nFonte: https://stat.ethz.ch/pipermail/r-announce/1997/000001.html↩︎\r\nFonte: https://www.gnu.org/philosophy/free-sw.html↩︎\r\nFonte: https://www.gnu.org/philosophy/open-source-misses-the-point.html↩︎\r\nFonte: https://www.gnu.org/philosophy/open-source-misses-the-point.html↩︎\r\nhttps://cran.r-project.org/doc/html/interface98-paper/paper_1.html↩︎\r\nhttps://cran.r-project.org/doc/html/interface98-paper/paper_1.html↩︎\r\nFonte da foto: https://rstudio.com/speakers/j.j.-allaire/↩︎\r\nComprehensive R Archive Network↩︎\r\nFonte da foto: https://www.ufpr.br/portalufpr/noticias/disciplinas-transversais-para-programas-de-pos-graduacao-abrem-inscricoes-nesta-segunda-feira/↩︎\r\nFonte da foto: Retirada de sua página pessoal, https://statweb.stanford.edu/~jmc4/↩︎\r\nBasta usar a função invisible(10 + 15), que a expressão é avaliada mas não impressa↩︎\r\nou também double, usando a função typeof()↩︎\r\nsinônimo: string, cadeia de caracteres.↩︎\r\nDiferente de outras linguagens, como a C, que o contador começa do número 0.↩︎\r\n",
      "last_modified": "2021-03-08T10:50:15-03:00"
    },
    {
      "path": "nintermediario.html",
      "title": "Programação em R (Nível Intermediário)",
      "description": "Esse módulo ...\n",
      "author": [],
      "contents": "\r\nSumário\r\nEm construção…\r\n\r\n Materiais para este módulo\r\nSlides de Aulas\r\nAula 00: Apresentação do Curso\r\nAula 01: Revisão de como o R trabalha\r\nScripts\r\nScript 00:\r\nScripts via Shiny\r\nCurso R via Shiny\r\n Apresentação do curso\r\nRevisão de como o R trabalha\r\n\r\n\r\n\r\nFigure 1: Relembrando como o R funciona.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n–>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-04T15:06:09-03:00"
    }
  ],
  "collections": []
}

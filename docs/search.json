{
  "articles": [
    {
      "path": "index.html",
      "title": "Curso R",
      "description": "Aprecie todo o material contido nesse site, como se fosse seu. Zele, propague, critique, contribua. Será um prazer compartilharmos nossas experiências e experienciarmos juntos esse conhecimento! \n",
      "author": [
        {
          "name": "Ben Dêivide",
          "url": "https://bendeivide.github.io/"
        }
      ],
      "contents": "\r\n\r\nAuthor Contributions\r\nSumário\r\n Livro do Curso\r\n Sobre o autor\r\n Proposta do curso\r\nProgramação em R (Nível Básico)\r\nProgramação em R (Nível Intermediário)\r\nProgramação em R (Nível Avançado)\r\nReferências do curso\r\nOnde encontrar nossos materiais\r\nPacotes R utilizados para esse curso\r\n\r\n Instalação do R e do RStudio\r\nSO Windows\r\nSO Linux (Ubuntu)\r\nSO MAC\r\n\r\n\r\n Livro do Curso\r\n\r\n\r\n\r\n Sobre o autor \r\nNatural da cidade de Pau dos Ferros/RN. Formado em Engenharia Agronômica pela Universidade Federal Rural do Semiárido (UFERSA), Mossoró/RN. Pós-Graduação (Mestrado e Doutorado) e Pós-Doutorado em Estatística e Experimentação Agropecuária pela Universidade Federal de Lavras (UFLA), Lavras/MG. Atualmente estou como Professor de Estatística pela Universidade de São João Del-Rei (UFSJ), campus Alto Paraopeba, Ouro Branco/MG. Minhas linhas de pesquisas se concentram em Estatística e Probabilidade, Estatística Experimental, Estatística Computacional (linguagem R), densenvolvimento de pacotes R para análises de dados e ensino da Estatística. Mais detalhes, acesse minha página.\r\nA motivação para estudar a linguagem R se deve a algumas fases experienciadas na vida acadêmica. A primeira foi a paixão pela Estatística. Estando no terceiro período do curso de Agronomia (UFERSA), concorri a tão sonhada monitoria de Estatística, orientada pelo Prof. Janilson Pinheiro de Assis (UFERSA). Nessa fase houve muitas conversas e conselhos para seguir em uma pós-graduação na área da Estatística. Se tornou amor quando fui impulsionado pelas leituras de apostilas e o encanto por um programa estatístico chamado SISVAR, do Prof. Daniel Furtado Ferreira (UFLA), Figura 1. Isso resultou em todo amadurecimento profissional durante o mestrado e doutorado sob a orientação do Prof. Daniel, e até hoje, estamos em constante processo de desenvolvimento de pesquisa, com o objetivo de propagar conhecimento.\r\n\r\n\r\n\r\nFigure 1: Daniel Furtado na Serra da Bocaina (Lavras/MG).1\r\n\r\n\r\n\r\nAinda durante a graduação, além de conhecer os materiais de Estatística do Professor Daniel, comecei a ler os materiais introdutórios em R, que costumeiramente, ele postava em sua página institucional. Mas o passo inicial para me guiar ao estudo do R, foi idealizado por uma apostila do Professor Paulo Justiniano Ribeiro Júnior (UFPR), intitulada Introdução ao Ambiente Estatístico R. As primeiras leituras desse material, me trouxe um bom conhecimento inicial, sobre a linguagem R, ao mestrado na UFLA.\r\nTudo isso me levou a essa outra grande paixão hoje que é estudar essa linguagem. Com o apoio inicial do Prof. Daniel Furtado, durante a pós-graduação, e agora na UFSJ, com os alunos que trabalham comigo de iniciação científica, juntos com mais alguns outros parceiros de estrada, chegamos a publicação de alguns pacotes R sob o CRAN, segue em ordem de publicação, SMR, midrangeMCP, TVMM, cppcor, MCPtests. Para projetos futuros, temos os pacotes statscience, meupacoter, leem (Laboratório de Ensino à Estatística e Matemática) dentre outros ainda não disponíveis.\r\nPara saber mais sobre o autor, veja a seção autor, na barra de navegação da página, ou acesse minha página [pessoal/profissional]\r\nlocal de trabalho (UFSJ), campus Alto Paraopeba\r\n\r\n\r\n{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"http://openstreetmap.org\\\">OpenStreetMap<\\/a> contributors, <a href=\\\"http://creativecommons.org/licenses/by-sa/2.0/\\\">CC-BY-SA<\\/a>\"}]},{\"method\":\"addMarkers\",\"args\":[-20.52206,-43.74496,null,null,null,{\"interactive\":true,\"draggable\":false,\"keyboard\":true,\"title\":\"\",\"alt\":\"\",\"zIndexOffset\":0,\"opacity\":1,\"riseOnHover\":false,\"riseOffset\":250},\"UFSJ, campus Alto Paraopeba\",null,null,null,null,{\"interactive\":false,\"permanent\":false,\"direction\":\"auto\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[-20.52206,-20.52206],\"lng\":[-43.74496,-43.74496]}},\"evals\":[],\"jsHooks\":[]}\r\n Proposta do curso \r\nO curso R não tem como objetivo principal de ensinar análise de dados. Mas sim, proporcionar a você um conhecimento sobre a linguagem R, de modo que consiga usufruir todos os recursos que ela possa lhe proporcionar.\r\nAinda como complemento, não queremos nesse material, convencê-lo a utilizar a linguagem R, pois a melhor linguagem é aquela que você domina. Contudo, pretendemos lhe mostrar que os recursos utilizados pelo R não estão mais limitados a própria análise de dados. Um exemplo é esse material, que nesse momento usufruo do R para repassar as minhas experiências sem ao menos ter o domínio sobre linguagens do tipo HTML, CSS, JavaScript, dentre outras, necessárias para uma boa criação de página web.\r\nDessa forma, propormos um entendimento sobre a sintaxe e semântica de como a linguagem R é desenvolvida. Com isso, você será capaz após esse curso, estudar um pouco mais sobre essa ciência que nos últimos anos vem ganhando mais evidência, que é a Estatística. Tudo isso devido ao grande volume de informações obtidos nessa era tecnológica. Juntamente com ela, o R se tornará uma poderosa ferramenta com o qual você poderá entender os padrões que estão por trás dos dados, que por sinal, é a moeda valiosa do momento, ou melhor, sempre foi!\r\nMas não só apenas análise de dados, aprenderemos também recursos diversos na área da computação, como programação defensiva, desenvolvimento de interfaces gráficas, paralelização. Ensinaremos também o desenvolvimento de materiais como artigos, livros, websites, blogs, dashboards. Por fim, chegaremos a maior cobiça de um programador R, desenvolver seu próprio pacote R.\r\n\r\n\r\n Repararam que em muitos momentos utilizamos o artigo “o” para a linguagem R. Pois é, isso ocorre porque ela também é considerada um software. Daí, também podemos chamá-la de software R, ou preferivelmente, ambiente R. \r\n\r\n\r\nO material curso R apresentará três módulos:\r\nProgramação em R (Nível Básico)\r\nProgramação em R (Nível Intermediário)\r\nProgramação em R (Nível Avançado)\r\nA seguir, explanaremos sobre cada um dos módulos.\r\nProgramação em R (Nível Básico)\r\nO primeiro módulo compreenderá um breve histórico sobre a linguagem, o conhecimento da sintaxe e semântica da linguagem R, compreendendo as estruturas bases da linguagem, sobre o que é um objeto e como construir uma função, o entendimento sobre fluxos de controle. O que é um pacote, carregar e anexar um pacote, e quem são as pessoas que fazem parte da manutenção dessa linguagem, também serão assuntos desse primeiro módulo. Caminhos de busca, ambientes e namespaces, teremos noções básicas. Algo muito interessante, que pode mudar a sua vida como programação em R são as boas práticas para a escrita de um código R, tema também abordado nesse módulo.\r\nPara acessar o material, segue: Programação em R (Nível Básico).\r\nProgramação em R (Nível Intermediário)\r\nEsse módulo irá caracterizar melhor o ambiente R quanto ao seu escopo léxico, como linguagem interpretada, como programação funcional, como programação meta-paradigma, como programação dinâmica; apresentaremos manipulações de objetos em mais detalhe, bem como o surgimento de alguns outros objetos como tibble, cópias de objetos. Uma característica do ambiente R é que a linguagem pode ser orientada a objetos e isso será estudado nesse módulo. Apresentações gráficas também serão abordadas. Introduziremos ao desenvolvimento de pacotes R, e aprofundaremos sobre os ambientes R. Daremos uma ênfase ao uso do banco de dados. E por fim, para uma divulgação de todos os materiais, também mostraremos como apresentar seu conhecimento no ambiente R, por meio da criação de documentações no R, que vai desde a criação de páginas Web (estatística e dinâmica), documentações de pacotes, criação de livros, relatórios, dentre outras.\r\nPara acessar o material, segue: Programação em R (Nível Intermediário).\r\nProgramação em R (Nível Avançado)\r\nEm contrução…\r\nReferências dos curso\r\nCitaremos alguns livros e materiais utilizados para o desenvolvimento desse curso, tais como:\r\nAn Introduction to R\r\nR Language Definition\r\nR Internals\r\nR Data Import/Export\r\nAdvanced R (Wickham 2019)\r\nAdvanced R Solutions (Grosser, Buman, and Wickham 2021)\r\nR Packages (Wickham 2015)\r\nExtending R (Chambers 2016)\r\nSoftware for Data Analysis: Programming with R (Chambers 2008)\r\nR in a Nutshell (Adler 2012)\r\nStatistical Models in S (Chambers and Hastie 1993)\r\nOnde encontrar os nossos materiais\r\nTemos dedicado uma parte do nosso trabalho no desenvolvimento de materiais em R, dos quais podem ser encontrados em: Ciencia e Progresso, Github e página pessoal.\r\nPacotes R utilizados para esse curso\r\n\r\n\r\nSegue uma lista dos pacotes utilizados para o desenvolvimento do material desse curso:\r\nPacote\r\nObjetivo para o curso\r\nlobstr\r\nAuxilia no estudo sobre a sintaxe do pacote\r\ncodetools\r\nAuxilia no estudo sobre a sintaxe do pacote\r\nXR\r\nAuxilia no estudo sobre a sintaxe do pacote\r\nrlang\r\nAuxilia no estudo sobre a sintaxe do pacote\r\nsloop\r\nAuxilia a compreender interativamente a programação orientada a objetos\r\nstyler\r\nAuxilia no estilo de código\r\nformatR\r\nAuxilia no estilo de código\r\ndistill\r\nCriação da página\r\n Instalação do R e do RStudio\r\nA seguir, apresentaremos as subseções para a instalação da linguagem R e do RStudio. Em todo nosso curso utilizaremos o sistema operacional Windows. Contudo, se esse não é o seu sistema operacinal, não haverá problema no entendimento sobre o R. Assim, convencionaremos a todos a utilização do RStudio, uma vez que poderá ser instalado nas principais plataformas de sistema operacional.\r\nSO Windows\r\nPara a instalação do R e do RStudio, como também do rtools, convidaremos para a seção Instalação do R e do RStudio do primeiro módulo desse curso, que é Programação em R (nível básico).\r\n\r\n\r\nSO Linux (Ubuntu)\r\nUm vídeo produzido pelo nosso canal do Youtube/Ben Dêivide, mostra falcilmente como realizar a instalação do R e o RStudio pelo Linux: \r\nUma outra opção pode ser um vídeo produzido pelo Canal PPGC UFSC (Youtube), mostra falcilmente como realizar a instalação do R e o RStudio pelo Linux: \r\nSO MAC\r\nUm vídeo produzido pelo Canal PPGC UFSC (Youtube), mostra falcilmente como realizar a instalação do R e o RStudio pelo MAC:\r\n\r\n\r\n\r\n\r\n\r\nAdler, Joseph. 2012. R in a Nutshell. Sebastopol: O’Reilly Media.\r\n\r\n\r\nChambers, John M. 2008. Software for Data Analysis: Programming with R. Statistics and Computing. New York: Springer.\r\n\r\n\r\n———. 2016. Extending R. The R Series. Boca Raton, Florida: Chapman; Hall/CRC.\r\n\r\n\r\nChambers, John M., and Trevor J. Hastie. 1993. Statistical Models in S. London: Chapman & Hall.\r\n\r\n\r\nGrosser, Malte, Henning Buman, and Hadley Wickham. 2021. Advanced R Solutions. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\nWickham, Hadley. 2015. R Packages. 2nd ed. O’Reilly Media. https://r-pkgs.org/index.html.\r\n\r\n\r\n———. 2019. Advanced R. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\nFonte das fotos: Acervo pessoal de Daniel Furtado↩︎\r\n",
      "last_modified": "2021-10-15T21:10:42-03:00"
    },
    {
      "path": "navancado.html",
      "title": "Programação em R (Nível Avançado)",
      "description": "Esse módulo ...\n",
      "author": [],
      "contents": "\r\nSumário\r\nEm construção…\r\n\r\n Materiais para este módulo\r\nSlides de Aulas\r\nAula 00: Apresentação do Curso\r\nAula 01: Revisão de como o R trabalha\r\nScripts\r\nScript 00:\r\nScripts via Shiny\r\nCurso R via Shiny\r\n Apresentação do curso\r\nTokens\r\n\r\nA vida secreta dos objetos R\r\n\r\n\r\n\r\n\r\nOtimização de rotinas\r\n\r\n\r\n\r\nR Interface\r\nAprofundar o conteúdo sobre o R Internals, apresentando as interfaces para a linguagem C e FORTRAN.\r\nfalar dos tipos de linguagens que interagem com o R\r\nJupyter\r\nJulia\r\njava\r\nJavaScript\r\npython\r\nSAS\r\nSQL\r\nPerl\r\nHTML\r\nCSS\r\ntcl/tk\r\nGTK+\r\nC/C++\r\nFortran\r\nFalar sobre os pacotes que auxiliam nessa interação entre linguagens e programas\r\nImportação/Exportação de dados\r\nUsar https://cran.r-project.org/doc/manuals/r-release/R-data.html\r\nComo modelo de ideias: http://www.sthda.com/english/wiki/import-and-export-data-using-r\r\nFalar sobre API’s para importação de dados, etc…\r\nBig Data, mineração de dados, gerenciamento de banco de dados (DBMS)\r\nDesenvolvimento de pacotes\r\nFalar sobre a discussão realizada em https://cran.r-project.org/doc/manuals/r-release/R-exts.html#DOCF1\r\nVer todas as atualizacoes do R\r\nhttps://cran-archive.r-project.org/bin/windows/base/old/\r\nVerificar quando houve a introdução no NAMESPACE nos pacotes\r\nAdicionais\r\ndesempenho\r\ndepuração\r\nsimulação\r\n\r\n\r\n\r\n",
      "last_modified": "2021-10-15T21:10:49-03:00"
    },
    {
      "path": "nbasico.html",
      "title": "Programação em R (Nível Básico)",
      "description": "Esse módulo terá o objetivo de apresentar de forma introdutória a **sintaxe** e **semântica** da linguagem `R`, enfatizando definições importantíssimas para a linguagem como **objeto**, **função** e **pacote**, como também outras definições.\n",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n\r\nSumário\r\n Materiais para este módulo\r\nSlides de Aulas\r\nScripts\r\nExercícios e Scripts via Shiny\r\n\r\n Apresentação do curso\r\n Instalação do R e RStudio para o SO Windows\r\n Como utilizar o R e o RStudio\r\n História do R\r\n Como o R trabalha\r\n Comandos no R e Ambiente Global\r\n Arquivos .Rdata e .Rhistory\r\n Criando e salvando um script\r\n Objetos\r\n Vetores\r\n Matrizes bidimensionais\r\n Matrizes multidimencionais\r\n Listas de dados\r\n Quadro de dados\r\n Importando dados\r\n Funções\r\nEstruturas de controle\r\nComo criar funções\r\n\r\n Boas práticas de como escrever um código\r\n Pacotes\r\nInstalação de um pacote\r\nObjetivos de um pacote\r\nUtilizar as funções de um pacote\r\nCarregando e anexando um pacote\r\nNamespace de um pacote\r\nUsando os operadores :: e :::\r\n\r\n Ambientes e Caminho de busca\r\nA superatribuição <<-\r\nCaminho de busca\r\n\r\n Interfaces com outras linguagens\r\n Considerações e preparação para o módulo Programação em R (Nível Intermediário)\r\nSlides de Aulas\r\nAula 00: Apresentação do Curso\r\nAula 01: Instalação do R e do RStudio\r\nAula 02: Passos iniciais para a utilização do R e do RStudio\r\nAula 03: História do R\r\nAula 04: Como o R trabalha\r\nAula 05: Comandos no R e Ambiente Global\r\nAula 06: Arquivos .RData e .Rhistory\r\nAula 07: Criando e salvando um Script\r\nAula 08: Objetos\r\nAula 09: Vetores\r\nAula 10: Matrizes\r\nAula 11: Arrays\r\nAula 12: Lists\r\nAula 13: Data frames\r\nAula 14: Importando dados\r\nAula 15: Funções\r\nAula 16: Estruturas de controle\r\nAula 17: Como criar funções\r\nAula 18: Boas práticas de como escrever um código\r\nAula 19: Pacotes\r\nAula 20: Carregando e Anexando pacotes\r\nAula 21: NAMESPACE de um pacote\r\nAula 22: Quando devemos utilizar os operadores :: e :::\r\nAula 23: Ambientes e Caminhos de busca\r\nAula 24: Interface com outras linguagens\r\nAula 25: Considerações e Preparação para a Programação em R (Nível Intermediário)\r\nScripts\r\nScript 00: ~\r\nScript 01: ~\r\nScript 02: ~\r\nScript 03: Escopo léxico\r\nScript 04: ~\r\nScript 05: Comandos\r\nScript 06: ~\r\nScript 07: .RData e .Rhistory\r\nScript 08: Script08.txt; Script 08_2: Script08_2.txt\r\nScript 09: Vetores\r\nScript 10: Matrizes bidimensionais\r\nScript 11: Matrizes multidimensionais\r\nScript 12:\r\nScript 13:\r\nScript 14: alfafa.txt, datast1980.txt, producao.csv\r\nScript 15:\r\nScript 16:\r\nScript 17:\r\nScript 18:\r\nScript 19: Script19.txt\r\nScript 20: Script20.txt\r\nScript 21: Script21.txt\r\nScript 22: Script22.txt\r\nScript 23: Script23.txt\r\nScript 24: r-python.R, r-rcpp.R, r-tcltk.R, add.cpp, add.py\r\nScript 25: ~\r\nExercícios e Scripts via Shiny\r\nCurso R via Shiny\r\n\r\n Apresentação do curso\r\n\r\n\r\nO Curso R será todo aprensentado no formato online, sendo que as aulas terão vídeos como suporte, postados no canal Youtube/Ben Dêivide divulgados ao longo do material. Os vídeos serão bem objetivos de curta duração para que usem como suporte com o material escrito. Como complemento desse material, disponibilizaremos os scripts com os comandos utilizados em cada aula e sua versão em Shiny para os que não quiserem realizar inicialmente a instalação do R e do RStudio, poderão utilizar uma versão online do material juntamente com a linguagem R.\r\n Instalação do R e RStudio para o SO Windows\r\n\r\n\r\nA linguagem R é o objetivo principal desse curso. Assim, faremos inicialmente a sua instalação, uma vez que o RStudio é apenas uma GUI, e sem o R, não há sentido instalá-lo.\r\nDessa forma, seguem os passos para a instalação:\r\nInstalação do R: https://cran.r-project.org/bin/windows/base/\r\nInstalação do RStudio: https://rstudio.com/products/rstudio/download/#download\r\nJustificamos a utilizamos do RStudio, pela quantidade de recursos disponíveis e a diversidade de usuários R, que hoje o perfil não é apenas de um programador, mas um usuário que necessita de uma ferramenta estatística para análise de seus dados. Dessa forma, até por questão de praticidade, e de uso pessoal, não deixaremos de repassar o entendimento sobre a linguagem R com o uso do RStudio.\r\n Como utilizar o R e o RStudio\r\n\r\n\r\nA primeira ideia que temos sobre a linguagem R é a linha de comando no R, que é simbolizada pelo prompt de comando “>.” Este símbolo significa que o R está pronto para receber os comandos do usuário. O prompt de comando está localizado no console do R. Vejamos o console do R a seguir, que é o local que recebe as linhas de comando do usuário.\r\n\r\n\r\n\r\nFigure 1: Console do R (Versão 4.0.3).\r\n\r\n\r\n\r\nO R ao ser iniciado está pronto para ser inserido as linhas de comando desejadas. Uma forma simples de armazernar os seus comandos é por meio de um script, isto é, um arquivo de texto com extensão .R. Para criar basta ir em: Arquivo > Novo script.... Muitas outras informações iremos ver ao longo do curso.\r\nO RStudio se apresenta como uma interface para facilitar a utilização do R, tendo por padrão quatro quadrantes, apresentados na Figura 2.\r\n\r\n\r\n\r\nFigure 2: Interface do RStudio (Versão 1.4.1103).\r\n\r\n\r\n\r\nMuitas coisas na interface do R podem se tornar problemas para os usuários, uma vez que janelas gráficas, janelas de scripts, dentre outras, se sobrepõe. Uma vantagem no RStudio foi essa divisão de quadrantes, que torna muito mais organizado as atividades realizadas no R. De um modo geral, diremos que o primeiro quadrante é responsável pela entrada de dados, comandos, isto é, o input. O segundo quadrante, que é o console do R, representa tanto entrada como saída de informações (input/output). Dependendo as atividades as abas podem aumentar. O terceiro quadrante representa informações básicas como objetos no ambiente global, a memória de comandos na aba History, dentre outras, e também representa entrada como saída de informações (input/output). Por fim, o quarto quadrante é responsável por representação gráficas, instalação de pacotes, renderização de páginas web.\r\n História do R\r\n\r\n\r\nA linguagem R tem a sua primeira aparição científica publicada em 1996, com o artigo intitulado R: A Language for Data Analysis and Graphics, cujos os autores são os desenvolvedores da linguagem, George Ross Ihaka e Robert Clifford Gentleman.\r\n\r\n\r\n\r\nFigure 3: Criadores do R.1\r\n\r\n\r\n\r\nDurante a época em que estes professores trabalhavam na Universidade de Auckland, Nova Zelândia, desenvolvendo uma implementação alternativa da lingugagem S, desenvolvida por John Chambers, que comercialmente era o S-PLUS, nasceu em 1991, o projeto da linguagem R, em que em 1993 o projeto é divulgado e em 1995, o primeiro lançamento oficial, como software livre com a licença GNU. Devido a demanda de correções da linguagem que estava acima da capacidade de atualização em tempo real, foi criado em 1997, um grupo central voluntário, responsável por essas atualizações, o conhecido R Development Core Team2, que hoje está em 20 membros: Douglas Bates, John Chambers, Peter Delgaard, Robert Gentleman, Kurt Hornik, Ross Ihaka, Tomas kalibera, Michael Lawrence, Friedrich Leish, Uwe Ligges, Thomas Lumley, Martin Maechler, Martin Morgan, Paul Murrel, Martyn Plummer, Brian Ripley, Deepayan Sarkarm, Duncan Temple Lang, Luke Tierney e Simon Urbanek.\r\nPor fim, o CRAN (Comprehensive R Archive Network) foi oficialmente anunciado em 23 de abril de 19973. O CRAN é um conjunto de sites (espelhos) que transportam material idêntico, com as contribuições do R de uma forma geral.\r\nR é uma linguagem de programação e ambiente de software livre e código aberto (open source). Entendemos4:\r\nSoftware livre: software que respeita a liberdade e sendo de comunidade dos usuários, isto é, os usuários possuem a liberdade de executar, copiar, distribuir, estudar, mudar, melhorar o software. Ainda reforça que um software é livre se os seus usuários possuem quatro liberdades:\r\nLiberdade 0 - A liberdade de executar o programa como você desejar, para qualquer propósito;\r\nLiberdade 1 - A liberdade de estudar como o programa funciona, e adaptá-la as suas necessidades;\r\nLiberdade 2 - A liberdade de redistribuir cópias de modo que você possa ajudar outros;\r\nLiberdade 3 - A liberdade de distribuir cópias de suas versões modificadas a outros.\r\n\r\nAlgo que deve está claro é que um software livre não significa não comercial. Sem esse fim, o software livre não atingiria seus objetivos.\r\nAgora perceba que, segundo Richard Stallman5, a ideia de software livre faz campanha pela liberdade para os usuários da computação. Por outro lado, o código aberto valoriza principalmente a vantagem prática e não faz campanha por princípios.\r\nCódigo aberto: Para Richard Stallman6 código aberto apoia critérios um pouco mais flexíveis que os do software livre. Todos os códigos abertos de software livre lançados se qualificariam como código aberto. Quase todos os softwares de código aberto são software livre, mas há exceções, como algumas licenças de código aberto que são restritivas demais, de forma que elas não se qualificam como licenças livres. Nesse contexto, o autor cita muitas situações que diferenciam os dois termos. Vale a pena a leitura.\r\nA linguagem R é uma combinação da linguagem S com a semântica de escopo léxico da linguagem Scheme. Dessa forma, a linguagem R se diferencia em dois aspectos principais7:\r\nGerenciamento de memória: usando as próprias palavras de Ross Ihaka8, em R, alocamos uma quantidade fixa de memória na inicialização e a gerenciamos com um coletor de lixo dinâmico. Isso significa que há muito pouco crescimento de heap e, como resultado, há menos problemas de paginação do que os vistos na linguagem S. \r\nEscopo: na linguagem R, as funções acessam as variáveis criadas no corpo da própria função, como também as variáveis contidas no ambiente que a função foi criada. No caso da linguagem S, isso não ocorre, assim, como por exemplo na linguagem C, em que as funções acessam apenas variáveis definidas globalmente.\r\nVejamos alguns exemplos para entendimento (Se você ainda não está ambientado ao R, estude esse módulo primeiro, e depois reflita sobre esses exemplos). Antes de executar as linhas de comando, instale o pacote lobstr como segue:\r\n\r\n\r\n# Instale o pacote lobstr\r\ninstall.packages(\"lobstr\")\r\n\r\n\r\n\r\nExemplo 1: As funções têm acesso ao escopo em que foram criadas.\r\n\r\n\r\n# Criando um nome \"n\" associado a um objeto 10 no escopo da funcao\r\nn <- 10\r\n\r\n# Criando um nome \"funcao\" associado a um objeto que eh uma funcao\r\nfuncao <- function() {\r\n  print(n)\r\n}\r\n\r\n# Imprimindo 'funcao'\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n\r\nExemplo 2: As variáveis criadas ou alteradas dentro de uma função, permanecem na função.\r\n\r\n\r\n# Criando um nome \"n\" associado a um objeto 10 no escopo da funcao\r\nn <- 10\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0x2aa92130\"\r\n\r\n# Criando um nome \"funcao\" associado a um objeto que eh uma funcao\r\nfuncao <- function() {\r\n  # Imprimindo n\r\n  print(n)\r\n  # Criando um nome \"n\" associado a um objeto 15 no corpo da funcao\r\n  n <- 15\r\n  # Imprimindo n\r\n  print(n)\r\n}\r\n# Imprimindo 'funcao'\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n[1] 15\r\n\r\n# Imprimindo 'n'\r\nn\r\n\r\n\r\n[1] 10\r\n\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0x2aa92130\"\r\n\r\nExemplo 3: As variáveis dentro de uma função permanecem nelas, exceto no caso em que a atribuição ao escopo seja explicitamente solicitada.\r\n\r\n\r\n# Criando um nome \"n\" associado a um objeto 10 no escopo da funcao\r\nn <- 10\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0x28a8d418\"\r\n\r\n# Criando um nome \"funcao\" associado a um objeto que eh uma funcao\r\nfuncao <- function() {\r\n  # Imprimindo n\r\n  print(n)\r\n  # Criando um nome \"n\" associado a um objeto 15 no corpo da funcao\r\n  n <<- 15\r\n  # Imprimindo n\r\n  print(n)\r\n}\r\n# Imprimindo 'funcao'\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n[1] 15\r\n\r\n# Observe que depois de usar a superatribuicao (\"<<-\") dentro da funcao,\r\n#o nome \"n\" passou a estar associado ao numero 15 e nao mais ao numero 10, observe\r\nn\r\n\r\n\r\n[1] 15\r\n\r\nlobstr::obj_addr(n) # Identificador do objeto\r\n\r\n\r\n[1] \"0x28a8d338\"\r\n\r\nExemplo 4: Por fim, embora a linguagem R tenha um escopo padrão, chamado ambiente global, os escopos de funções podem ser alterados.\r\n\r\n\r\n# Criando um nome 'n' associado a um objeto 10 no escopo da funcao (ambiente global)\r\nn <- 10\r\n# Criando um nome 'funcao' associado a um objeto que eh uma função criado no ambiete global\r\nfuncao <- function() {\r\n  # Imprimindo n\r\n  print(n)\r\n}\r\n# Imprimindo 'funcao' no ambiente global\r\nfuncao()\r\n\r\n\r\n[1] 10\r\n\r\n# Criando um novo ambiente\r\nnovo_ambiente <- new.env()\r\n# Criando um nome \"n\" associado ao objeto 20 no ambiente  'novo_ambiente'\r\nnovo_ambiente$n <- 20\r\n# Criando um objeto funcao no ambiente 'novo_ambiente'\r\nenvironment(funcao) <- novo_ambiente\r\n# Imprimindo 'funcao' no ambiente 'novo_ambiente'\r\nfuncao()\r\n\r\n\r\n[1] 20\r\n\r\nComo a linguagem S é também uma linguagem interpretada cuja base é a linguagem FORTRAN, a linguagem R também é uma linguagem interpretada e baseada além da linguagem S, tem como base as linguagens de baixo nível C e FORTRAN e a própria linguagem R.\r\nEmbora o R tenha uma interface baseada em linhas de comando, existem muitas interfaces gráficas ao usuário com destaque ao RStudio, criado por Joseph J. Allaire, Figura 4.\r\n\r\n\r\n\r\nFigure 4: J. J. Allaire, o criador do RStudio9.\r\n\r\n\r\n\r\nEssa interface tornou o R mais popular, pois além de produzir pacotes de grande utilização hoje como a família de pacotes tidyverse, rmarkdown, shiny, dentre outros, permite uma eficiente capacidade de trabalho de análise de utilização do R. Uma vez que o RStudio facilita a utilização de muitos recursos por meio de botões, como por exemplo, a criação de um pacote R. A quem diga que para um iniciante em R, não seja recomendado utilizar o RStudio para o entendimento da linguagem. Cremos, que o problema não é a IDE10 utilizada, e sim, o caminho onde deseja chegar com a linguagem R.\r\nNo Brasil, o primeiro espelho do CRAN foi criado na UFPR, pelo grupo do Prof. Paulo Justiniano. Inclusive um dos primeiros materiais mais completos sobre a linguagem R produzidos no Brasil, foi dele, iniciado em 2005, intitulado Introdução ao Ambiente Estatístico R. Vale a pena assistirmos o evento a palestra: R Releflões: um pouco de história e experiências com o R, proferida pelo Prof. Paulo Justiniano Ribeiro Júnior, no R Day - Encontro nacional de usuários do R, ocorrido em 2018 em Curitiba/UFPR, do qual o vídeo está disponível no Canal (Youtube) LEG UFPR.\r\n\r\n\r\nPara quem não sabe, o Prof. Paulo Justiniano (Figura 5) e sua equipe trouxeram o primeiro espelho do R para o Brasil e foi o desenvolvedor de um dos 100 primeiros pacotes submetidos ao CRAN11. Devido a sua ida para Lancaster/Inglaterra para fazer o doutorado, em 1997, se deparou com o início dos estudos sobre o R fora do país. Isso porque havia uma necessidade muito grande de um programa para ser utilizado nas plataforma UNIX. Nesse momento a linguagem S estava sendo uma saída para isso, porém, o uso de memória que a linguagem consumia nos computadores, na criação das rotinas, era muito grande (Claro que grande para aquela época!). Não satisfeito, ao voltar para o Brasil, em 2002, se depara com alguns usuários da linguagem S, porém, certo como mudança de cultura na utilização de linguagem R, passou a densevolver materiais didáticos da linguagem, para as disciplinas do departamento de Estatística (UFPR).\r\n\r\n\r\n\r\nFigure 5: Foto de divulgação de Paulo Justiniano12 no R Day.\r\n\r\n\r\n\r\n\r\n Como o R trabalha\r\n\r\n\r\nIniciamos a discussão por uma afirmação de John McKinley Chambers, do qual afirmou que o R tem três princípios (Chambers 2016):\r\n\r\n\r\n\r\nFigure 6: John Chambers13, o criador da linguagem S.\r\n\r\n\r\n\r\n\r\n\r\nPrincípio do Objeto: Tudo que existe em R é um objeto;\r\nPrincípio da Função: Tudo que acontece no R é uma chamada de função;\r\nPrincípio da Interface: Interfaces para outros programas são parte do R.\r\n\r\nAo longo de todo o curso, para os três módulos, iremos nos referir a esses princípios. Vamos inicialmente observar uma adaptação da ilustração feita por Paradis (2005), mostrando como o R trabalha, Figura 7.\r\n\r\n\r\n\r\nFigure 7: Esquema de como o R funciona.\r\n\r\n\r\n\r\nToda ação que acontece no R é uma chamada de função (Operadores e funções), que por sua vez é armazenada na forma de um objeto, e este se associa a um nome. A forma de execução de uma função é baseada em argumentos (dados, fórmulas, expressões, etc), que são entradas, ou argumentos padrões que já são pré-estabelecidos na criação da função. Esses tipos de argumentos podem ser modificados na execução da função. Por fim, a saída é o resultado, que é também um objeto, e pode ser usado como argumento de outras funções.\r\nNa Figura 7, observamos que todas as ações realizadas sobre os objetos ficam armazenadas na memória ativa do computador. Esses objetos são criados por comandos (teclado ou mouse) através de funções ou operadores (chamada de função), dos quais leem ou escrevem arquivo de dados do disco rígido, ou leem da própria internet. Por fim, o resultado desses objetos podem ser apresentados no console (memória ativa), exportados em formato de imagem, página web, etc. (disco rígido), ou até mesmo ser reaproveitado como argumento de outras funções, porque o resultado também é um objeto.\r\n Comandos no R e Ambiente Global\r\n\r\n\r\nConsole e Prompt de comando\r\nComo falado anteriormente, o R é uma linguagem baseada em linhas de comando, e as linhas de comando, são executadas uma de cada vez, no console. Assim que o prompt de comando está visível na tela do console, o R indica que o usuário está pronto para inserir as linhas de comando. O símbolo padrão do prompt de comando é “>,” porém ele pode ser alterado. Para isso, use a linha de comando, por exemplo:\r\n\r\n\r\noptions(prompt = \"R>\")\r\n# Toda vez que o console iniciar, começarar por 'R>'\r\n10\r\n\r\n\r\n[1] 10\r\n\r\nO conjunto de símbolos que podem ser utilizados no R depende do sistema operacional e do país em que o R está sendo executado. Basicamente, todos os símbolos alfanuméricos podem ser utilizados, mas para evitar problemas quanto ao uso das letras aos nomes, opte pelos caracteres ASCII.\r\nA escolha do nome associado a um objeto tem algumas regras:\r\nDeve consistir em letras, dígitos, . e _;\r\nOs nomes devem ser iniciado por uma letra ou um ponto não seguido de um número, isto é, Ex.: .123, 1n, dentre outros;\r\nAs letras maiúsculas se distinguem das letras minúsculas;\r\nNão pode inicia por _ ou dígito, é retornado um erro no console caso isso ocorra;\r\nNão pode usar qualquer uma das palavras reservadas pela linguagem, isto é, TRUE, FALSE, if, for, dentre outras, que pode ser consultado usando o comando ?Reserved().\r\nUm nome que não segue essas regras é chamado de um nome não sintático. Um comando que pode ser usado para converter nomes não sintatícos em nomes sintáticos é make.names.\r\n\r\n\r\n\r\nApesar dessas justificativas, algumas situações como as apresentadas nos exemplos anteriores são possíveis, ver Wickham (2019) na Seção 2.2.1\r\nComandos elementares\r\nOs comandos elementares podem ser divididos em expressões e atribuições. Por exemplo, podemos está interessados em resolver a seguinte expressão \\(10 + 15 = 25\\). No console quando passamos pelo comando:\r\n\r\n\r\n10 + 15\r\n\r\n\r\n[1] 25\r\n\r\nO R avalia essa expressão internamente e imprime o resultado na tela, após apertar o botão ENTER do teclado. Esse fato é o que ocorre no segundo princípio mencionado por Chambers (2016), tudo em R acontece por uma chamada de função. Na realidade o símbolo + é uma função interna do R, que chamamos de função primitiva, porque foi implementada em outra linguagem. Assim, essa é o resultado de três objetos (“10,” “+,” “15”) que são avaliados internamente, do qual a função + é chamada, e em seguida o resuldo é impresso no console.\r\nDo mesmo modo, se houver algum problema em algum dos objetos o retorno da avaliação pode ser uma mensagem de erro. Um caso muito prático é quando utilizamos o separador de casas decimais para os números sendo a vírgula. Quando na realidade deve ser um ponto “.” respeitando o sistema internacional de medidas. A vírgula é utilizada para separar elementos, argumentos em uma função, etc. Vejamos o exemplo:\r\n\r\n10,5 + 15,5\r\nError: <text>:1:3: ',' inesperado\r\n1: 10,\r\n      ^\r\n\r\nPorém, tem que ficar claro que uma expressão é qualquer comando repassado no console. Este comando é avaliado e seu resultado impresso, há menos que explicitamente o usuário queira torná-lo invisível14. Caso algum elemento do comando não seja reconhecido pelo R, há um retorno de alguma mensagem em forma de “erro” ou “alerta,” tentando indicar o possível problema. Todos esses processos ocorrem na memória ativa do computador, e uma vez o resultado impresso no console, o valor é perdido, há menos que você atribua essa expressão a um nome, que erroneamento usamos o termo: “criamos um objeto!” A atribuição dessa expressão será dada pela junção de dois símbolos “<-,” falado mais a frente. Um comando em forma de atribuição também avalia a sua expressão, um nome se associa ao seu resultado, e o resultado será mostrado, se posteriormente, após a execução você digitar o “nome” atribuído a esse resultado. Vejamos um exemplo:\r\n\r\n\r\n# Foi criado um objeto do tipo caractere e o nome \"meu_nome\" foi associado a ele\r\n# O 'R' avalia essa expressão, mas não imprime no console!\r\nmeu_nome <- \"Ben\"\r\n\r\n# Para imprimir o resultado da expressão, digitamos o nome \"meu_nome\" no console\r\n# e apertamos o botão ENTER do teclado!\r\nmeu_nome\r\n\r\n\r\n[1] \"Ben\"\r\n\r\nExecução dos comandos\r\nQuando inserimos um comando no console, executamos uma linha de comando por vez ou separados por “;” em uma mesma linha. Vejamos\r\n\r\n\r\n# Uma linha de comando por vez\r\nmeu_nome <- \"Ben\" # Criamos e associamos um nome ao objeto\r\nmeu_nome # Imprimos o objeto\r\n\r\n\r\n[1] \"Ben\"\r\n\r\n# Tudo em uma linha de comando\r\nmeu_nome <- \"Ben\"; meu_nome\r\n\r\n\r\n[1] \"Ben\"\r\n\r\nSe um comando for muito grande e não couber em uma linha, ou caso deseje completar um comando em mais de uma linha, após a primeira linha haverá o símbolo “+” iniciando a linha seguinte ao invés do símbolo de prompt de comando (“>”), até que o comando esteja sintaticamente completo. Vejamos:\r\n\r\n\r\n# Uma linha de comando em mais de uma linha\r\n(10 + 10) /\r\n  2\r\n\r\n\r\n[1] 10\r\n\r\nPor fim, todas linhas de comando quando iniciam pelo símbolo jogo da velha, “#” indica um comentário e essa linha de comando não é avaliada pelo console, apenas impressa na tela. E ainda, as linhas de comandos no console são limitadas a aproximadamente 4095 bytes (não caracteres).\r\nChamada e correção de comandos anteriores\r\nUma vez que um comando foi executado no console, esse comando por ser recuperado usando as teclas de setas para cima e para baixo do teclado, recuperando os comandos anteriorermente executados, e que os caracteres podem ser alterados usando as teclas esquerda e direita do teclado, removidas com o botão Delete ou Backspace do teclado, ou acrescentadas digitando os caracteres necessários. Uma outra forma de completar determinados comandos já existentes, como por exemplo, uma função que já existe nas bibliotecas de instalação do R, usando o botão Tab do teclado. O usuário começa digitando as iniciais, e para completar o nome aperta a tecla Tab. Posteriormente, basta completar a linha de comando e apertar ENTER para executá-la. Vejamos um exemplo a seguir.\r\n\r\n\r\nUsando esses recursos no RStudio são mais dinâmicos e vão mais além. Por exemplo, quando usamos um objeto do tipo função, estes apresentam o que chamamos de argumento(s) dentro do parêntese de uma função, do qual são elementos necessários, para que a função seja executada corretamente. Nesse caso, ao inseri o nome dessas funções no console, usando o RStudio, ao iniciá-la com a abertura do parêntese, abre-se uma janela informano todos os argumentos possíveis dessa função. Isso torna muito dinâmico escrever linhas de comando, porque não precisaremos estar lembrando do nome dos argumentos de uma função, mas apenas entender o objetivo dessa função. Vejamos um exemplo a seguir.\r\n\r\n\r\nAmbiente Global (ou área de trabalho, Workspace)\r\nQuando usamos um comando de atribuição no console, o R armazena o nome associado ao objeto criado na área de trabalho (Workspace), que nós chamamos de Ambiente Global. Teremos uma seção introdutória na seção Ambientes e caminhos de busca, mas entendamos inicialmente que o objetivo de um ambiente é associar um conjunto de nomes a um conjunto de valores. Por exemplo:\r\n\r\n\r\n# Nomes criados no ambiente \r\nx <- 10 - 6; y <- 10 + 4; w <- \"Maria Isabel\"\r\n# Verificando o nomes contidos no ambiente global\r\nls()\r\n\r\n\r\n [1] \"cran\"          \"funcao\"        \"github\"        \"meu_nome\"     \r\n [5] \"n\"             \"novo_ambiente\" \"rlink\"         \"rstudio\"      \r\n [9] \"w\"             \"x\"             \"y\"            \r\n\r\nObserve que todos os objetos criados até o momento estão listados, e o que é mais surpreendente é que ambientes podem conter outros ambientes e até mesmo se conter. Observe o objeto meu_nome é um ambiente e está contido no Ambiente global. Será sempre dessa forma que recuperaremos um objeto criado no console do R. Caso contrário, se no console esse comando não for de atribuição esse objeto é perdido.\r\n Arquivos .Rdata e .Rhistory\r\n\r\n\r\nAo final do que falamos até agora, todo o processo ao inserir linhas de comando do console, e desejarmos finalizar os trabalhos do ambiente R, dois arquivos são criados, sob a instrução do usuário em querer aceitar ou não, um .RData e outro .Rhistory, cujas finalidades são:\r\n.RData: salvar todos os objetos criados que estão atualmente disponíveis;\r\n.Rhistory: salvar todas as linhas de comandos inseridas no console.\r\nAo iniciar o R no mesmo diretório onde esses arquivos foram salvos, é carregado toda a sua área de trabalho anteriomente, bem como o histórico das linhas de comando utilizadas anteriormente.\r\n Criando e salvando um script\r\n\r\n\r\nA melhor forma de armazenarmos nossas linhas de código inseridas no console é criando um Script. Este é um arquivo de texto com a extensão “.R.” Uma vez criada, poderemos ao final salvar o arquivo e guardá-lo para utilizar futuramente.\r\nNo R, ao ser iniciado poderemos ir no menu em Arquivo > Novo script.... Posteriormente, pode ser inserido as linhas de comando, executadas no console pela tecla de atalho F5. As janelas do Script e console possivelmente ficarão sobrepostas. Para uma melhor utilização, estas janelas podem ficar lado a lado, configurando-as no menu em Janelas > Dividir na horizontal (ou Dividir lado a lado).\r\nNo RStudio, poderemos criar um Script no menu em File > New File > R Script, ou diretamente no ícone abaixo da opção File no menu, cujo o símbolo é um arquivo com o símbolo “+” em verde, que é o ícone do New File, e escolher R Script. Esse arquivo abrirá no primeiro quadrante na interface do RStudio.\r\nPara salvar, devemos clicar no botão com o símbolo de disquete (R/RStudio), escolher o nome do arquivo e o diretório onde o arquivo será armazenado no seu computador. Algumas ressalvas devem ser feitas:\r\nEscolha sempre um nome sem caracteres especiais, com acentos, etc.;\r\nEscolha sempre um nome curto ou abreviado, que identifique a finalidade das linhas de comando escritas;\r\nEvite espaços se o nome do arquivo for composto. Para isso, use o símbolo underline “_”;\r\nQuando escrever um código, evite também escrever caracteres especiais, exceto em casos de necessidade, como imprimir um texto na tela, títulos na criação de gráficos, dentre outras. Nos referimos especificamente, nos comentários do código.\r\nUm ponto bem interessante é o diretório. Quando criamos um Script a primeira vez, e trabalhamos nele a pós a criação, muitos erros podem ser encontrados de início. Um problema clássico é a importação de dados. O usuário tem um conjunto de de dados e deseja fazer a importação para o R, porém, mesmo com todos os comandos corretos, o console retorna um erro, informando que não existe esse arquivo que contém os dados para serem informados. Isso é devido ao diretório de trabalho atual. Para verificar qual o diretório que está trabalhando no momento, use a linha de comando:\r\n\r\n\r\ngetwd()\r\n\r\n\r\n\r\nPara alterar o diretório de trabalho, o usuário deve usar a seguinte função setwd(\"Aqui, deve ser apontado para o local desejado!\"). Supomos que salvamos o nosso Script tem sido em C:\\meus_scripts_r. Assim, usamos a função setwd e ao apontarmos o local, as barras devem ser inseridas de modo invertido, isto é, setwd(\"C:/meu_scripts_r\"), além de estar entre aspas.\r\nNo RStudio, isso pode ser feito em Session > Set Working Directory > To Source File Location. Isso levará ao diretório corrente do Script. Se desejar escolher outro diretório, vá em Session > Set Working Directory > Choose Directory.... Porém, uma vez criado um Script, e utilizado novamente, se o usuário estiver abrindo o RStudio também naquele primeiro momento, por padrão, o diretório de trabalho corrente será o mesmo do diretório do Script. Isso acaba otimizando o trabalho.\r\nDevemos estar atentos também, quando trabalhamos utilizando Scripts ou arquivos de banco de dados, em locais diferentes do diretório corrente. Um outro recurso interessante é a função source(), que tem o objetivo de executar todas as linhas de comando de um Script sem precisar abri-lo. Isso pode ser útil, quando criamos funções para as nossas atividades, porém elas não se encontram no Script de trabalho para o momento. Assim, podemos criar um Script auxiliar que armazenas todas as funções criadas para as análises desejadas, e no Script corrente, poderemos chamá-las sem precisar abri o Script auxiliar. Todos os objetos passam a estar disponíveis no ambiente global.\r\n\r\nPor fim, algo de muita importância para um programador, comente suas linhas de comando. Mas faça isso a partir do primeiro dia em que você criou o seu primeiro Script. Isso criará um hábito, uma vez que o arquivo não está sendo criado apenas para um momento, mas para futuras consultas. E quando voltamos a Scripts com muitas linhas de comando, principalmente depois de algum tempo, e sem comentários, possivelmente você passará alguns instantes para tentar entender o que foi escrito.\r\nOutra coisa importante, é a boa prática de escrita de um código, e o RStudio nos proporciona algumas ferramentas interessantes. Mas isso será visto mais a frente.\r\n Objetos\r\n\r\n\r\nDefinimos um objeto como uma entidade no ambiente R com características internas contendo informações necessárias para interpretar sua estrutura e conteúdo. Essas características são chamadas de atributos. Vamos entender o termo estrutura como a disposição de como está o seu conteúdo. Por exemplo, a estrutura de um objeto mais simples no R é um vetor atômico, pois os elementos contidos nele, apresenta o mesmo modo, um tipo de atributo. Falaremos nisso, mais à frente. De forma didática, adaptaremos a representação dos objetos no formato de diagrama.\r\nVejamos o seguinte código:\r\n\r\n\r\nx <- 10\r\n\r\n\r\n\r\nTodo mundo que tem uma certa noção sobre a linguagem R afirmaria: “criei um objeto x que recebe o valor 10.” Para Wickham (2019) essa afirmação é imprecisa e pode levar um entendimento equivocado sobre o que acontece de fato. Para o mesmo autor, o correto é afirmar que o objeto 10 está se ligando a um nome. E de fato, o objeto não tem um nome, mas o nome tem um objeto. O símbolo que associa um objeto a um nome é o de atribuição, <-, isto é, a junção do símbolo desigualdade menor e o símbolo de menos. Para ver qual objeto associado ao nome, o usuário precisa apenas digitar o nome no console e apertar a tecla ENTER.\r\nRepresentaremos em termos de diagrama, um nome se ligando a um objeto, na Figura 8.\r\n\r\n\r\n\r\nFigure 8: Dizemos que o nome 'x' se liga ao objeto do tipo (estrutura) vetor.\r\n\r\n\r\n\r\nO identificador na memoría ativa desse objeto pode ser obtida por:\r\n\r\n\r\nlobstr::obj_addr(x)\r\n# [1] \"0xf8a104fc20\"\r\n\r\n\r\n\r\nO diagrama explica que o nome criado “x” se associou com um objeto do tipo (estrutura) vetor (vector) e modo numérico (numeric)15, cuja identificação na memória ativa do seu computador foi <0xf8a104fc20>. É claro que para cada vez que o usuário abri o ambiente R e executar novamente esse comando, ou repeti o comando, esse identificador irá alterar.\r\nEssa outra representação ficará mais claro para a afirmação feita anteriormente, no segundo diagrama, Figura 9, que representa a ligação do nome “y” ao mesmo objeto. Os termos nos diagramas, serão usados de acordo com a sintaxe da linguagem com os termos em inglês para melhor compreensão e fixação dos termos utilizados em R, uma vez que os termos na linguagem são baseados nesse idioma.\r\n\r\n\r\ny <- x\r\nlobstr::obj_addr(y)\r\n# [1] \"0xf8a104fc20\"\r\n\r\n\r\n\r\nObservem que não houve a criação de um outro objeto, mas apenas a ligação de mais um nome ao objeto existente, pois o identificador na memória ativa para o objeto não alterou, é o mesmo. Logo, não temos um outro objeto, mais dois nomes que se ligam ao mesmo objeto.\r\n\r\n\r\n\r\nFigure 9: Dizemos que o nome 'x' e ‘y’ se ligam ao objeto do tipo (estrutura) vetor.\r\n\r\n\r\n\r\nMais especificamente, acrescentamos um outro diagrama, Figura 10, mostrando a representação do ambiente global (.GlobalEnv, nome associado ao objeto que representa o ambiente global).\r\n\r\n\r\n\r\nFigure 10: Dizemos que o nome 'x' e 'y' se ligam ao objeto do tipo (estrutura) vetor e essa ligação fica armazenada no ambiente global.\r\n\r\n\r\n\r\nDe todo modo, deixaremos para o módulo Programação em R (Nível Intermediário), uma abordagem mais profunda sobre o assunto.\r\nO símbolo de atribuição poderá ser representado na direção da esquerda para à direita ou vice-versa, isto é,\r\n\r\n\r\nx <- 10\r\n10 -> x\r\n\r\n\r\n\r\nEssas duas linhas de comando anteriores podem ter passado despercebidas pelo leitor em uma situação. Se na segunda linha tivéssemos alterado o valor do objeto de 10 para 30, por exemplo, a associação de x seria ao objeto 30. Isso significa que se o nome já existe, ele será apagado da memória ativa do computador e associado ao novo objeto. Veja,\r\n\r\n\r\nlobstr::obj_addr(x)\r\n# [1] \"0xf8a104fc20\"\r\nx <- 30\r\nlobstr::obj_addr(x)\r\n# [1] \"0x42db6dbb50\"\r\n\r\n\r\n\r\nUma outra forma menos convencional é usar o comando assign, veja:\r\n\r\n\r\nassign(\"m\", 15)\r\nm\r\n\r\n\r\n[1] 15\r\n\r\nAo invés do símbolo de atribuição, muitos usuários utilizam o símbolo da igualdade “=” para associarmos nomes aos objetos, que o ambiente R compreenderá. Contudo, discutiremos mas adiante, em Boas práticas de como escrever um código, que o uso da igualdade deverá em R ser usado apenas para a utilização em argumentos de uma função.\r\nQuando desejamos executar mais de uma linha de comando por vez, separamos estas pelo símbolo “;” isto é,\r\n\r\n\r\nx <- 10; w <- 15; x; w\r\n\r\n\r\n[1] 10\r\n[1] 15\r\n\r\nNeste caso, executamos quatro comandos em uma linha. Associamos dois nomes a dois objetos e imprimimos os seus valores.\r\nPor questão de comodidade, iremos a partir de agora, sempre nos referir a um objeto pelo nome associado a ele, para não está sempre se expressando como “um nome associado a um objeto.” Mas que fique claro a discussão realizada anteriormente sobre esses conceitos.\r\nNesse momento, nos limitaremos a falar sobre objetos que armazenam dados, do tipo caracteres, números e operadores lógicos (TRUE/FALSE).\r\nAtributos\r\nTodos os objetos, terão pelo menos dois tipos de atributos, chamados de atributos intrínsecos. Os demais atributos, quando existem, podem ser verificados pela função attributes(). A ideia dos atributos pode ser pensada como metadados, isto é, um conjunto de informações que caracterizam o objeto.\r\nDiremos também que todos os objetos R tem uma classe, e por meio dessas classes, determinadas funções podem ter comportamento diferente a objetos com classes diferentes. Agora, devemos deixar claro essa informação, apesar do R seguir o princípio do Objeto, nem tudo é orientado a objetos, como por exemplo, observamos na linguagens C++ e Java. Deixemos esse tópico para o módulo Programação em R (Nível Intermediário).\r\nA forma de se verificar a classe de um objeto é pela função class(). Contudo, os objetos internos do R (base), quando solicitado sua classe pela função class(), acabam retornando, algumas vezes, resultados equivocados. Uma alternativa é utilizar a função sloop::s3_class() do pacote sloop. Isso também será discutido no módulo Programação em R (Nível Intermedirário).\r\nDevemos estar atentos a uma questão. Existe um atributo também chamado classe (“class”), e nem todos os objetos necessariamente tem esse atributo, apenas aqueles orientados a objetos, como é o caso do objeto com atributo classe . Por exemplo, é devido a classe factor no objeto criado pela função factor() que apesar do seu resultado ser numérico, este não se comporta como numérico. Isto significa que o atributo classe muda o comportamento de como funções veem esse objeto.\r\nPara verificarmos se tal objeto tem o atributo class, usamos a função attributes(). Quando este atributo existe, ele é coincidente com o resultado obtido também pela função class().\r\nO tipo das classes podem ser numeric, logical, character, list, matrix, array, factor e data.frame. Por enquanto, nos concentraremos nas classes de objetos que armazenam dados para uso em análises.\r\nPara remover o efeito da classe, usamos a função unclass() para tal.\r\nPor exemplo, quando criamos um objeto da classe data.frame, vejamos o seu comportamento:\r\n\r\n\r\n# Criamos um objeto de classe 'data.frame'\r\ndados <- data.frame(a = 1:3, b = LETTERS[1:3])\r\n\r\n# Imprimindo na tela\r\ndados\r\n\r\n\r\n  a b\r\n1 1 A\r\n2 2 B\r\n3 3 C\r\n\r\n# Verificando sua classe\r\nclass(dados)\r\n\r\n\r\n[1] \"data.frame\"\r\n\r\n# Verificando o efeito do objeto 'dados',\r\n# sem o efeito da classe\r\ndados2 <- unclass(dados); dados2\r\n\r\n\r\n$a\r\n[1] 1 2 3\r\n\r\n$b\r\n[1] \"A\" \"B\" \"C\"\r\n\r\nattr(,\"row.names\")\r\n[1] 1 2 3\r\n\r\n# Qual a classe desse objeto sem o efeito da\r\n# classe 'data.frame'\r\nclass(dados2)\r\n\r\n\r\n[1] \"list\"\r\n\r\nObserve que sem o atributo class= 'data.frame', o objeto tem classe list. Isto significa que, o objeto tem uma estrutura em forma de list, mas se comporta como um data.frame, que se apresenta como mostrado anteriormente.\r\nVeremos no módulo Programação em R (Nível Intermediário) como criar atributos, classes, e mostrar que não conseguiremos mostrar todos os tipos de classes, pois a todo momento se cria classes em objetos R no desenvolvimento de pacotes.\r\nAtributos intrínsecos\r\nTodos os objetos tem dois atributos intrínsecos: o modo e comprimento. O modo representa a natureza dos elementos objetos. Para o caso dos vetores atômicos, o modo dos vetores podem ser cinco, numérico (numeric), lógico (logic), caractere16 (character), complexo (complex) ou bruto (raw). Este último, não daremos evidência para esse momento. O comprimento mede a quantidade de elementos no objeto.\r\nPara determinarmos o modo de um objeto, usamos a função mode(). Vejamos:\r\n\r\n\r\n# Objeto modo caractere\r\nx <- \"Ben\"; mode(x)\r\n\r\n\r\n[1] \"character\"\r\n\r\n# Objeto modo numerico\r\ny <- 10L; mode(y)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\n# Objeto modo numerico\r\ny2 <- 10; mode(y2)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\n# Objeto modo logico\r\nz <- TRUE; mode(z)\r\n\r\n\r\n[1] \"logical\"\r\n\r\n# Objeto modo complexo\r\nw <- 1i; mode(w)\r\n\r\n\r\n[1] \"complex\"\r\n\r\nContudo, essa função mode() se baseou nos atributos baseados na linguagem S. Temos uma outra função para verificarmos o modo do objeto que é typeof(). O atributo modo retornado de um objeto para esta última função, está relacionado a tipagem de variáveis da linguagem C, uma vez que boa parte das rotinas no R está nessa linguagem, principalmente as funções do pacote base. Existem 25 tipos que serão detalhados no módulo Programação em R (Nível Intermedirário).\r\n\r\n\r\n# Objeto modo caractere\r\nx <- \"Ben\"; typeof(x)\r\n\r\n\r\n[1] \"character\"\r\n\r\n# Objeto modo numerico (Inteiro)\r\ny <- 10L; typeof(y) \r\n\r\n\r\n[1] \"integer\"\r\n\r\n# Objeto modo numerico (Real)\r\ny2 <- 10; typeof(y2)\r\n\r\n\r\n[1] \"double\"\r\n\r\n# Objeto modo logico\r\nz <- TRUE; typeof(z)\r\n\r\n\r\n[1] \"logical\"\r\n\r\n# Objeto modo complexo\r\nw <- 1i; typeof(w)\r\n\r\n\r\n[1] \"complex\"\r\n\r\nObservamos que apesar de alguns vetores serem vazios, estes ainda tem um modo, observe nas seguintes linhas de comando:\r\n\r\n\r\n# Vetor numérico vazio de comprimento 1\r\nnumeric(0)\r\n\r\n\r\nnumeric(0)\r\n\r\n# Verificando o seu modo\r\nmode(numeric(0))\r\n\r\n\r\n[1] \"numeric\"\r\n\r\ntypeof(numeric(0))\r\n\r\n\r\n[1] \"double\"\r\n\r\n# Vetor caractere vazio de comprimento 1\r\ncharacter(0)\r\n\r\n\r\ncharacter(0)\r\n\r\n# Verificando o seu modo\r\nmode(character(0))\r\n\r\n\r\n[1] \"character\"\r\n\r\ntypeof(character(0))\r\n\r\n\r\n[1] \"character\"\r\n\r\nA diferença existente nos objetos y e y2 para as funções mode() e typeof() se referem apenas como o R armazena essas informações na memória do computador. Podemos perguntar ao R se dois números são iguais, assim:\r\n\r\n\r\n# 10 eh igual a 10L ?\r\n10 == 10L\r\n\r\n\r\n[1] TRUE\r\n\r\nVeja que o resultado é TRUE, isto é, sim eles são iguais. Agora, veja a próxima linha de comando:\r\n\r\n\r\n# 10 eh identico a 10L ?\r\nidentical(10, 10L)\r\n\r\n\r\n[1] FALSE\r\n\r\nO retorno agora foi FALSE, que significa que o armazenamento dessas informações não são iguais. Posteriormente, entenderemos no que isso reflete no código usuário, uma vez que um código escrito pode uma perda de desempenho simplesmente pela não necessidade de determinados objetos ou cópias realizadas.\r\nO termo double retornado pela função typeof() significa dupla precisão na linguagem de programação, que acaba tenho uma exigência de mais memória do que o objeto de modo integer. Esses termos são utilizados na linguagem C. Já a linguagem S não os diferencia, utiliza tudo como numeric.\r\nAqui vale um destaque para o termo numérico, que no R podem ter três significados:\r\nPode significar um número real, isto é, para a computação um número de dupla precisão (numeric e double seriam iguais nesse aspecto). Veja linha de código:\r\n\r\n\r\n# Criacao de dois objetos de modo numerico\r\na <- numeric(1); b <- double(1)\r\n# Verificando o modo\r\nmode(a); mode(b)\r\n\r\n\r\n[1] \"numeric\"\r\n[1] \"numeric\"\r\n\r\n# Verificando se 'a' e 'b' sao identificos\r\nidentical(a, b)\r\n\r\n\r\n[1] TRUE\r\n\r\nnos sistemas S3 e S4 (orientação a objetos), o termo numérico é usado como atalho para o modo integer ou double. Esse ponto veremos no módulo Programação em R (Nível Básico). Contudo, veja a linha de código:\r\n\r\n\r\nsloop::s3_class(1)\r\n\r\n\r\n[1] \"double\"  \"numeric\"\r\n\r\nsloop::s3_class(1L)\r\n\r\n\r\n[1] \"integer\" \"numeric\"\r\n\r\nPode ser utilizado (is.numeric()) para verificar se determinados objetos tem o modo numérico. Por exemplo, temos um objeto de classe factor que é importante para a área da estatística experimental, representando os níveis de um fator em um experimento. Os elementos desse objeto pode ser número ou caracteres, mas serão representados como sempre por números. Entretanto, não se comportam como numérico. Veja a linha de comando:\r\n\r\n\r\n# Criando um objeto de atributo classe 'factor':\r\nfator <- factor(\"a\"); fator\r\n\r\n\r\n[1] a\r\nLevels: a\r\n\r\n# O atributo classe muda a forma dos elementos. Veja quando retiramos o atributo \r\n# classe 'factor', o objeto retorna o valor 1\r\nunclass(fator)\r\n\r\n\r\n[1] 1\r\nattr(,\"levels\")\r\n[1] \"a\"\r\n\r\n# Para confirmar essa afirmacao anterior, vejamos o modo\r\nmode(fator)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\ntypeof(fator)\r\n\r\n\r\n[1] \"integer\"\r\n\r\n# Apesar do resultado retornar 1, veja que ele nao se comporta como numerico\r\nis.numeric(fator)\r\n\r\n\r\n[1] FALSE\r\n\r\nis.integer(fator)\r\n\r\n\r\n[1] FALSE\r\n\r\nUma tabela a seguir, mostra o retorno dos seis principais modos de um objeto do tipo (estrutura) de vetores atômicos (Os modos apresentados baseiam-se apenas quanto a característica dos dados do objeto. É claro que um objeto não armazena apenas dados. Existem outras naturezas, que serão omitidas nesse momento):\r\ntypeof\r\nmode\r\nlogical\r\nlogical\r\ninteger\r\nnumeric\r\ndouble\r\nnumeric\r\ncomplex\r\ncomplex\r\ncharacter\r\ncharacter\r\nraw\r\nraw\r\nO comprimento do objeto é informado pela função lenght(), do qual a representação em diagrama informa esse atributo. Vejamos as linhas de comando a seguir.\r\n\r\n\r\n# Vetor de comprimento 5\r\nv1 <- 1:5\r\n\r\n# Vetor de comprimento 3\r\nv2 <- c(\"Ben\", \"Maria\", \"Lana\")\r\n\r\n# Vetor de comprimento quatro\r\nv3 <- c(TRUE, FALSE, TRUE, TRUE)\r\n\r\n# Vejamos o comprimento dos vetores\r\nlength(v1)\r\n\r\n\r\n[1] 5\r\n\r\nlength(v2)\r\n\r\n\r\n[1] 3\r\n\r\nlength(v3)\r\n\r\n\r\n[1] 4\r\n\r\nUm diagrama apresentando esses três objetos no ambiente global, pode ser apresentado na Figura 11. Observe que acrescentamos agora o comprimento dos objetos no diagrama entre colchetes, ao lado do atributo modo.\r\n\r\n\r\n\r\nFigure 11: Objetos v1, v2 e v3.\r\n\r\n\r\n\r\nUm resumo as funções mensionadas podem ser refletidas com as seguintes indagações:\r\nbase::class() e loop::c3_class(): Qual o tipo de objeto?\r\nbase::mode(): Qual o tipo de dados baseados na linguagem S?\r\nbase::typeof(): Qual o tipo de dados baseados na linguagem C?\r\nbase::attributes(): O objeto tem atributos?\r\nbase::length(): Qual o comprimento do objeto?\r\nUsamos essa sintaxe pacote::nome_função() para entedermos qual o pacote da função que utilizamos. Contudo, essa forma tem uma importância no sentido de acesso a funções em um pacote sem necessitar anexá-lo no caminho de busca. Assunto abordado mais a frente.\r\nCoersão\r\nComo falamos anteriormente, os vetores atômicos armazenam um conjunto de elementos de mesmo modo. A coerção é a forma como o R coage o modo dos objetos. Por exemplo, se um elemento de modo caractere estiver em um vetor, todos os demais elementos serão convertidos para esse modo. Veja:\r\n\r\n\r\n# Criando um objeto x e imprimindo o seu resultado\r\nx <- c(\"Nome\", 3, 4, 5);x\r\n\r\n\r\n[1] \"Nome\" \"3\"    \"4\"    \"5\"   \r\n\r\nObserva que todos os elementos ganharam aspas, isto é, se tornaram um caractere ou uma cadeia de caracteres. A coersão entre vetores de modo numeric, character e logical será sempre assim:\r\n\r\n\r\nNo caso dos vetores lógicos, todo TRUE se converterá em 1, e FALSE em 0. Porém, os modos dos vetores podem ser coagidos pelo usuário, usando as funções do tipo as.<modo ou tipo>() com prefixo as., isto é, se desejarmos que um objeto meu_objeto tenha o modo “character,” basta usar as.character(meu_objeto). Para desejar saber se um objeto é de um determinado modo, usamos as funções do tipo is.<modo ou tipo>(), com o prefixo is.. Vejamos,\r\n\r\n\r\n# Objeto de modo numerico\r\nminha_idade <- 35\r\nmode(minha_idade)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\n# Coersão do objeto para modo caractere (`string`)\r\nminha_idade <- as.character(minha_idade)\r\nmode(minha_idade)\r\n\r\n\r\n[1] \"character\"\r\n\r\n# Verificando se o objeto tem modo 'character'\r\nis.character(minha_idade)\r\n\r\n\r\n[1] TRUE\r\n\r\nTipo de objetos\r\nPor fim, pretendemos falar sobre os principais tipos de objetos. O tipo vamos entender como a estrutura de como os dados estão organizados em um objeto, relacionados aos seus atributos. Falamos anteriormente sobre a estrutura mais simples, que é o vetor atômico. Mas entendemos que um vetor em R podem ser considerados: atômicos ou listas. Podemos então subdividi-los em:\r\nVetores atômicos:\r\nLógicos, Numéricos e Caracteres;\r\nMatrizes unidimensionais (Matrix) e multidimensionais (Arrays);\r\n\r\nVetores em listas:\r\nListas (Lists);\r\nQuadro de dados (Data frames);\r\n\r\nExistem outros, mas para esse módulo, exploraremos estes nas seções seguintes. As funções para as coersões realizadas pelos usuários, são similares as funções de coersão para modo, isto é, usar as funções prefixadas as.<tipo>.\r\nDaremos uma visão geral dos objetos apresentados até o momento na Tabela a seguir.\r\nObjeto\r\nClasse\r\nModo\r\nSão possíveis vários modos no mesmo objeto?\r\nVetor\r\nnumeric (integer ou double), character, complex, logical, raw\r\nnumeric (integer ou double), character, complex, logical, raw\r\nNão\r\nMatriz\r\nmatrix\r\nnumeric (integer ou double), character, complex, logical, raw\r\nNão\r\nArray\r\narray\r\nnumeric (integer ou double), character, complex, logical, raw\r\nNão\r\nlista\r\nlist\r\nnumeric (integer ou double), character, complex, logical, raw, expression, function\r\nSim\r\nQuadro de dados\r\ndata.frame\r\nnumeric (integer ou double), character, complex, logical, raw\r\nSim\r\n Vetores\r\n\r\nPodemos dizer que existem três tipos principais de vetores atômicos:\r\nNuméricos (numeric):\r\nInteiro (integer);\r\nReal (double);\r\n\r\nLógico (logical);\r\nCaractere (character)\r\nExistem dois tipos raros que são os complexos (complex) e brutos (raw), que falaremos no módulo seguinte.\r\nEscalares\r\nO menor comprimento de um vetor é de tamanho um, conhecido também como um escalar. Porém, para o R tudo é observado como um vetor. As sintaxes para os tipos especiais são: - os vetores lógicos assumem valores: TRUE ou FALSE, ou abreviados, T ou F, respectivamente. Existem valores especiais devido a precisão de operações na programação, que são os chamados pontos flutuantes. Nesse caso temos: Inf, -Inf e NaN, quando o resultados tende a \\(\\infty\\), \\(-\\infty\\), sem número, respectivamente;\r\n\r\n\r\n\r\n\r\n# divisao de um numero por zero (+ infinito)\r\nx <- 50 / 0; x\r\n\r\n\r\n[1] Inf\r\n\r\n# divisao de um numero por zero (- infinito)\r\n-50 / 0\r\n\r\n\r\n[1] -Inf\r\n\r\n# Resultado sem número do tipo NaN\r\nx - x\r\n\r\n\r\n[1] NaN\r\n\r\nos vetores numéricos do tipo double podem ser representados de forma decima (0.123), científica (1.23e5), ou hexadecimal (3E0A);\r\nos vetores numéricos do tipo integer são representados pela letra L ao final do número inteiro, isto é, 1L, 1.23e5L, etc.;\r\nos caracteres são representados pelas palavras, letras, números ou caracteres especiais entre aspas, isto é, \"Ben\", \"a\". Pode ser utilizado também aspa simples, 'Ben', 'a', etc.\r\nVetores longos\r\nOs vetores longos podem ser criados pela função c() a incial da palavra concatenar, que significa agrupar. Vejamos alguns exemplos:\r\n\r\n\r\n# Criando um vetor 'double'\r\nvetor.num <- c(1, 2, 3, 4, 5); vetor.num\r\n\r\n\r\n[1] 1 2 3 4 5\r\n\r\ntypeof(vetor.num)\r\n\r\n\r\n[1] \"double\"\r\n\r\nUma coisa interessante é que por padrão, a função c() sempre cria um vetor de modo double, a menos que o usuário determine que estes elementos sejam inteiros, isto é,\r\n\r\n\r\n# Criando um vetor 'integer'\r\nvetor.num2 <- c(1L, 2L, 3L, 4L, 5L); vetor.num; typeof(vetor.num2)\r\n\r\n\r\n[1] 1 2 3 4 5\r\n[1] \"integer\"\r\n\r\nUma forma mais eficiente para criarmos um vetor com elementos de sequências regulares, é por meio da função primitiva (:), isto é, <menor valor da sequência>:<maior valor da sequência>. Vejamos:\r\n\r\n\r\n# Criando uma sequência de 1 a 5\r\nvetor.num3 <- 1:5; vetor.num3; typeof(vetor.num3)\r\n\r\n\r\n[1] 1 2 3 4 5\r\n[1] \"integer\"\r\n\r\nVeremos mais a frente outras funções para construir sequências regulares. Se verificarmos os três objetos, veremos que todos eles são iguais:\r\n\r\n\r\n\r\n\r\n\r\nvetor.num == vetor.num2\r\n\r\n\r\n[1] TRUE TRUE TRUE TRUE TRUE\r\n\r\nvetor.num == vetor.num3\r\n\r\n\r\n[1] TRUE TRUE TRUE TRUE TRUE\r\n\r\nvetor.num2 == vetor.num3\r\n\r\n\r\n[1] TRUE TRUE TRUE TRUE TRUE\r\n\r\nO que vai difenrenciá-los é a forma de armazená-lo (double ou integer), e por consequência, o espaço na memória ativa. Veja:\r\n\r\n\r\n# Objetos:\r\nvetor.num <- c(1, 2, 3, 4, 5)\r\nvetor.num2 <- c(1L, 2L, 3L, 4L, 5L)\r\nvetor.num3 <- 1:5\r\n# Memoria:\r\nlobstr::obj_size(vetor.num)\r\n\r\n\r\n96 B\r\n\r\nlobstr::obj_size(vetor.num2)\r\n\r\n\r\n80 B\r\n\r\nlobstr::obj_size(vetor.num3)\r\n\r\n\r\n680 B\r\n\r\nO que podemos observar é que o vetor de modo double precisa de mais memória do que o objeto de modo integer. O último objeto aparentemente ocupou mais memória. Contudo, essa função apresenta um recurso interessante apresentado nas versões posteriores R (3.5.0), que é chamado de abreviação alternativa. Esse recurso faz com que a sequência de números não seja armazenada completamente, apenas os extremos. Isso significa que para qualquer tamanho de sequência, a ocupação de memória do objeto será sempre a mesma. Outras formas de criar sequência de números é usando as funções rep() e seq(), do qual a ajuda pode ser realizada usando no console ?rep() e ?seq(), respectivamente.\r\nDessa forma, poderemos ter com o último objeto (vetor.num3) uma economia de memória, dependendo do tamanho do seu vetor, quando se compara com as outras opções. Veja:\r\n\r\n\r\n# Tamanho de memoria dos objetos\r\nlobstr::obj_size(1:10)\r\n\r\n\r\n680 B\r\n\r\nlobstr::obj_size(1:10000)\r\n\r\n\r\n680 B\r\n\r\nlobstr::obj_size(1:1000000)\r\n\r\n\r\n680 B\r\n\r\nlobstr::obj_size(c(1:10))\r\n\r\n\r\n96 B\r\n\r\nlobstr::obj_size(c(1:10000))\r\n\r\n\r\n40,048 B\r\n\r\nlobstr::obj_size(c(1:1000000))\r\n\r\n\r\n4,000,048 B\r\n\r\nManipulando vetores\r\nQuando algum elemento de um vetor não está disponível, representamos pela constante lógica NA, que pode ser coagida para qualquer outro modo de vetor, exceto para raw. Podemos ter constantes lógicas NA específicas para modos específicos: NA_integer_, NA_real_ (o equivalente para o modo double), NA_complex_ e NA_character_. Entretando, dependendo de onde o NA é inserido, o atributo modo no objeto já converte para NA específico de acordo com o seu atributo modo. Essa constante contido no vetor não altera o modo do vetor, isto é,\r\n\r\n\r\ntypeof(c(1, 2, 3, NA))\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(c(1, 2, 3, NA))\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(c(\"c\", \"b\", \"a\", NA))\r\n\r\n\r\n[1] \"character\"\r\n\r\nPodemos criar vetores atômicos iniciais sem nenhuma elemento, por meio das funções numeric(0), character(0) e logical(0), isto é,\r\n\r\n\r\n# Vetor numerico de comprimento 0\r\nv1 <- numeric(0); length(v1)\r\n\r\n\r\n[1] 0\r\n\r\nv2 <- character(0); length(v2)\r\n\r\n\r\n[1] 0\r\n\r\nv3 <- logical(0); length(v2)\r\n\r\n\r\n[1] 0\r\n\r\nPara inserirmos valores a esses vetores usamos o sistema de indexação, que no caso da linguagem R, o contador começa a partir do número 117. Vejamos,\r\n\r\n[1] 0\r\n[1] 0\r\n[1] 0\r\n\r\n\r\n\r\n# Vetor numerico de comprimento 0\r\nv1 <- numeric(0)\r\nv2 <- character(0)\r\nv3 <- logical(0)\r\n# Inserimos 3 elementos em v1 e depois imprimos o seu resultado\r\nv1[1] <- 5; v1[2] <- 3; v1[3] <- 10; v1; length(v1)\r\n\r\n\r\n[1]  5  3 10\r\n[1] 3\r\n\r\nAssim, como exercício vocês podem completar para os dois outros vetores. Uma vez criado o vetor, se desejarmos acessar os seus elementos, usamos também o sistema de indexação:\r\n\r\n\r\n# Vetor numerico de comprimento 0\r\nv1 <- numeric(0)\r\nv2 <- character(0)\r\nv3 <- logical(0)\r\n\r\n# Inserimos 3 elementos em v1 e depois imprimos o seu resultado\r\nv1[1] <- 5; v1[2] <- 3; v1[3] <- 10\r\n\r\n# Imprimindo apenas o primeiro valor\r\nv1[1]\r\n\r\n\r\n[1] 5\r\n\r\n# Imprimindo os dois ultimos\r\nv1[2:3]; v1[c(2, 3)]\r\n\r\n\r\n[1]  3 10\r\n[1]  3 10\r\n\r\n# Imprimindo todos\r\nv1\r\n\r\n\r\n[1]  5  3 10\r\n\r\nAritmética e outras operações\r\nAs operações com vetores não necessariamente são as operações realizadas baseadas na álgebra de matrizes. O que a linguagem R faz é realizar as operações elemento a elemento, mantendo o comprimento de tamanho igual ao tamanho do maior vetor na operação. Vejamos as operações aritméticas entre vetores de tamanho 1:\r\n\r\n\r\n# Soma de dois vetores\r\n2 + 3\r\n\r\n\r\n[1] 5\r\n\r\n# Exceto pela sintaxe, '+' eh uma chamada de funcao\r\n`+`(2, 3)\r\n\r\n\r\n[1] 5\r\n\r\n# Subtracao de dois vetores\r\n3 - 2\r\n\r\n\r\n[1] 1\r\n\r\n# Exceto pela sintaxe, '-' eh uma chamada de funcao\r\n`-`(3, 2)\r\n\r\n\r\n[1] 1\r\n\r\n# Multiplicacao de dois vetores\r\n3 * 2\r\n\r\n\r\n[1] 6\r\n\r\n# Exceto pela sintaxe, '*' eh uma chamada de funcao\r\n`*`(3, 2)\r\n\r\n\r\n[1] 6\r\n\r\n# Divisao de dois vetores\r\n3 / 2\r\n\r\n\r\n[1] 1.5\r\n\r\n# Exceto pela sintaxe, '/' eh uma chamada de funcao\r\n`/`(3, 2)\r\n\r\n\r\n[1] 1.5\r\n\r\nEssas mesmas operações podem ser realizadas elemento a elemento para vetores de comprimento maior que 1, observe:\r\n\r\n\r\n# Soma de vetores\r\nc(4, 5, 6) + c(1, 2, 3)\r\n\r\n\r\n[1] 5 7 9\r\n\r\n# Subtracao de  vetores\r\nc(4, 5, 6) + c(1, 2, 3)\r\n\r\n\r\n[1] 5 7 9\r\n\r\n# Multiplicacao dois vetores\r\nc(4, 5, 6) * c(1, 2, 3)\r\n\r\n\r\n[1]  4 10 18\r\n\r\n# Divisao de dois vetores\r\nc(4, 5, 6) / c(1, 2, 3)\r\n\r\n\r\n[1] 4.0 2.5 2.0\r\n\r\nQuando os vetores não têm mesmo comprimento, o R completará de forma sequencial o menor vetor até que ele atinja o tamanho do maior vetor, observe:\r\n\r\n\r\n# Soma de vetores de comprimento diferente\r\n1:10 + 3:10\r\n\r\n\r\n [1]  4  6  8 10 12 14 16 18 12 14\r\n\r\nO segundo vetor recebeu os elementos 3, 4, 5, isto é, os três primeiros elementos do vetor, para que o seu comprimento se tornasse igual ao comprimento do primeiro vetor. Após isso, foi realizado a soma elemento a elemento. Esse provedimento ocorre com os demais tipos de operações.\r\nDemais operações podem ser realizadas de acordo com as funções apresentadas na Tabela abaixo.\r\nFunção (Ou operador)\r\nFinalidade\r\n+\r\nSoma unária, por exemplo (+ 4), ou binária entre dois vetores\r\n-\r\nSubtração unária, por exemplo (- 3), ou binária entre dois vetores\r\n*\r\nMultiplicação entre dois vetores\r\n/\r\nDivisão entre dois vetores\r\n^ ou **\r\nExpoenciação binária, isto é 2^3 ou 2 ** 3\r\n%/%\r\nDivisão inteira\r\n%%\r\nRestante da divisão\r\nsum()\r\nSoma de elementos do vetor\r\nprod()\r\nProdutório dos elementos do vetor\r\nsqrt()\r\nRaiz quadrada dos elementos de um vetor\r\nlog()\r\nFunção Logaritmo neperiano\r\nlog10()\r\nFunção Logaritmo na base 10\r\nexp()\r\nFunção exponencial\r\nmean()\r\nMédia dos elementos de um vetor\r\nsd()\r\nDesvio padrão dos elementos de um vetor\r\nvar()\r\nVariância dos elementos de um vetor\r\nmedian()\r\nMediana dos elementos de um vetor\r\nround()\r\nArredondamento de vetor numérico. Outros tipos são: trunc(), floor() e ceiling().\r\nDemais funções podem ser procuradas no manual An Introduction to R, ou execute no console ?Arithmetic.\r\nOperadores lógicos\r\nOs operadores lógicos têm a função de avaliar determinada condição e retornar TRUE/FALSE. São eles:\r\nOperador Lógico\r\nSintaxe\r\nPergunta\r\n<\r\na < b\r\na é menor que b?\r\n>\r\na > b\r\na é maior que b?\r\n==\r\na == b\r\na é igual b?\r\n!=\r\na != b\r\na é diferente b?\r\n>=\r\na >= b\r\na é maior ou igual a b\r\n<=\r\na <= b\r\na é menor ou igual a b?\r\n%in%\r\n\"a\" %in% c(\"a\", \"b\", \"c\")\r\nO elemento \"a\" está no vetor c(\"a\", \"b\", \"c\")?\r\nA operação binária significa que a função exige dois argumentos (ou operandos), isto é, <Argumento 1> <Operador> <Argumento 2>. Para mais detalhes, use no console ?Syntax.\r\nVejamos alguns exemplos:\r\n\r\n\r\n# Operador '>' entre vetores de comprimento 1\r\n1 > 3\r\n\r\n\r\n[1] FALSE\r\n\r\n# Operador '<' com vetor de comprimento maior que 1\r\n1 < c(0, 1, 3)\r\n\r\n\r\n[1] FALSE FALSE  TRUE\r\n\r\n# Operador '==' entre vetores\r\nc(1, 2, 3) == c(3, 2, 1)\r\n\r\n\r\n[1] FALSE  TRUE FALSE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\n1 %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\nc(1, 2) %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE FALSE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\nc(1, 2, 3) %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE FALSE  TRUE\r\n\r\n# Operador '%in%' verificando se os elementos do primeiro vetor\r\n# estao no segundo vetor\r\nc(1, 2, 3, 4) %in% c(3, 4, 5)\r\n\r\n\r\n[1] FALSE FALSE  TRUE  TRUE\r\n\r\nO que é interessante nesse operador %in%, que na realidade é uma função com dois argumentos, constitui uma forma de criar operadores binários especiais do tipo %<nome_sintatico>%, que esse tipo de função é uma das mais conhecidas hoje na análise de dados usando o operador pipe (%>%) do pacote magrittr da família de pacotes Tidyverse. A diferença no operador pipe é que o segundo operando (Argumento 2) é uma função que recebe no primeiro argumento o operando 1 (Argumento 1). Por fim, o operador %>% acaba sendo um operado unário. Veremos mais detalhes na seção sobre criação de funções.\r\nOperadores Booleanos\r\nO operadores booleanos avaliam diversas operações lógicas (condições) para ao final retornar um TRUE/FALSE. Vejamos a Tabela a seguir, com esses operadores e suas indagações.\r\nOperador Booleano (ou Função)\r\nSintaxe\r\nPergunta\r\n& ou &&\r\ncond1 & cond2\r\nAs cond1 e cond2 são verdadeiras?\r\n| ou ||\r\ncond1 | cond2\r\nA cond1 ou cond2 é verdadeira?\r\nxor()\r\nxor(cond1, cond2)\r\nApenas a cond1 ou a cond2 é verdadeiro?\r\n!\r\n!cond1\r\nÉ falso a cond1 ?\r\nany()\r\nany(cond1, cond2, ...)\r\nAlguma das condições são verdadeiras?\r\nall()\r\nall(cond1, cond2, ...)\r\nTodas as condições são verdadeiras?\r\nVejamos alguns exemplos:\r\n\r\n\r\n# Criando objetos\r\nx <- 1:3\r\ny <- 1:3\r\nz <- c(1, 2, 4)\r\n\r\n# Primeira condicao\r\nx == y\r\n\r\n\r\n[1] TRUE TRUE TRUE\r\n\r\n# Segunda condicao\r\ny == z\r\n\r\n\r\n[1]  TRUE  TRUE FALSE\r\n\r\n# Terceira condicao\r\nx == y & y == z\r\n\r\n\r\n[1]  TRUE  TRUE FALSE\r\n\r\nFica como sugestão de exercício os leitores criarem condições para os demais operadores booleanos.\r\n Matrizes bidimensionais\r\nA apresentação dos próximos objetos daqui pra frente, desde matrizes até quadro de dados (data frame) não é apresentar todas as manipulações possíveis sobre esses objetos. Mas mostrar a sua estrutura e condições básicas imposta sobre eles. Assim, não apresentaremos funções para manipulações com matrizes, por exemplo, porque isso não é o propósito do curso. Daremos a ideia de uma matriz é na realidade um vetor bidimensional, assim como um quadro de dados que na realidade é uma lista.\r\nQuando usamos um atributo chamado dim em um vetor atômico, criamos na realidade vetores bi ou multidimencionais, isto é, objetos do tipo matrizes ou arrays. Observe o que falados anteriormente, o atributo pode mudar a estrutura do objeto.\r\nVejamos alguns exemplos:\r\n\r\n\r\n# Criando um vetor atomico\r\nx <- 1:6; x\r\n\r\n\r\n[1] 1 2 3 4 5 6\r\n\r\n# Verificando se o objeto 'x' tem atributo adicionado\r\nattributes(x)\r\n\r\n\r\nNULL\r\n\r\n# Vamos verificar a classe do objeto x\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"integer\" \"numeric\"\r\n\r\n# Adicionando o atributo dim\r\ndim(x) <- c(2, 3) # 2 x 3 = 6 (Comp do vetor)\r\n# attr(x, \"dim\") <- c(2, 3)\r\n\r\n# Observando agora o comportamento do objeto 'x'\r\nx\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n# Verificando novamente se 'x' tem atributo\r\nattributes(x)\r\n\r\n\r\n$dim\r\n[1] 2 3\r\n\r\n# Verificando a classe do objeto\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"matrix\"  \"integer\" \"numeric\"\r\n\r\nO atributo dim recebeu uma informação bidimensional, isto é, o número de linhas e colunas, respectivamente. Uma outra forma para construir uma matriz é usando a função matrix, que de modo similar, temos:\r\n\r\n\r\n# Criando uma matriz\r\nmatrix(1:6, 2, 3)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Criando uma matriz\r\nmatrix(1:6, 2, 3, byrow = TRUE)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    2    3\r\n[2,]    4    5    6\r\n\r\nSe desejássemos que os números fossem inserido em linhas e não iniciados pelas colunas, usaríamos o argumento byrow = TRUE, isto é,\r\n\r\n\r\n# Criando uma matriz\r\nmatrix(1:6, 2, 3, byrow = TRUE)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    2    3\r\n[2,]    4    5    6\r\n\r\nPara acessarmos ou alterarmos os elementos de uma matriz, usamos o sistema de indexação similar ao vetor, porém, devemos indexar as linhas e colunas. Por exemplo, o elemento da primeira linha e primeira coluna pode ser obtido por x[1, 1], e assim por diante. Todos os elementos da linha 1, x[1,], ou todos os elementos da coluna 1, x[,1].\r\n Matriz multidimencional\r\nA ideia do objeto matriz multidimencional (ou array) é similar ao da matriz, a diferença é que agora é um vetor atômico de mais de duas dimensões. Vejamos,\r\n\r\n\r\n# Criando um vetor atomico\r\nx <- 1:12; x\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\r\n\r\n# Verificando se o objeto 'x' tem atributo adicionado\r\nattributes(x)\r\n\r\n\r\nNULL\r\n\r\n# Vamos verificar a classe do objeto x\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"integer\" \"numeric\"\r\n\r\n# Adicionando o atributo dim\r\ndim(x) <- c(2, 3, 2) # 2 x 3 x 2 = 12 (Comp do vetor x)\r\n# attr(x, \"dim\") <- c(2, 3, 2)\r\n\r\n# Observando agora o comportamento do objeto 'x'\r\nx\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n\r\n# Verificando novamente se 'x' tem atributo\r\nattributes(x)\r\n\r\n\r\n$dim\r\n[1] 2 3 2\r\n\r\n# Verificando a classe do objeto\r\nsloop::s3_class(x)\r\n\r\n\r\n[1] \"array\"   \"integer\" \"numeric\"\r\n\r\nObserve que criamos duas matrizes de dimensão (2 x 3). Para acessar os elementos desse objeto, usaremos também o sistema de indexação, agora acrescentando a terceira dimensão. Por exemplo, para acessar o elemento da linha 1, coluna 1, matriz 1, temos x[1, 1, 1], ou todos os elementos da linha 1, matriz 1, temos x[1, , 1].\r\nUma outra forma de criar um objeto array é usar a função array(). De modo similar, temos:\r\n\r\n\r\n# Criando um array\r\narray(1:12, c(2, 3, 2))\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n\r\nUm exercício para os leitores seria, como poderíamos criar um array de 4 dimensões?\r\nMostramos um quadro resumo de funções que podem ser utilizadas (Wickham (2019)). Para auxílio nas funções, use sempre o símbolo de interrogação antes das funções e execute no console. Por exemplo, ajuda da função names(), use ?names().\r\nVetor\r\nMatriz\r\nArray\r\nnames()\r\nrownames(), colnames()\r\ndimnames()\r\nlength()\r\nnrow(), ncol()\r\ndim()\r\nc()\r\nrbind(), cbind()\r\nabind::abind()\r\n-\r\nt()\r\naperm()\r\nis.null(dim(x))\r\nis.matrix()\r\nis.array\r\n Listas de dados\r\nAs listas são como vetores atômicos, porém mais complexos, isto é, os elementos de uma lista são vetores atômicos, como também outras listas, funções, expressões. Esta última é o que chamamos de objetos recursivos. A forma de se obter uma lista é pela função list(). Vejamos os comandos a seguir.\r\n\r\n\r\n# Criando uma lista\r\nl0 <- list(1:3, letters[5], list(1, 2, 3),\r\n           mean, expression(x ~ y))\r\n# Imprimindo a lista\r\nl0\r\n\r\n\r\n[[1]]\r\n[1] 1 2 3\r\n\r\n[[2]]\r\n[1] \"e\"\r\n\r\n[[3]]\r\n[[3]][[1]]\r\n[1] 1\r\n\r\n[[3]][[2]]\r\n[1] 2\r\n\r\n[[3]][[3]]\r\n[1] 3\r\n\r\n\r\n[[4]]\r\nfunction (x, ...) \r\nUseMethod(\"mean\")\r\n<bytecode: 0x0000000008634560>\r\n<environment: namespace:base>\r\n\r\n[[5]]\r\nexpression(x ~ y)\r\n\r\nPodemos acessar ou alterar os elementos de uma lista por meio do operador $, ou pelo sistema de indexação, que diferencia um pouco da indexação dos vetores. Por exemplo, o primeiro elemento desse vetor pode ser acessado por l0[[1]], o terceiro l0[[3]], e assim por diante. Para acessar informações específicas dentro dos elementos, usamos l0[[3]][2], isto é, imprimimos o segundo valor do segundo elemento. Os elementos de um lista são na realidade outros objetos, do qual conseguimos acessar também os elementos desses objetos.\r\nQuando nominamos os objetos contidos nas listas, podemos utilizar o operador $, para acessar esses objetos. Vejamos,\r\n\r\n\r\n# Criando uma lista\r\nl0 <- list(l01 = 1:3, \r\n           l02 = letters[5], \r\n           l03 = list(1, 2, 3),\r\n           l04 = mean, \r\n           l05 = expression(x ~ y))\r\n# Imprimindo o primeiro elemento (objeto) da lista 'l0'\r\nl0$l01\r\n\r\n\r\n[1] 1 2 3\r\n\r\n# Imprimindo o segundo\r\nl0$l02\r\n\r\n\r\n[1] \"e\"\r\n\r\nAs listas têm importâncias diversas dentro da linhagem R, por exemplo, o atributo em um objeto é armazenado em forma de lista. A coerção sempre força um vetor atômico a uma lista. Vejamos as linhas de comando a seguir.\r\n\r\n\r\n# Vejamos as linhas de comando\r\nl1 <- list(list(1, 2), c(3, 4))\r\nl2 <- c(list(1, 2), c(3, 4))\r\n# Vejamos as suas estruturas\r\nstr(l1)\r\n\r\n\r\nList of 2\r\n $ :List of 2\r\n  ..$ : num 1\r\n  ..$ : num 2\r\n $ : num [1:2] 3 4\r\n\r\nstr(l2)\r\n\r\n\r\nList of 4\r\n $ : num 1\r\n $ : num 2\r\n $ : num 3\r\n $ : num 4\r\n\r\nObservamos no objeto l1, temos uma lista cujos elementos são outra lista, o elemento 3 e o elemento 4. O vetor c(3, 4) se transformou em dois elementos de l1. No objeto l2, poderíamos pensar que como a lista está dentro da função c(), os elementos da lista fariam parte dos elementos de um vetor. Porém isso não ocorre. O que temos é uma coerção em que a lista força ao vetor a se tornar lista. Por fim, temos em l2 quatro elementos em uma lista.\r\n Quadro de dados\r\nO objeto quadro de dados (Data frame) é uma lista com classe data.frame, em que contém dois atributos. Porém, com algumas restrições:\r\nOs componentes devem ser vetores uni ou multidimencionais, listas ou até mesmo quadro de dados;\r\nAs colunas das matrizes, listas ou quadro de dados são inseridas como colunas do quadro de dados;\r\nA partir da versão R (4.0.0), os vetores terão mesmo modo no quadro de dados. Antes os vetores em modo caractere eram convertidos em objeto do tipo fator. Para convertê-lo automaticamente use o argumento stringsAsFactors = TRUE. Por sugestão, prefira a mudança usando a função factor(), para ter um maior controle dos níveis;\r\nOs objetos inseridos no quadro de dados devem ter o mesmo comprimento.\r\nPara criarmos um objeto do tipo quadro de dados (data frame), usamos a função data.frame(). Assim, como nas listas podemos inserir os objetos no quadro de dados inserindo o nome nas colunas ou não. A forma de acessar os elementos é interessante, podemos usar a sintaxe de indexação de uma lista ou de uma matriz. Vejamos os exemplos a seguir.\r\n\r\n\r\n# Criando um quadro de dados\r\ndados <- data.frame(x = 1:10, \r\n                    y = letters[1:10],\r\n                    z = rep(c(TRUE, FALSE), 5))\r\n# Imprimindo dados\r\ndados\r\n\r\n\r\n    x y     z\r\n1   1 a  TRUE\r\n2   2 b FALSE\r\n3   3 c  TRUE\r\n4   4 d FALSE\r\n5   5 e  TRUE\r\n6   6 f FALSE\r\n7   7 g  TRUE\r\n8   8 h FALSE\r\n9   9 i  TRUE\r\n10 10 j FALSE\r\n\r\n# Acessando os elementos de forma de lista\r\ndados[[1]]\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\ndados$x\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\n# Acessando os elementos em forma de matriz\r\ndados[1, ] # Coluna 1\r\n\r\n\r\n  x y    z\r\n1 1 a TRUE\r\n\r\ndados[1, 1] # Elemento da linha 1 coluna 1\r\n\r\n\r\n[1] 1\r\n\r\ndados[, 1] # Linha 1 \r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nQuando importamos um conjunto de dados, por exemplo usando a função read.table(), o objeto que armazena esses dados é um quadro de dados. Assunto discutido mais a frente.\r\nA semelhança com a forma retangular de uma matriz, faz com que algumas funções utilizadas em matrizes sejam utilizadas em quadro de dados:\r\nAs funções rownames() e colnames(), retornam ou inserem os nomes das linhas e colunas, respectivamente. A função names() retorna o nome das colunas.\r\nA dimensão das linhas e colunas podem ser obtidas pelas funções nrow() e ncol(), respectivamente. A função length() retorna o número de colunas.\r\nEm algumas situações, estamos interessados em otimizar o nosso tempo de programação, e achamos muito demorado ou não conveniente a utilização da sintaxe objeto$elemento para acessar os elementos de uma lista. Dessa forma, poderemos utilizar a função attach() para que os elementos do quadro de dados estejam disponíveis (anexados) no caminho de busca, e assim, possamos acessar os elementos (ou objetos) do quadro de dados sem precisar mencioná-lo. Vejamos,\r\n\r\n\r\n# Criando um quadro de dados\r\ndados <- data.frame(x = 1:10, \r\n                    y = letters[1:10],\r\n                    z = rep(c(TRUE, FALSE), 5))\r\n# Usando a funcao attach()\r\nattach(dados)\r\n\r\n# Acessando os elementos\r\nx; y; z\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n[1] 1 2 3\r\n[1] 1 2 4\r\n\r\n# Desanexando dados\r\ndetach(dados)\r\n\r\n\r\n\r\nEssa função attach() tem implicações, quando por exemplo se deseja inseri-la na construção de um pacote R. Iremos discutir esse ponto mais a frente. Para desanexar o quadro de dados, use detach(). A função attach() é genérica e pode ser usada em qualquer objeto de modo list ser anexado no caminho de busca.\r\n Importando dados\r\n\r\n\r\n\r\nA importação/exportação de dados era algo que em poucas linhas conseguíamos explicar sobre o ambiente R, no sentido de análise de dados. Entretanto, observando o terceiro princípio do R, afirmado por Chambers (2016):\r\n\r\n\r\nPrincípio da Interface: Interfaces para outros programas são parte do R\r\n\r\nHoje é uma realidade a interação que o ambiente R tem com outras interfaces (programas, linguagens, etc.). A facilidade em utilizar outras linguagens dentro do ambiente R torna assim mais complexo a importação/exportação de dados, uma vez que o objetivo do R, apesar do R Core Team ainda limitar a sua definição como o ambiente para a computação estatística, a ferramenta se tornou tão versátil, que hoje torna humilde essa definição. Para mais detalhes acesse o manual R Data Import/Export. Um outro fator e tema atual é a era dos grandes bancos de dados (Big Data), do qual se tem um grande conjunto de variáveis e necessitamos fazer a importação por APIs, por exemplo, ou outras vias. Temas como esses, abordaremos no módulo Programação em R (Nível Avançado).\r\nNesse momento, limitaremos esse assunto ao objetivo de termos um conjunto de dados em arquivos de texto (extensões do tipo .txt, .csv, xls), formato binário (.xls ou .xlsx) ou digitados manualmente pelo teclado do computador. Assim, a primeira forma de como os dados estão dispostos, precisaremos importá-los e armazená-los em um quadro de dados (data frame), para que esteja disponível na área de trabalho (ambiente global) do R, e dessa forma, possamos utilizá-lo. Ao final do tratamento dos dados, podemos exportar essas informações para arquivos externos, e daí também, usaremos os arquivos de textos e o formato binário (.xls), mensionados anteriormente.\r\nPreparação dos dados\r\nA primeira coisa que devemos entender quando desejamos construir o arquivo de dados, é entender que sempre organizaremos as variáveis em colunas, com os seus valores em linhas, Figura 12. Sempre a primeira linha das colunas representarar o nome das variáveis. Esse é outro ponto importante, pois devemos ter a noção que alguma linguagem irá ler esse banco de dados. Assim, quanto mais caracteres diferentes do padrão ASCII, mais difícil será a leitura desses dados. Assim, sugerimos alguns padrões:\r\nEvitem símbolos fora do padrão alfanumérico;\r\nEvitem mistura de letras minúsculas com letras maiúsculas. Isso facilitará o acesso a essas variáveis. Contudo, lembre-se do padrão de nomes sintéticos permissíveis do R;\r\nLembre-se que o banco de dados será utilizado para que um programa faça a sua leitura, portanto, deixe a formatação da apresentação dos dados para arquivos específico. Sendo assim, evitem comentários nesses arquivos, ou qualquer outro tipo de informação que não seja o banco de dados;\r\nEvitem palavras longas, por exemplo, segundavariavel (má escolha), segvar (boa escolha), seg_var (boa escolha);\r\nEvitem palavras compostas com espaço entre elas. Para isso use o símbolo _, por exemplo, var 2 (má escolha), var2 (boa escolha), var_2 (boa escolha);\r\n\r\n\r\n\r\nFigure 12: Modelo estrutural de um banco de dados.\r\n\r\n\r\n\r\nImportando dados\r\nA função primária responável pela importação de dados é a função scan(). Por exemplo, funções como read.table(), read.csv() e read.delim(), usam a função scan() em seu algoritmo.\r\nA primeira ideia sobre importação de dados pode ser inserindo-os pelo teclado no próprio ambiente R. Para isso, usaremos a função scan(). Vejamos,\r\n\r\n\r\n# Criando e inserido os elementos do objeto dados\r\nx <- scan()\r\n\r\n\r\n\r\nApós executado essa linha de comando, aparecerá no console 1: que significa, digitar o primeiro valor do objeto x, e depois clicar em ENTER. Depois 2:, que significa digitar o segundo valor, e clicar em ENTER. Depois de inserido todos os valores necessários, aperte a tecla ENTER duas vezes no console, para sair da função scan().\r\nO mais tradicional é usar programa para criação de banco de dados e deixá-lo pronto para o R lê-lo. O tipo de arquivo de texto que melhor controla a separação de variáveis é com a extensão .csv, uma vez que separamos as variáveis por “;” é o padrão. O arquivo de texto com extensão .txt, geralmente usa espaços. Isso acaba gerando problema de leitura no R, porque muitos usuários usam nomes de variáveis muito grandes, palavras compostas, de forma a desalinhar as colunas das variáveis. Daí, como a separação das variáveis é por meio de espaços, acaba gerando problema de leitura. Uma outra forma, é fazer importação de dados gerados pelo próprio R, extensão .RData.\r\nTemos a opção de usar um editor de banco de dados para essas extensões por meio de programas como MS Excel, Libre Office, dentre outros. Estes exportam arquivos binários do tipo .xls, .xlsx, dentre outros. Uma sugestão para diminuir complicações, é exportar os bancos de dados para arquivos de texto sitados acima, que também é possível ser exportado por esses programas. Isso evita a necessidade de ser instalado mais pacotes e dor de cabeça. Porém, para quem ainda deseja enfrentar, sugerimos a leitura do pacote readr, como exemplo, porém existem diversos outros pacotes para este mesmo fim.\r\nUma vez que o banco de dados está pronto, a leitura destes pode ser feita por alguns caminhos. Mostraremos o mais trivial que é o botão Import Dataset, terceiro quadrante, aba Environment, na IDE do RStudio. Veja na Figura 13.\r\n\r\n\r\n\r\nFigure 13: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nPosteriormente, indique o arquivo para leitura. Aparece algumas opções de tipo de arquivo. Em nosso caso, usaremos a opção From Text (base), que significa realizar a leitura para os tipos de arquivo .txt ou .csv. Daí os passos seguintes são:\r\nEscolher o arquivo para leitura dos dados;\r\n\r\n\r\n\r\nFigure 14: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nConfigurar a leitura do banco de dados. Uma prévia pode ser vista no quadro Data Frame. Se for visualizado, algum problema, isso significa que deve ser informado opções adicionais como separador de variáveis (Separator), símbolo para casas decimais (Decimal), dentre outras opções. Por fim, digitar o nome associado ao objeto (Name) que será criado do tipo quadro de dados (data frame), e clicar no botão Import;\r\n\r\n\r\n\r\nFigure 15: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nUma vez inserido, o RStudio apresenta a linha de comando utilizada para importar os dados no console (2º quadrante), o conjunto de dados (1º quadrante), e a ligação entre o nome e o objeto no ambiente global (3º quadrante).\r\n\r\n\r\n\r\nFigure 16: Usando o RStudio para importar dados.\r\n\r\n\r\n\r\nA outra forma é utilizar linhas de comando. Para isso utilizaremos a função read.table(). Antes de importarmos o banco de dados, algo interessante é inserir o arquivo de dados no diretório de trabalho no ambiente R. Para verificar o ambiente de trabalho use a função getwd(). Para alterar o local do ambiente de trabalho use setwd(). Se esse procedimento não for realizado, o usuário deve informar na função read.table(), o local exato do arquivo de texto.\r\nVamos usar como diretório o local C:\\cursor. Lembre-se que no R, a barra deve ser invertida. Vamos inserir nesse diretório três arquivos alfafa.txt, datast1980.txt e producao.csv.\r\nOs três conjuntos de dados são:\r\nalfafa.txt\r\n\r\nTRAT\r\nBLOCO\r\nPROD\r\nA\r\nI\r\n2.89\r\nA\r\nII\r\n2.88\r\nA\r\nIII\r\n1.88\r\nA\r\nIV\r\n2.90\r\nA\r\nV\r\n2.20\r\nA\r\nVI\r\n2.65\r\nB\r\nI\r\n1.58\r\nB\r\nII\r\n1.28\r\nB\r\nIII\r\n1.22\r\nB\r\nIV\r\n1.21\r\nB\r\nV\r\n1.30\r\nB\r\nVI\r\n1.66\r\nC\r\nI\r\n2.29\r\nC\r\nII\r\n2.98\r\nC\r\nIII\r\n1.55\r\nC\r\nIV\r\n1.95\r\nC\r\nV\r\n1.15\r\nC\r\nVI\r\n1.12\r\nD\r\nI\r\n2.56\r\nD\r\nII\r\n2.00\r\nD\r\nIII\r\n1.82\r\nD\r\nIV\r\n2.20\r\nD\r\nV\r\n1.33\r\nD\r\nVI\r\n1.00\r\n\r\ndatast1980.txt\r\n\r\ntrt\r\ny\r\n1\r\n19.4\r\n1\r\n32.6\r\n1\r\n27.0\r\n1\r\n32.1\r\n1\r\n33.0\r\n2\r\n17.7\r\n2\r\n24.8\r\n2\r\n27.9\r\n2\r\n25.2\r\n2\r\n24.3\r\n3\r\n17.0\r\n3\r\n19.4\r\n3\r\n9.1\r\n3\r\n11.9\r\n3\r\n15.8\r\n4\r\n20.7\r\n4\r\n21.0\r\n4\r\n20.5\r\n4\r\n18.8\r\n4\r\n18.6\r\n5\r\n14.3\r\n5\r\n14.4\r\n5\r\n11.8\r\n5\r\n11.6\r\n5\r\n14.2\r\n6\r\n17.3\r\n6\r\n19.4\r\n6\r\n19.1\r\n6\r\n16.9\r\n6\r\n20.8\r\n\r\nproducao.csv\r\n\r\nx\r\ny\r\n1\r\n6.7\r\n2\r\n7.9\r\n3\r\n9.1\r\n4\r\n6.6\r\n5\r\n7.5\r\n6\r\n8.8\r\n7\r\n7.7\r\n8\r\n7.6\r\n9\r\n6.5\r\n10\r\n7.9\r\n11\r\n8.7\r\n12\r\n6.2\r\n13\r\n7.9\r\n14\r\n7.4\r\n15\r\n9.7\r\n16\r\n6.2\r\n17\r\n4.9\r\n18\r\n5.6\r\n19\r\n7.0\r\n20\r\n6.0\r\n\r\nVejamos as linhas de comando para importar os dados.\r\n\r\n\r\n# Diretorio\r\ngetwd()\r\n\r\n# Mudadando para o diretorio de interesse\r\nsetwd(\"C:/cursor\")\r\n\r\n# Verificando os arquivos no diretorio de trabalho\r\nlist.files()\r\n\r\n# Importando os dados apontando para o diretorio do arquivo\r\ndados1 <- read.table(file = \"C:/cursor/alfafa.txt\", header = TRUE)\r\n\r\n# Considerando que o arquivo esta no diretorio de\r\n# trabalho, isto eh, getwd()\r\ndados2 <- read.table(\"alfafa.txt\", header = TRUE)\r\n\r\n# Importando os dados com decimais com ',' apontando para o diretorio do arquivo\r\ndados3 <- read.table(file = \"C:/cursor/dadost1980.txt\", header = TRUE, dec = \",\")\r\n\r\n# Considerando que o arquivo esta no diretorio de\r\n# trabalho, isto eh, getwd()\r\ndados4 <- read.table(file = \"dadost1980.txt\", header = TRUE, dec = \",\")\r\n\r\n# Importando os dados com decimais ',', e separados por ';' apontando para o diretorio do arquivo\r\ndados5 <- read.table(file = \"C:/cursor/producao.csv\", header = TRUE, dec = \",\", sep = \";\")\r\n\r\n# Considerando que o arquivo esta no diretorio de\r\n# trabalho, isto eh, getwd()\r\ndados6 <- read.table(file = \"producao.csv\", header = TRUE, dec = \",\", sep = \";\")\r\n\r\n# Importando da internet\r\ndados7 <- read.table(file = \"https://bendeivide.github.io/cursor/dados/alfafa.txt\", header = TRUE)\r\n\r\n\r\n\r\nNa última linha de comando, mostramos que também é possível importar dados de arquivos de texto da internet, e claro considerando que o usuário está com acesso a internet no momento da importação. E um recurso interessante que pode ser feito, principalmente para este caso, é salvar o banco de dados em um arquivo de dados no .RData. Dessa forma, todos os dados, inclusive os importados da internet serão agora armazenados nesse tipo de arquivo, e não precisaremos, nesse caso, de acesso a internet. Para salvar, usamos a função save(). Para carregar os dados e armazená-lo no ambiente global, usamos a função load(). Vejamos,\r\n\r\n\r\n# Diretorio\r\ngetwd()\r\n\r\n# Verificando os arquivos do diretorio de trabalho\r\nlist.files()\r\n\r\n# Importando os dados da internet\r\ndados7 <- read.table(file = \"https://bendeivide.github.io/cursor/dados/alfafa.txt\", header = TRUE)\r\n\r\n# Salvando em '.RData'\r\nsave(dados7, file = \"alfafa.RData\")\r\n\r\n# Carregando '.RData' para o ambiente global\r\nload(\"alfafa.RData\")\r\n\r\n\r\n\r\nPercebemos que as extensões .txt e .csv são idênticos, exceto pela estrutura de como os dados estão dispostos. Para comprovar isso, o usuário manualmente poderá mudar a entensão de um arquivo do tipo .csv para um arquivo .txt e observar em um bloco de notas.\r\nAté esse momento do curso, usamos as funções no R sem apresentar os argumentos dessas funções dentro dos parênteses. Isso porque quando inserimos os valores dos argumentos na posição correta destes, não precisaremos inserir o nome dos argumentos. Por exemplo, já usamos anteriormente a função mean() que calcula a média de um conjunto de valores, por exemplo, valores <- 1:10. Temos como primeiro argumento para essa função o x que representa um objeto R que recebe os valores para o cálculo. Assim, como sabemos que x é o primeiro argumento dessa função, podemos omitir o seu nome e calcular a média por mean(valores), que é o mesmo que mean(x = valores). Para mais detalhes, ?mean(). Para mais detalhes sobre a função read.table(), use ?read.table().\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n Funções\r\n\r\n\r\nMais uma vez, nos reportamos aos princípios do R (Chambers (2016)), mais especificamente ao segundo princípio,\r\n\r\n\r\nPrincípio da função: Tudo que acontece no R é uma chamada de função.\r\n\r\nPara que possamos compreender esse princípio, precisamos entender que uma função é um objeto, isto é, modo function18, assim como os vetores são, seguindo as mesmas ideias comentadas na seção anterior, e que as funções podem ser dividas em três componentes:\r\nArgumentos, função formals(),\r\nCorpo, função body() e\r\nAmbiente, função environment().\r\nPara o caso das funções primitivas, escritas na linguagem C, essa regra foge a excessão, e será comentado nos módulos seguintes. Dizemos que funções são primitivas de modo builtin ou special.\r\nA ideia de função aqui não pensando como uma relação matemática, mas como um sistema que tem uma entrada e saída. Podemos ter funções no ambiente R que organiza dados, e não operações matemáticas por exemplo. Vejamos a função sort() do pacote base que ordena de forma crescente ou descrescente um conjunto de valores,\r\n\r\n\r\n# Vetor\r\ny <- c(5, 3, 4); y\r\n\r\n\r\n[1] 5 3 4\r\n\r\n# Funcao\r\nsort(x = y)\r\n\r\n\r\n[1] 3 4 5\r\n\r\n# Argumentos da funcao sort\r\nformals(sort)\r\n\r\n\r\n$x\r\n\r\n\r\n$decreasing\r\n[1] FALSE\r\n\r\n$...\r\n\r\n# Corpo da funcao\r\nbody(sort)\r\n\r\n\r\n{\r\n    if (!is.logical(decreasing) || length(decreasing) != 1L) \r\n        stop(\"'decreasing' must be a length-1 logical vector.\\nDid you intend to set 'partial'?\")\r\n    UseMethod(\"sort\")\r\n}\r\n\r\n# Ambiente\r\nenvironment(sort)\r\n\r\n\r\n<environment: namespace:base>\r\n\r\nNesse caso, os argumentos x, decreascing e ..., são nomes que aguardam receber objetos para a execução da função sort(). Nem todos os argumentos necessitam receber objetos, a estes chamamos de argumentos padrão, como o caso do argumento decreascing com padrão igual a FALSE, que significa que o ordenamento dos dados será de forma não-decrescente. Observe que na função sort() entramos apenas com o argumento x = y, não precisando inserir decreascing = FALSE. Agora, para modificar o argumento padrão, basta acrescentar a alteração na função, isto é,\r\n\r\n\r\n# Funcao\r\nsort(x = y, decreasing = TRUE)\r\n\r\n\r\n[1] 5 4 3\r\n\r\nO '...' é um argumento especial e significa que pode conter qualquer número de argumentos. Geralmente é utilizado em uma função quando não se sabe o número exato de argumentos. Na subseção Como criar funções, entenderemos melhor.\r\nO próximo item é o corpo da função. É nele que inserirmos as instruções, isto é, as linhas de comandos necessárias a que destina a sua criação. Uma outra forma de acessarmos o corpo das funções é digitar no console apenas o seu nome sem o parêntese, isto é, sort.\r\nPor fim, o ambiente que no caso da função sort() representa o ambiente do pacote base, isto é, o namespace do pacote.\r\nPodemos observar que essas funções utilizadas até agora, não foram criadas pelo usuário. Estas funções vieram do que chamamos de pacotes. Alguns pacotes estão disponíveis quando instalamos o R, dizemos que estes são os pacotes da Base do R, para a linguagem. O principal pacote deles é o pacote base. Os demais pacotes desenvolvidos podem ser obtidos via CRAN, e falaremos mais adiante.\r\nO ambiente R apresenta uma versatilidade de manuais para a linguagem. Por exemplo, para verificar informações sobre um determinado pacote como o base, use help(package = \"base\"). A função help pode ser utilizada para funções de pacotes anexados. Por exemplo, help(\"sort\"). Uma outra função que pode ser usada para procurar por funções com determinado parte de nome é apropos(), isto é, para o exemplo anterior, temos apropost(\"sort\"). O pacote base sempre estará anexado, isto é, disponível no caminho de busca para a utilização. Para os que não estão anexados, a função help deve informar o nome da função que necessita de ajuda, bem como o seu pacote. Por exemplo, temos uma função read.dbf() do pacote foreign, Base do R, porém, ele não está anexado19 ao inicializar o R. Assim, caso não anexe o pacote, usando library(\"foreign\"), a ajuda sobre a função pode ser realizada com help(\"read.dbf\", package = \"foreign\"). Outras sintaxes para a função help() é usar ? antes do nome de uma função de um pacote anexado, isto é, ?sort().\r\nPara os manuais de ajuda na internet, use ?? antes do nome da função, por exemplo ??sort(), read.dbf(), etc. Essa sintaxe não precisa dos pacotes estarem anexados para ajuda de determinada função, porém o pacote necessita estar instalado. Para mais detalhes sobre pacotes, teremos uma seção sobre Pacotes.\r\nAs chamadas de funções podem ocorrer de três formas: aninhada, intermediária ou de forma pipe. As duas primeiras formas da Base do R, e o segundo foi uma sintaxe utilizada pelo pacote magrittr, e na versão do R 4.1, já existe o operador pipe nativo (|>), sendo comentado no módulo Programação em R (Nível Intermediário).\r\nSuponha que desejamos calcular o desvio padrão de um conjunto de valores. Vamos utilizar as três formas:\r\nAninhado:\r\n\r\n\r\n# Gerando 100 numeros aleatorios de uma distribuicao normal\r\nset.seed(10) # Semente\r\nx <- rnorm(100)\r\n\r\n# Calculando o desvio padrao\r\nsqrt(var(x))\r\n\r\n\r\n[1] 0.9412359\r\n\r\nintermediária:\r\n\r\n\r\n# Calculando o desvio padrao\r\nvari <- var(x)\r\ndesvpad <- sqrt(vari); desvpad\r\n\r\n\r\n[1] 0.9412359\r\n\r\nPipe:\r\n\r\n\r\n# Anexando o pacote\r\nlibrary(magrittr)\r\n\r\n# Calculando o desvio padrao\r\nx %>%\r\n  var() %>%\r\n  sqrt()\r\n\r\n\r\n[1] 0.9412359\r\n\r\nA ideia da chamada de função aninhada é inserir função como argumento de funções sem necessidade de associar nomes aos objetos. A ordem de execução começa sempre da direita para a esquerda. No caso da chamada de função intermediária, associamos nomes a cada função, e os passos seguem. Por fim, o operador especial pipe (%>%) tem como primeiro operando o primeiro argumento da função no segundo operando.\r\nQuando desenvolvemos pacotes, preferimos os dois primeiros, pois é a forma tradicional de chamadas de função no R. A chamada de função pipe é muito utilizada para ciência dos dados.\r\nEstruturas de controle\r\n\r\n\r\nAs funções que utilizaremos, a seguir, são utilizadas quando desejamos realizar processos repetitivos para um determinado fim ou condicionado, as famosas estruturas de controle. Assim, como em outras linguagens, as funções utilizadas são: if(), switch(), ifelse(), while(), repeat, for(). Esses objetos tem modo special20, porque as expressão não são necessariamente avaliadas. Já a função ifelse() é de modo closure21. Esse é um tipo de função implementado por function().\r\nA ideias das estruturas de controle de modo special é:\r\nfunção (condição) {\r\n  expressão\r\n}\r\nA sintaxe das funções repeat e swicth() fogem um pouco desse padrão, e explicaremos em sua aplicação.\r\nApesar da linguagem R ser interpretada, acaba ganhando a fama de que as funções loops são mais lentas. Em alguns casos, a construção do algoritmo proporciona isso e não a implementação dessas funções em si. Um exemplo que podemos citar, são as cópias de objetos podem ter um gasto de memória ativa imenso no processo e proporcionar um gasto computacional. E isso foi devido a forma de como o algoritmo copiou os objetos, e não as funções lopps. Veremos isso no módulo Programação em R (Nível Intermediário).\r\nA primeira estrutura é o if(), com sintaxe:\r\nif (condição) {\r\n  expressão sob condição = TRUE\r\n} else {\r\n  expressão sob condição = FALSE\r\n}\r\nou de forma alternativa:\r\nif (condição) {\r\n  expressão sob condição = TRUE\r\n}\r\nObserve o primeiro exemplo,\r\n\r\n\r\n# Objeto\r\ni <- 5\r\n# Estrutura if()\r\nif (i > 3) {\r\n  print(\"Maior que 3!\")\r\n}\r\n\r\n\r\n[1] \"Maior que 3!\"\r\n\r\nVejamos mais um exemplo,\r\n\r\n\r\n# Objeto numerico\r\nx <- 10\r\n\r\n# Estrutura 'if'\r\nif (is.numeric(x)) {\r\n  print(\"Isso é um número\")\r\n} else {\r\n  print(\"Isso não é um número\")\r\n}\r\n\r\n\r\n[1] \"Isso é um número\"\r\n\r\n# eh o mesmo que\r\nif (is.numeric(x) == TRUE) {\r\n  print(\"Isso é um número\")\r\n} else {\r\n  print(\"Isso não é um número\")\r\n}\r\n\r\n\r\n[1] \"Isso é um número\"\r\n\r\nobserve na primeira forma que a condição na função nós não precisamos perguntar se is.numeric(x) == TRUE, porque isso já é implícito na função, e acaba levando a primeira expressão print(\"Isso é um número\"). No R, essa estrutura de controle não é vetorizado, isto é, se a condição houver um vetor lógico maior que 1, apenas os primeiros itens serão usados. Vejamos,\r\n\r\n\r\n# Objetos\r\nx <- 5\r\nw <- 3:8\r\n\r\n# Primeira sintaxe (Preferivel)\r\nif (x < w) {\r\n  x\r\n} else {\r\n  w\r\n}\r\n\r\n\r\n[1] 3 4 5 6 7 8\r\n\r\n# Segunda forma\r\n# if (x < w) x else w\r\n\r\n\r\n\r\nComo forma alternativa, pode ser usado a função ifelse, cuja sintaxe é:\r\nifelse(condição, expressão sob TRUE, expressão sob FALSE)\r\nAssim, temos:\r\n\r\n\r\n# Objetos\r\nx <- 5\r\nw <- 3:8\r\n\r\n# Primeira sintaxe (Preferivel)\r\nifelse(x < w, x, w)\r\n\r\n\r\n[1] 3 4 5 5 5 5\r\n\r\nPodemos estar interessados em resultados específicos para determinadas condições. Por exemplo,\r\n\r\n\r\nx <- 2 # numero ou palavra\r\n\r\n# Estrutura 'if'\r\nif (is.character(x)) {\r\n  \"palavra\"\r\n} else {\r\n    if ((x %% 2) == 0) {\r\n      \"numero_par\"\r\n    } else {\r\n        if ((x %% 2) == 1) {\r\n          \"numero_impar\"\r\n        }\r\n    }\r\n}\r\n\r\n\r\n[1] \"numero_par\"\r\n\r\nOutro exemplo seria,\r\n\r\n\r\n# Objeto\r\nset.seed(15) # Fixando a semente\r\nx <- rnorm(1000) # Gerando 1000 numeros aleatorios\r\n\r\n# medida descritiva\r\nopcao <- \"media\" # opcoes: \"media\", \"mediana\", \"medapar\" (media aparada)\r\n\r\nif (opcao == \"media\") {\r\n  cat(\"A média aritmética é:\", round(mean(x), 4))\r\n} else {\r\n    if (opcao == \"mediana\") {\r\n      cat(\"A mediana é:\", round(mean(x), 4))\r\n    } else {\r\n        if (opcao == \"medapar\") {\r\n          cat(\"A média aparada é:\", round(mean(x, trim = 0.1), 4))\r\n        }\r\n    }\r\n}\r\n\r\n\r\nA média aritmética é: 0.037\r\n\r\nPoderíamos utilizar a função switch(), para esse mesmo código, isto é,\r\n\r\n\r\nswitch(opcao,\r\n   media = cat(\"A média aritmética é:\", round(mean(x), 4)),\r\n   mediana = cat(\"A mediana é:\", round(mean(x), 4)),\r\n   medapar = cat(\"A média aparada é:\", round(mean(x, trim = 0.1), 4))\r\n)\r\n\r\n\r\nA média aritmética é: 0.037\r\n\r\nAs três estruturas de loop no R são: repeat, while() e for(). A primeira delas é repeat, apresentamos sua sintaxe:\r\nrepeat {\r\n   expressão ...\r\n}\r\nJuntamente com o repeat, usamos as funções break e next, pois a função repeat não tem uma condição explícita. Vejamos, alguns exemplos.\r\n\r\n\r\n# Contador\r\ni <- 1\r\n# Loop repeat\r\nrepeat {\r\n  if (i > 5) {\r\n    break\r\n  } else {\r\n    print(i)\r\n    i <- i + 1\r\n  }\r\n}\r\n\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n\r\nObserve que quando i <- 6, o ciclo entrou na condição if(i > 5) e avaliou a função break, que resultou na quebra do ciclo. Assim, a função print(i) não foi mais acionada, e os resultados foram impressos até o número 5. No próximo exemplo, acrescentamos a função next.\r\n\r\n\r\n# Contador\r\ni <- 1\r\n# Loop repeat\r\nrepeat {\r\n  if (i > 5) {\r\n    break\r\n  }\r\n  else {\r\n    if (i == 3) {\r\n      i <- i + 1\r\n      next\r\n    }\r\n    print(i)\r\n    i <- i + 1\r\n    }\r\n}\r\n\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 4\r\n[1] 5\r\n\r\nSimilar a essa função, temos while(), que agora, temos uma condição de parada, cuja sintaxe é:\r\nwhile (condição) {\r\n   expressão ...\r\n}\r\nNessa função, também podemos usar as funções break e next, como usados na função repeat. Vejamos um exemplo,\r\n\r\n\r\n# Contador\r\ni <- 1\r\n# Loop while\r\nwhile (i <= 5) {\r\n  print(i)\r\n  i <- i + 1\r\n}\r\n\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n\r\nNesse caso, não foi necessário utilizar a função break, devido a condição que ela permite impor ao ciclo. Vejamos um outro exemplo,\r\n\r\n\r\n# Contador\r\ni <- 1\r\n# Loop while\r\nwhile (i <= 5) {\r\n  if (i == 3) {\r\n    i <- i + 1\r\n    next\r\n  }\r\n  print(i)\r\n  i <- i + 1\r\n}\r\n\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 4\r\n[1] 5\r\n\r\nObservamos a utilização da função next, similar ao que foi realizado com a função repeat. Por fim, a função for(), cuja sintaxe é dada por:\r\nfor (contador in lista) {\r\n   expressão ...\r\n}\r\nCom essa função, também podemos utilizar break e next. Porém, o controle do ciclo nessa sitação é maior, e menos necessário essas funções. Vejamos um primeiro exemplo,\r\n\r\n\r\n# Loop for\r\nfor (i in 1:5) {\r\n  print(i)\r\n}\r\n\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n\r\nObserve que a implementação, dos algoritmos anteriores, é bem mais simples usando a função for(). Vejamos um próximo exemplo,\r\n\r\n\r\n# Loop for\r\nfor (i in 1:5) {\r\n  if (i == 3) {\r\n    next\r\n  }\r\n  print(i)\r\n}\r\n\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 4\r\n[1] 5\r\n\r\nMais uma vez, foi utilizado a função next, sem necessidade agora, de atualizar o contador i, uma vez que já está definido na função for().\r\nVeremos na próxima subseção, que temos funções de alto nível que podem substituir as funções loops. São as chamadas funções da família apply.\r\nComo criar funções\r\n\r\n\r\nAté esse momento, usamos funções já desenvolvidas no R, seja dos pacotes da Base, seja via instalação dos pacotes via CRAN. Agora, iremos desenvolver as nossas próprias funções.\r\nComo falado anteriormente, no início dessa seção, a estrutura da função criada se mantém, argumento, corpo e ambiente. Para isso, usaremos a função function. O modo desse objeto é closure22. Vejamos a sua sintaxe,\r\n# Forma usual\r\nnome_funcao <- function(arg1, arg2, ...) {\r\n   corpo: comandos..\r\n}\r\n# Forma simplificada\r\nnome_funcao <- function(arg1, arg2, ...) corpo\r\nVejamos um primeiro exemplo,\r\n\r\n\r\nfun1 <- function(x) {\r\n  res <- x + 1\r\n  return(res)\r\n}\r\n\r\n\r\n\r\nNesse caso, temos uma função chamada fun1, cujo argumento de entrada é x. Observe que uma função é como um objeto do tipo vetor, associamos um nome ao objeto da mesma forma. O corpo apresenta uma delimitação por chaves {...}, em que apresenta um comando de atribuição res que se associa a soma x + 1, e por fim, o resultado dessa função, imprime res, por meio da função return(). Para utilizar essa função, fazemos\r\n\r\n\r\nfun1(x = 5)\r\n\r\n\r\n[1] 6\r\n\r\nO que aconteceu foi que ao assumir x = 5, essa informação foi repassada para o corpo da função, aonde existia x, foi substituído por 5, para esse caso. A função + é chamada, a expressão x + 1 avaliada, e nome res se associa ao resultado da expressão. Por fim, quando a função fun1 é chamada, o resultado de res é impresso no console, por meio de return(res). Vamos verificar os três componentes da função fun1,\r\n\r\n\r\n# Argumentos\r\nformals(fun1)\r\n\r\n\r\n$x\r\n\r\n# Corpo\r\nbody(fun1)\r\n\r\n\r\n{\r\n    res <- x + 1\r\n    return(res)\r\n}\r\n\r\n# Ambiente\r\nenvironment(fun1)\r\n\r\n\r\n<environment: R_GlobalEnv>\r\n\r\nO corpo da função é executado de forma sequencial, a partir da primeira linha até a última. Apesar de recomendado, também não é obrigatório o uso da função return(), veja\r\n\r\n\r\n# Funcao\r\nfun2 <- function(x) x + 1\r\n# Executando\r\nfun2(5)\r\n\r\n\r\n[1] 6\r\n\r\nFunção anônima\r\nPodemos também ter o que chamamos de função anônima, da qual não associamos nome as funções. Contudo, sendo criada esta não pode ser recuperada como qualquer outro objeto. Essa forma é interessante quando não precisamos dela após o seu uso. Por exemplo, queremos calcular a integral, \\[\r\n\\int^{1}_{0}x^2dx = \\frac{1}{3},\r\n\\]\r\ne criamos uma função \\(x^2\\). Então,\r\n\r\n\r\nintegrate(f = function(x) x^2,\r\n          lower = 0,\r\n          upper = 1)\r\n\r\n\r\n0.3333333 with absolute error < 3.7e-15\r\n\r\nA função integrate é utilizada para o cálculo de integral, do qual, passamos os argumentos, função (f), limite inferior (lower) e limite superior (upper) da integração, respectivamente. Observe que não houve necessidade de nomear a função no argumento, pois não há objetivo de reutilizado.\r\nChamadas de função\r\nAs chamadas para essas funções ocorrem da mesma forma que as funções apresentadas da Base do R. Vejamos o cálculo do desvio padrão novamente,\r\n\r\n\r\n# Funcao auxiliar 1\r\naux1 <- function(x) x - mean(x)\r\n# Funcao auxiliar 2\r\naux2 <- function(x) x^2\r\n# Funcao auxiliar 3\r\naux3 <- function(x) {\r\n  sum(x) / (length(x) - 1)\r\n}\r\n\r\n# Gerando 100 numeros aleatorios de uma distribuicao normal\r\nset.seed(10)\r\nx <- rnorm(100)\r\n\r\n# Calculo do desvio padrao (aninhado)\r\nsqrt(aux3(aux2(aux1(x))))\r\n\r\n\r\n[1] 0.9412359\r\n\r\n# Calculo do desvio padrao (intemediario)\r\ndp <- aux1(x)\r\ndp <- aux2(dp)\r\ndp <- aux3(dp)\r\ndp <- sqrt(dp)\r\ndp\r\n\r\n\r\n[1] 0.9412359\r\n\r\n# Calculo do desvio padrao (pipe)\r\nx %>%\r\n  aux1() %>%\r\n  aux2() %>%\r\n  aux3() %>%\r\n  sqrt()\r\n\r\n\r\n[1] 0.9412359\r\n\r\nOrdenação de argumentos\r\nOs argumentos nas funções podem ser nomeados ou não. Quando nomeados, a ordem como são inseridos na função não importa. Já os argumentos não nomeados, seus valores precisam estar na ordem como a função foi desenvolvida. Vejamos,\r\n\r\n\r\nestdesc <- function(x, opcao) {\r\n  res <- switch(opcao,\r\n           media = round(mean(x), 4),\r\n           mediana = round(mean(x), 4),\r\n           medapar = round(mean(x, trim = 0.1), 4))\r\n  return(res)\r\n}\r\n\r\n# Objeto\r\nset.seed(15)\r\nx <- rnorm(1000)\r\n\r\n# Argumentos nomeados na funcao\r\nestdesc(x = x, opcao = \"media\")\r\n\r\n\r\n[1] 0.037\r\n\r\nestdesc(opcao = \"media\", x = x)\r\n\r\n\r\n[1] 0.037\r\n\r\n# Argumentos não nomeados ordenados\r\nestdesc(x, \"media\")\r\n\r\n\r\n[1] 0.037\r\n\r\n# Argumentos não ordenados (Gera erro)\r\nestdesc(\"media\", x)\r\n\r\n\r\nError in switch(opcao, media = round(mean(x), 4), mediana = round(mean(x), : EXPR deve ser um vetor de comprimento 1\r\n\r\nObjeto reticências (...)\r\nO objeto reticências é do tipo pairlist, um tipo de objeto usado bastante internamente no R, e dificilmente utilizado no código interpretado. De modo que não temos acesso direto ao objeto .... Contudo, esse objeto tem um papel fundamental nas funções, quando damos a liberdade de inserir mais argumentos além dos definidos na função. Vejamos,\r\n\r\n\r\n# Funcao que plota um grafico\r\ngrafico <- function(x, y, ...) {\r\n  plot(x = x, y = y, ...)\r\n}\r\n# Vetores\r\nx <- 1:10; y <- rnorm(10)\r\n# Chamada 1, com os argumentos definidos\r\ngrafico(x = x, y = y)\r\n\r\n\r\n\r\n# Chamada 2, inserindo argumentos nao definidos\r\ngrafico(x = x, y = y, main = \"Título\")\r\n\r\n\r\n\r\n\r\nIsso ocorre, porque temos a função plot() no corpo da função grafico() que apresenta muitos argumentos. Dessa forma, criamos a função grafico(), com os argumentos que representam as coordenadas, mas a reticências (...) garantem que os demais argumentos de plots, omitidos, possam ser utilizados.\r\nEscopo léxico\r\nVamos retornar aos componentes da função fun1,\r\n\r\n\r\n# Argumentos\r\nformals(fun1)\r\n\r\n\r\n$x\r\n\r\n# Corpo\r\nbody(fun1)\r\n\r\n\r\n{\r\n    res <- x + 1\r\n    return(res)\r\n}\r\n\r\n# Ambiente\r\nenvironment(fun1)\r\n\r\n\r\n<environment: R_GlobalEnv>\r\n\r\nObserve que o último componente é o ambiente onde o nome fun1 foi associado a função. Este ambiente é chamado de ambiente envolvente. Nesse caso é o ambiente global. Contudo, quando a função é executada, momentaneamente é criado o ambiente de execução. É nesse ambiente que os nomes que estão no corpo da função são associados aos objetos. Vejamos um primeiro exemplo,\r\n\r\n\r\nx <- 10\r\nfun <- function() {\r\n  x <- 2\r\n  x\r\n}\r\n# Chamando a funcao fun\r\nfun()\r\n\r\n\r\n[1] 2\r\n\r\nPor causa do ambiente de execução que o objeto x dentro da função é retornado, ao invés do que foi definido fora da função. Isso porque o ambiente de execução mascara os nomes definidos dentro da função dos nomes definidos fora da função. Esse é uma primeira característica do escopo léxico nas funções em R.\r\nAnteriormente, falamos sobre a atribuição, que representa a forma como os nomes se associam aos objetos. Agora, o escopo vem a ser a forma como os nomes encontram seus valores associados. O termo léxico significa que as funções podem encontrar nomes e seus respectivos valores associados, definidos no ambiente onde a função foi definida, isto é, no ambiente de função. Claro que isso segue regras, e a primeira foi a máscara de nome falada anteriormente.\r\nPorém quando não existe um nome vinculado a um objeto, e este foi definido no ambiente de função, o valor é repassado para o corpo da função. Observe,\r\n\r\n\r\nx <- 10\r\nfun <- function() {\r\n  x\r\n}\r\n# Chamando a funcao fun\r\nfun()\r\n\r\n\r\n[1] 10\r\n\r\nO resultado de fun() foi 10, porque como a função procurou no ambiente de execuções e não encontrou esse nome, a função foi até o ambiente superior, no caso, o ambiente de execuções. Como falado anteriormente, todo ambiente tem um pai (ou ambiente superior). Essa hierarquização é observada no caminho de busca, que pode ser acessado por search(), ou seja,\r\n\r\n\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"        \"package:magrittr\"  \"package:leaflet\"  \r\n [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\r\n [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \r\n[10] \"Autoloads\"         \"package:base\"     \r\n\r\nO ambiente corrente do R sempre será o ambiente ambiente global (.GlobalEnv). O ambiente de execução não aparece, porque ele é momentâneo. Então após buscar no ambiente de execução e não encontrar, é pelo caminho de busca que a função irá procurar pelos objetos inseridos no corpo da função. Ele só existe quando a função é chamada e não quando ela é definida, isto é,\r\n\r\n\r\n# Funcao\r\nfun <- function() x + 10\r\n# Objeto 1\r\nx <- 10\r\n# Chamada1\r\nfun()\r\n\r\n\r\n[1] 20\r\n\r\n# Objeto 2\r\nx <- 20\r\n# Chamada 2\r\nfun()\r\n\r\n\r\n[1] 30\r\n\r\nObserve que após ser criada a função fun(), o nome x se associou ao objeto 10. Posteriormente, fun() foi chamada e o resultado foi 20. Contudo, o nome x se associou a outro objeto 20, e após a segunda chamada da função fun(), o resultado foi 30, porque a função procura os valores quando ela é executada, e não quando é criada, é a característica de pesquisa dinâmica do escopo léxico.\r\nUma outra situação é a seguinte,\r\n\r\n\r\n# Objeto\r\nn <- 1\r\n# Funcao\r\nfun <- function() {\r\n  n <- n + 1\r\n  n\r\n}\r\n# Chamada 1\r\nfun()\r\n\r\n\r\n[1] 2\r\n\r\n# Chamada 2\r\nfun()\r\n\r\n\r\n[1] 2\r\n\r\nNessas linhas de comando, poderíamos pensar que após ter executado a primeira chamada, que retornou valor 2, a segunda chamada retornaria o valor 3, como ocorre com as variáveis estáticas na linguagem C. Aqui nesse caso, resultado independente do número de chamadas será sempre o mesmo, porque uma outra característica do escopo léxico no R é o novo começo, porque a cada vez que a função é executada um novo ambiente de execução é criado, e portanto, cada execução dos comandos de atribuição e expressão são executados de forma independentes nas chamadas de funções.\r\nAlgo que não havíamos falado anteriormente, é que a função function() permite que não seja definido argumentos, devido a flexibilidade do escopo léxico das funções em R. É essa característica que faz com que os comandos no corpo das funções encontrem os objetos que não estão definidos na própria função. Mais detalhes, será visto no módulo Programação em R (Nível Intermediário).\r\n\r\n Boas práticas de como escrever um código\r\n\r\n\r\nNesse momento, entendemos os principais objetos para escrevermos os nossos scripts. Quando escrevemos um código, duas consequências ocorrem: - guardá-lo para futuras consultas, ou - compartilhamento.\r\nNesses dois casos, percebemos que alguém irá ler esse código, ou até mesmo o próprio usuário, irá retornar àquelas linhas de código e tentar raciocinar quais as ideias por trás disso tudo. Para um melhor entendimento de seu script, nada mais importante do que uma boa escrita, separação das estruturas por hierarquização, comentários, etc.\r\nUma primeira ferramenta que pode ser configurada para quem usa o rstudio é acionar todas as opções de diagnóstico do seu código. Para isso no menu:\r\nTools > Global options > Code > Editing. Marque todas as opções em General;\r\nTools > Global options > Code > Display, Marque todas as opções;\r\nTools > Global options > Code > Diagnostics. Marque todas as opções em R Diagnostics.\r\nCom isso, colorações nas linhas de comando ocorrerão, distinguindo diversas estruturas, como linhas de comentário, funções, espaçamentos, dentre outras coisas.\r\nUma vez feito isso, vamos para o passo seguinte que são as boas práticas de como se escrever um script. Temos algumas ferramentas prontas, como o pacote styler e como alternativa o formatR, que automatiza todo o nosso código seja em script, contido em um pacote, ou diretório. Acesse https://yihui.org/formatr, para mais detalhes. Para instalar e anexar o pacote styler, use as linhas de comando:\r\n\r\n\r\n# Instalando pacote\r\ninstall.packages(styler)\r\n# Carregando e anexando\r\nlibrary(styler)\r\n\r\n\r\n\r\nVejamos a seguinte ilustração, para entendermos a funcionabilidade desse pacote .\r\n\r\n\r\n\r\nFigure 17: Estilo de código com o pacote styler.\r\n\r\n\r\n\r\nPela Figura 17, percebemos que inicialmente, a leitura do código sem nenhum padrão de hierarquização, de funções dentro de funções, torna mais difícil a leitura quando não seguimos algumas regras básicas de espaçamentos iniciais nas linhas de comando. Ao passo que, após aplicar a função styler:::style_active_file(), conseguimos distinguir quais as funções que estão dentro de outras, bem como as suas expressões.\r\nNomes de arquivos\r\nApesar de toda essa facilidade, vamos apresentar algumas ideias. A primeira noção é o nome do arquivo. Padronizem a extensão .R e evitem espaços em nomes compostos,\r\nBoa escolha:\r\n-----------\r\nscript.R\r\nnome_composto.R\r\nnome-composto.R\r\n\r\nMá escolha:\r\n-----------\r\nscript.r\r\nnome composto.r\r\nComentar as linhas de comando\r\nSempre que escrever uma linha de comando ou uma sequência de linhas de comando para um mesmo fim, comente sobre a ideia que esse fragmento de código quer repassar, usando #. Evitem acentos e símbolos especiais, porque os novos acessos ao script, dependendo da codificação que o RStudio esteja utilizando ou o seu sistema operacional, pode desconfigurar todo o arquivo.\r\nBoa escolha:\r\n-----------\r\n# Objeto x\r\nx <- 1:10\r\n# Calculo da media\r\nmean(x)\r\n\r\nMá escolha:\r\n-----------\r\nx <- 1:10\r\nmean(x)\r\nNomes de objetos\r\nLevem em consideração que nomes de objetos é uma forma de acessarmos os objetos no R, e não os nomes das variáveis que serão utilizados em nossos relatórios para escrever sobre um problema real. Portanto, a escolha desses nomes devem ser mais simples, curtos, sem acentos ou símbolos não ASCII, e de preferência apenas letras minúsculas.\r\nBoa escolha:\r\n-----------\r\nnome_curto\r\naux1\r\n\r\nMá escolha:\r\n-----------\r\nnome_muito_grande\r\nNome_Grande\r\nAux1\r\nSempre que possível evite nomes já utilizados no R, para outros fins,\r\nMá escolha:\r\n-----------\r\nT <- \"Nada\"\r\nc <- 5\r\nsd <- 5 + 1\r\nmean <- 3 * 4\r\nPara verificar se determinado nome já existe, use a função exists(), isto é, exists(\"mean\"). Se a função retornar TRUE, significa que já existe esse nome, caso contrário, FALSE.\r\nSintaxe\r\nUm dos erros mais comuns na sintaxe de um código é o espaçamento entre os operadores básicos na linguagem R, exceto para os operadores :, :: e :::. Use sempre um espaço após a vírgula.\r\nBoa escolha:\r\n-----------\r\nx <- 1:10\r\nmedia <- mean(x + 1 / length(x), na.rm = TRUE)\r\nbase::mean(x)\r\n\r\nMá escolha:\r\n-----------\r\nx <- 1 : 10\r\nmedia<-mean(x+1/length(x),na.rm=TRUE)\r\nbase :: mean(x)\r\nPara facilitar pode ser utilizado a função styler::style_text(), isto é,\r\n\r\n\r\ncomando <- \"media<-mean(x+1/length(x),na.rm=TRUE)\"\r\nstyler::style_text(comando)\r\n\r\n\r\nmedia <- mean(x + 1 / length(x), na.rm = TRUE)\r\n\r\nSe necessário use mais de um espaço em uma linha para o alinhamento para <- ou =, bem como um espaço antes do parêntese, a menos que seja uma função,\r\nBoa escolha:\r\n-----------\r\ndata.frame(a = 1,\r\n           b = \"Ben\")\r\n\r\nfunction(){\r\n  x    <- 10\r\n  vari <- x + 1\r\n  return(vari)\r\n}\r\n\r\nfor (i in 1:10) i + 1\r\n\r\nMá escolha:\r\n-----------\r\nfunction () 1\r\nfor(i in 1:10) i + 1\r\nNão insira espaços na condição entre parêntese ou nos itens de indexação, a menos que este último contenha uma vírgula,\r\nBoa escolha:\r\n-----------\r\nif (verbose)\r\nx11 <- mat[1, 1]\r\nx1  <- mat[1, ]\r\n\r\nMá escolha:\r\n-----------\r\nif ( verbose )\r\nx11 <- mat[1,1]\r\nx1  <- mat[1,]\r\nQuando usamos chaves em um comando, devemos evitar abri-lo e fechá-lo na mesma linha. E ainda, quando é função, as linhas de comando inseridas dentro das chaves, inserimos um recuo de dois espaços para entendermos a hierarquização das funções, isto é, função dentro de função. Veja,\r\nBoa escolha:\r\n-----------\r\nfx <- function(x) {\r\n  if (x > 2) {\r\n    print(\"Maior que 2!\")\r\n  } else {\r\n    print(\"Menor que 2!\")\r\n  }\r\n}\r\n\r\nfor (i in 1:10) {\r\n  x <- i + 1\r\n}\r\n\r\nMá escolha:\r\n-----------\r\nfx <- function(x) {\r\nif (x > 2) {\r\nprint(\"Maior que 2!\")\r\n} else {\r\nprint(\"Menor que 2!\")\r\n}\r\n}\r\n\r\nfor (i in 1:10) {x <- i + 1}\r\nObserve também que sempre quando iniciamos a abertura de uma chave, damos um espaço para separar do fechamento do parêntese, sempre quando usamos em uma função. Por fim, sempre use a atribuição com <-, e = para definir os argumentos de uma função,\r\nBoa escolha:\r\n-----------\r\nfx <- function(x = NULL) 10\r\na  <- \"Nome\"\r\n\r\nMá escolha:\r\n-----------\r\nfx = function(x = NULL) 10\r\na = \"Nome\"\r\nPara códigos mais complexos, use o pacote styler e como alternativa o formatR, pois muito mais recursos podem ser utilizados. Para consultas, acesse também Wickham (2015), mais específico, Estilo de código, e ainda Advanced R, 1ed, Style guide, The tidyverse style guide e Google’s R Style Guide.\r\n\r\n Pacotes\r\n\r\n\r\nO pacote em R é um diretório de arquivos necessários para carregar um código de funções, dados, documentações de ajuda, testes, etc. O próprio R em sua instalação, contém 30 pacotes, que dizemos que são as funções mínimas para a utilização da linguagem. Nesse diretório não há apenas códigos em R, mas um pacote fonte (do inglês, source package), contendo os arquivos mencionados acima, ou um arquivo compactado, de extensão .tar.gz do pacote fonte, ou um pacote instalado, resultado da função R CMD INSTALL, que será visto no módulo Programação em R (Nível Avançado). Isso acontece no SO Linux. Para as plataformas Windows e Macintosh, existem também os pacotes binários ou compactados com a extensão .zip ou .tar.gz.\r\nUm pacote, portanto é a unidade básica para o compartilhamento de um código. Atualmente, até 11/03/2021, o número de pacotes disponíveis é 17.295, e isso no CRAN, isto é, na Comprehenive R Archive Network, o repositório oficial de pacotes no R. Qualquer usuário pode publicar um pacote e disponibilizá-lo sob o CRAN. Para isso, uma série de testes iniciais são realizados para verificar se não há problemas. Significa também se um pacote está disponível no CRAN ele funcionará nas três plataformas mais usadas em sistema operacional, SO Linux ou sitemas Unix, SO Windows e SO Macintosh. Há outros repositórios que podem ser disponibilizados os pacotes, como por exemplo, no GitHub. Porém, não há a garantia de que possa estar funcionando corretamento em seu sistema operacional, como os pacotes disponíveis no CRAN.\r\nPara uma instalação mais rápida no CRAN, há espelhos disponíveis no Brasil, do qual o primeiro foi desenvolvido e está funcionando até hoje na UFPR.\r\nContudo, uma coisa deve ficar claro, que erroneamente, alguns usuários chamam pacote de biblioteca. Nas documentações do R, biblioteca é o diretório onde os pacotes são instalados, também chamados de diretório de biblioteca ou diretório de arvores. O outro sentido de biblioteca é o de biblioteca compartilhada (dinâmica ou estática), que armazenam código compilado que se vinculam aos pacotes, por exemplo, no Windows são as DLLs.\r\nA estrutura básica de um pacote é apresentada na Figura 18.\r\n\r\n\r\n\r\nFigure 18: Esqueleto básico de um pacote.\r\n\r\n\r\n\r\nVejamos as ideias básicas desses subdiretórios e arquivos,\r\nDESCRIPTION: Esse é um arquivo de texto, contendo informações básicas como o título do pacote, versão, licença, descrição, nome dos autores, e o mantenedor do pacote, isto é, para quando um pacote estiver com problema ou o CRAN entre em contato, será para este último. Esses as informações obrigatórias que devem ter nesse arquivo.\r\nNAMESPACE: Esse arquivo embora tenha tenha muita semelhança com a linguagem R, o seu conteúdo, se destina a importação e exportação de funções no pacote. Será nesse arquivo, que diremos quais os pacotes que ele depende, isto é, as funções, e quais as funções exportadas, visíveis, que devem ser apresentadas aos usuários.\r\nR/: Esse subdiretório apresenta os scripts com as funções em R. é o cérebro do pacote.\r\nman/: Esse subdiretório apresenta os arquivos de ajuda, com extensão .Rd. Isso significa, que uma vez instalado o pacote no R, o acesso aos manuais de ajuda do referido pacote, estarão disponíveis, graças a esses arquivos.\r\nInstalação de um pacote\r\nA instalação de um pacote via CRAN pode ser feito pela função install.packages(pkgs = \"nome_pacote\"). Por exemplo, vamos tentar instalar o pacote midrangeMCP, da seguinte forma:\r\n\r\n\r\ninstall.packages(\"midrangeMCP\")\r\n\r\n\r\n\r\nPode ser que nesse processo, dependendo de onde o usuário esteja executando essa linha de comando, interface do R ou RStudio, que seja solicitado o espelho por onde deseja fazer a instalação. Isso é apenas um atalho para ter um acesso mais rápido na instalação do pacote. A sugestão é escolher um espelho de seu país de origem.\r\nUma forma simples de se ter detalhes do pacote na internet, tais como, baixar o pacote fonte ou o pacote binário do midrangeMCP, por exemplo, é sempre usar essa url: http://cran.r-project.org/package=midrangeMCP. Para qualquer outro pacote, basta mudar o nome do pacote na url, e assim, estaremos na página do repositório do pacote. O pacote fonte, como falado anteriormente, é compactado com extensão .tar.gz, no caso, midrangeMCP_3.1.1.tar.gz. O pacote binário tem a compactação zipada, midrangeMCP_3.1.1.tar.zip para o Windows e midrangeMCP_3.1.1.tgz para o Macintosh. O acesso aos arquivos do pacote mencionados no esqueleto são disponíveis no pacote fonte.\r\nUma outra forma possível de instalação é baixar o arquivo do pacote fonte para o seu computador e instalá-lo,\r\n\r\n\r\ninstall.packages(pkgs = \"./midrangeMCP.tar.gz\", repos = NULL, type = \"source\")\r\n\r\n\r\n\r\nConsideramos que o arquivo do pacote esteja no diretório de trabalho do usuário. Caso contrário, deve ser informado o local onde pacote se encontra no computador. Para o Window ou Macintosh, é possível instalar também, a partir dos pacotes binários.\r\nMuitos dos desenvolvedores, estão disponibilizando seus projetos de pacotes, principalmente no GitHub, inclusive com manuals de ajuda com maiores detalhes. Pode ser possível instalar esses pacotes por esse repositório. Precisamos inicialmente do pacote devtools, e posteriormente a instalação do pacote. Segue,\r\n\r\n\r\ninstall.packages(\"devtools\")\r\ninstall_github(\"bendeivide/midrangeMCP\")\r\n\r\n\r\n\r\nContudo, devemos dar a preferência pela instalação via CRAN. Por lá, teremos a garantia que os pacotes estão estáveis para a utilização nas referidas plataformas mencionadas acima.\r\nAlguns pacotes, por falta de manutenção, seja por atualizações do R ou por qualquer outro motivo, podem se tornar incompatíveis para utilização sobre alguns dos três sistemas operacionais básicos (SO Windows, Unix e SO Mac) exigidos pelo R. Dessa forma, se as correções não forem feitas, estes pacotes e tornam órfãos, ou seja, desativados sob o CRAN. O primeiros pacotes sob o CRAN, por exemplo, não tinham o arquivo NAMESPACE, que hoje é exigido. Qualquer tentativa de instalação desses pacotes nessas situações, não serão bem sucedidas. Dessa forma, fizemos uma vídeo-aula, como tentativa de recuperar os pacotes desativados. Porém, deixemos claro que nem sempre é possível a instalação de pacotes desativados.\r\n\r\n\r\nObjetivos de um pacote\r\nA ideia de um pacote para um usuário R deve representar como uma ferramenta para otimizar suas atividades do dia-a-dia na utilização da linguagem. Suponha que o usuário seja um cientista de dados, e todos os dias ele carrega uma sequência de scripts, via source, para disponibilizar suas funções no ambiente global. Isso acaba gerando processos repetitivos de trabalho desnecessários.\r\nAo invés, o cientista de dados pode desenvolver um pacote, e esse pacote conter todas as funções necessárias para as suas análises. De uma vez, o pacote instalado e anexado no caminho de busca, todas as suas funções estarão disponíveis para utilização. Portanto, o entendimento disso, permite uma maior eficiência de trabalho.\r\nOutro ponto é que a experiência contida em um pacote pode ser propagada mais facilmente para outros usuários, mostrando que o conhecimento é uma liberdade necessária. Tanto pelo CRAN, quanto por outras plataformas, o pacote pode ser disponibilizado.\r\nUtilizar as funções de um pacote\r\nUma vez instalado o pacote, precisamos carregar e anexá-lo, para que possamos utilizar os recursos disponíveis no pacote, como funções, dados, etc. Isso significa, disponibilizar na memória e inseri-lo no caminho de busca, respectivamente. Para fazer essas duas ações ao mesmo tempo, use a função library() ou require(). A primeira função se for utilizada sem argumento algum, retorna todos os pacotes instalados na bibioteca de pacotes do R. Vejamos o exemplo do pacote midrangeMCP,\r\n\r\n\r\n# Carregando e anexando o pacote midrangeMCP\r\nlibrary(midrangeMCP)\r\n\r\n# Usando a função MRtest() desse pacote\r\n#-----\r\n# Dados simulados de um experimento em DIC (Delineamento Inteiramente Casualizado)\r\n\r\n# Variavel resposta\r\nrv <- c(100.08, 105.66, 97.64, 100.11, 102.60, 121.29, 100.80,\r\n        99.11, 104.43, 122.18, 119.49, 124.37, 123.19, 134.16,\r\n        125.67, 128.88, 148.07, 134.27, 151.53, 127.31)\r\n\r\n# Tratamento\r\ntreat <- factor(rep(LETTERS[1:5], each = 4))\r\n\r\n# Anava\r\nres     <- anova(aov(rv~treat))\r\nDFerror <- res$Df[2]\r\nMSerror <- res$`Mean Sq`[2]\r\n\r\n# Aplicando testes\r\nresults <- midrangeMCP::MRtest(y = rv,\r\n                  trt = treat,\r\n                  dferror = DFerror,\r\n                  mserror = MSerror,\r\n                  alpha = 0.05,\r\n                  main = \"PCMs\",\r\n                  MCP = c(\"all\"))\r\n\r\n\r\nMCP's based on distributions of the studentized midrange and range\r\n\r\nStudy:  PCMs \r\n\r\nSummary:\r\n   Means   std r    Min    Max\r\nA 100.87  3.40 4  97.64 105.66\r\nB 105.95 10.33 4  99.11 121.29\r\nC 117.62  9.02 4 104.43 124.37\r\nD 127.97  4.74 4 123.19 134.16\r\nE 140.30 11.42 4 127.31 151.53\r\n\r\n Mean Grouping Midrange Test\r\n\r\nStatistics: \r\n  Exp.Mean      CV  MSerror Df n Stud.Midrange Ext.DMS  Int.DMS\r\n   118.542 7.08182 70.47488 15 5      1.089968 5.90246 4.575105\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g2\r\nC 117.62     g3\r\nB 105.95     g4\r\nA 100.87     g4\r\n\r\nMean Grouping Range Test\r\n\r\nStatistics: \r\n  Exp.Mean      CV  MSerror Df n Stud.Range      DMS\r\n   118.542 7.08182 70.47488 15 5   4.366985 18.33027\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g2\r\nC 117.62     g2\r\nB 105.95     g3\r\nA 100.87     g3\r\n\r\nSNK Midrange Test\r\n\r\nStatistics: \r\n      Exp.Mean     CV MSerror Df n Stud.Midrange    DMS\r\ncomp1  118.542 7.0818 70.4749 15 5        1.0900 5.9025\r\ncomp2  118.542 7.0818 70.4749 15 4        1.1646 6.2159\r\ncomp3  118.542 7.0818 70.4749 15 3        1.2828 6.7121\r\ncomp4  118.542 7.0818 70.4749 15 2        1.5072 7.6536\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g1\r\nC 117.62   g1g2\r\nB 105.95   g1g2\r\nA 100.87     g2\r\n\r\nTukey Midrange Test\r\n\r\nStatistics: \r\n  Exp.Mean      CV  MSerror Df n Stud.Midrange Ext.DMS  Int.DMS\r\n   118.542 7.08182 70.47488 15 5      1.089968 5.90246 4.575105\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g2\r\nC 117.62     g3\r\nB 105.95     g4\r\nA 100.87     g4\r\n\r\n\r\nMCP's based on distributions of the studentized midrange and range\r\n\r\nStudy:  PCMs \r\n\r\nSummary:\r\n   Means   std r    Min    Max\r\nA 100.87  3.40 4  97.64 105.66\r\nB 105.95 10.33 4  99.11 121.29\r\nC 117.62  9.02 4 104.43 124.37\r\nD 127.97  4.74 4 123.19 134.16\r\nE 140.30 11.42 4 127.31 151.53\r\n\r\n Mean Grouping Midrange Test\r\n\r\nStatistics: \r\n  Exp.Mean      CV  MSerror Df n Stud.Midrange Ext.DMS  Int.DMS\r\n   118.542 7.08182 70.47488 15 5      1.089968 5.90246 4.575105\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g2\r\nC 117.62     g3\r\nB 105.95     g4\r\nA 100.87     g4\r\n\r\nMean Grouping Range Test\r\n\r\nStatistics: \r\n  Exp.Mean      CV  MSerror Df n Stud.Range      DMS\r\n   118.542 7.08182 70.47488 15 5   4.366985 18.33027\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g2\r\nC 117.62     g2\r\nB 105.95     g3\r\nA 100.87     g3\r\n\r\nSNK Midrange Test\r\n\r\nStatistics: \r\n      Exp.Mean     CV MSerror Df n Stud.Midrange    DMS\r\ncomp1  118.542 7.0818 70.4749 15 5        1.0900 5.9025\r\ncomp2  118.542 7.0818 70.4749 15 4        1.1646 6.2159\r\ncomp3  118.542 7.0818 70.4749 15 3        1.2828 6.7121\r\ncomp4  118.542 7.0818 70.4749 15 2        1.5072 7.6536\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g1\r\nC 117.62   g1g2\r\nB 105.95   g1g2\r\nA 100.87     g2\r\n\r\nTukey Midrange Test\r\n\r\nStatistics: \r\n  Exp.Mean      CV  MSerror Df n Stud.Midrange Ext.DMS  Int.DMS\r\n   118.542 7.08182 70.47488 15 5      1.089968 5.90246 4.575105\r\n\r\nGroups: \r\n   Means Groups\r\nE 140.30     g1\r\nD 127.97     g2\r\nC 117.62     g3\r\nB 105.95     g4\r\nA 100.87     g4\r\n\r\n\r\n\r\nmidrangeMCP::MRbarplot(results)\r\n\r\n\r\n\r\n\r\nCarregando e anexando um pacote\r\n\r\n\r\nAnteriormente, falamos que usamos a função library() ou require() para carregar e anexar um pacote para utilizar suas funções, após a instalação. Carregar um pacote significa disponibilizar na memória ativa. Para acessar uma função de um pacote após ter sido carregado, usamos o operador ::, isto é, nome_pacote::nome_função. Isto significa, que será chamado a função necessária sem anexar o pacote no caminho de busca. Estudaremos a seguir um pouco mais sobre caminho de busca. Para esse momento, entenda que é um caminho hierarquizado de ambientes, isto é, objetos que armazenam, em forma de lista, nomes associados a objetos. A função para ver o caminho de busca é search(). Em nosso caso, temos:\r\n\r\n\r\n\r\n\r\n\r\n# Caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"        \"package:magrittr\"  \"package:leaflet\"  \r\n [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\r\n [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \r\n[10] \"Autoloads\"         \"package:base\"     \r\n\r\n# Carregando e chamando uma função de um pacote\r\nmidrangeMCP::MRwrite(results, extension = \"latex\")\r\n\r\n\r\nTable in latex of results of the MGM test\r\n\r\n% latex table generated in R 4.1.0 by xtable 1.8-4 package\r\n% Fri Oct 15 21:11:42 2021\r\n\\begin{table}[ht]\r\n\\centering\r\n\\begin{tabular}{lrl}\r\n  \\hline\r\ntrt & Means & Groups \\\\ \r\n  \\hline\r\nE & 140.30 & g1 \\\\ \r\n  D & 127.97 & g2 \\\\ \r\n  C & 117.62 & g3 \\\\ \r\n  B & 105.95 & g4 \\\\ \r\n  A & 100.87 & g4 \\\\ \r\n   \\hline\r\n\\end{tabular}\r\n\\end{table}\r\n\r\n\r\nTable in latex of results of the MGR test\r\n\r\n% latex table generated in R 4.1.0 by xtable 1.8-4 package\r\n% Fri Oct 15 21:11:42 2021\r\n\\begin{table}[ht]\r\n\\centering\r\n\\begin{tabular}{lrl}\r\n  \\hline\r\ntrt & Means & Groups \\\\ \r\n  \\hline\r\nE & 140.30 & g1 \\\\ \r\n  D & 127.97 & g2 \\\\ \r\n  C & 117.62 & g2 \\\\ \r\n  B & 105.95 & g3 \\\\ \r\n  A & 100.87 & g3 \\\\ \r\n   \\hline\r\n\\end{tabular}\r\n\\end{table}\r\n\r\n\r\nTable in latex of results of the SNKM test\r\n\r\n% latex table generated in R 4.1.0 by xtable 1.8-4 package\r\n% Fri Oct 15 21:11:42 2021\r\n\\begin{table}[ht]\r\n\\centering\r\n\\begin{tabular}{lrl}\r\n  \\hline\r\ntrt & Means & Groups \\\\ \r\n  \\hline\r\nE & 140.30 & g1 \\\\ \r\n  D & 127.97 & g1 \\\\ \r\n  C & 117.62 & g1g2 \\\\ \r\n  B & 105.95 & g1g2 \\\\ \r\n  A & 100.87 & g2 \\\\ \r\n   \\hline\r\n\\end{tabular}\r\n\\end{table}\r\n\r\n\r\nTable in latex of results of the TM test\r\n\r\n% latex table generated in R 4.1.0 by xtable 1.8-4 package\r\n% Fri Oct 15 21:11:42 2021\r\n\\begin{table}[ht]\r\n\\centering\r\n\\begin{tabular}{lrl}\r\n  \\hline\r\ntrt & Means & Groups \\\\ \r\n  \\hline\r\nE & 140.30 & g1 \\\\ \r\n  D & 127.97 & g2 \\\\ \r\n  C & 117.62 & g3 \\\\ \r\n  B & 105.95 & g4 \\\\ \r\n  A & 100.87 & g4 \\\\ \r\n   \\hline\r\n\\end{tabular}\r\n\\end{table}\r\n\r\n\r\nTable in latex of results of descriptive statistics\r\n\r\n% latex table generated in R 4.1.0 by xtable 1.8-4 package\r\n% Fri Oct 15 21:11:42 2021\r\n\\begin{table}[ht]\r\n\\centering\r\n\\begin{tabular}{lrrrrr}\r\n  \\hline\r\ntrt & Means & std & r & Min & Max \\\\ \r\n  \\hline\r\nA & 100.87 & 3.40 & 4.00 & 97.64 & 105.66 \\\\ \r\n  B & 105.95 & 10.33 & 4.00 & 99.11 & 121.29 \\\\ \r\n  C & 117.62 & 9.02 & 4.00 & 104.43 & 124.37 \\\\ \r\n  D & 127.97 & 4.74 & 4.00 & 123.19 & 134.16 \\\\ \r\n  E & 140.30 & 11.42 & 4.00 & 127.31 & 151.53 \\\\ \r\n   \\hline\r\n\\end{tabular}\r\n\\end{table}\r\n\r\nSee yours tables in Console\r\n Format: latex\r\n\r\n# Verificando novamente o caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"        \"package:magrittr\"  \"package:leaflet\"  \r\n [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\r\n [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \r\n[10] \"Autoloads\"         \"package:base\"     \r\n\r\nCom as linhas de comando apresentadas anteriormente, percebemos ao executar a função MRwrite() do pacote midrangeMCP, usando :: que o caminho de busca não foi alterado. Isso significa que o pacote não foi anexado, apenas carregado, ou seja, se o usuário desejar usar alguma função do pacote midrangeMCP digitando apenas o nome no console, não será possível, porque o pacote não está anexado ao caminho de busca.\r\nVejamos uma outra situação,\r\n\r\n\r\n\r\n\r\n\r\n# Caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"        \"package:magrittr\"  \"package:leaflet\"  \r\n [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\r\n [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \r\n[10] \"Autoloads\"         \"package:base\"     \r\n\r\n# Carregando e anexando um pacote\r\nlibrary(midrangeMCP)\r\n\r\n# Verificando novamente o caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"package:midrangeMCP\" \"package:magrittr\"   \r\n [4] \"package:leaflet\"     \"package:stats\"       \"package:graphics\"   \r\n [7] \"package:grDevices\"   \"package:utils\"       \"package:datasets\"   \r\n[10] \"package:methods\"     \"Autoloads\"           \"package:base\"       \r\n\r\n# Chamando uma funcao do pacote\r\n# guimidrangeMCP()\r\n\r\n\r\n\r\nCom o uso da função library(), percebemos que o caminho de busca foi alterado, porque agora temos o ambiente de pacote package:midrangeMCP. Isso significa que agora poderemos acessar os objetos desse pacote apenas digitando o nome associado a eles. Por fim, a última linha foi comentada, porque é uma interface gráfica ao usuário para o pacote, o que chamamos de GUI (do inglês, Graphical User Interface), mas que pode ser visualizado na Figura 19.\r\n\r\n\r\n\r\nFigure 19: Interface para o pacote midrangeMCP.\r\n\r\n\r\n\r\nNAMESPACE de um pacote\r\n\r\n\r\nNo início da seção sobre pacotes, falamos sobre o esqueleto de um pacote, isto é, os componentes básicos de um pacote. Um dos arquivos é o NAMESPACE. Esse arquivo é respondsável pela exportação e importação de funções. As funções exportadas de um pacote, por meio desse arquivo, são aquelas visíveis após a anexação do pacote ao caminho de busca, ou por meio do operador ::. As funções importadas são aquelas utilizadas de outros pacotes.\r\nAs funções ditas internas do pacote, são aquelas não mencionadas no NAMESPACE. Em muitas situações, precisamos de funções internas necessárias para a finalidade do pacote, que muitas vezes não é objetivo final para disponibilidade dos usuários, mas códigos intermediários para a boa funcionabilidade do pacote. Dessa forma, uma boa escolha para que não haja conflitos em nomes associados a objetos no ambiente de trabalho, é a decisão de não exportá-los.\r\nPorém, quando se cria um pacote, por exemplo, pelo RStudio, o padrão no NAMESPACE é o comando:\r\nexportPattern(\"^[^\\\\.]\")\r\nque significa que todas as funções no pacote serão exportadas que não iniciam por um ponto (“.”). Como toda função em um pacote precisa de um arquivo de ajuda (.Rd), todas as funções deverão ter esses tipos arquivos inseridos no subdiretório man/.\r\nOs primeiros pacotes submetidos ao CRAN na primeiras versões do R, não tinha o arquivo NAMESPACE. Por isso que quando tentamos instalar pacotes órfãs antigos, um dos erros é a falta desse arquivo.\r\nMais detalhes sobre o desenvolvimento de pacotes será abordado no módulo Programação em R (Nível Avançado).\r\nUsando os operadores :: e :::\r\n\r\n\r\nComo falamos anteriormente, para chamarmos uma função sem a necessidade de anexar o pacote, usamos o operador ::. Comentamos também, que algumas funções não eram exportadas pelo NAMESPACE de um pacote. Contudo, se desejarmos visualizar ou executá-las, poderemos utilizar o operador :::. Vejamos um exemplo,\r\n\r\n\r\n# Instale o pacote SMR\r\n# install.packages(SMR) # Descomente a linha de comando para instalar\r\n# Carregando e chamando funcoes exportadas do pacote SMR\r\nSMR::pSMR(q = 2, size = 10, df = 3)\r\n\r\n\r\n[1] 0.9905216\r\n\r\n# Carregando e chamando funcoes nao exportadas ao pacote\r\nSMR:::GaussLegendre(size = 4)\r\n\r\n\r\n$nodes\r\n[1] -0.8611363 -0.3399810  0.3399810  0.8611363\r\n\r\n$weights\r\n[1] 0.3478548 0.6521452 0.6521452 0.3478548\r\n\r\nAs funções internas dos pacotes devem ser utilizadas com muita cautela, uma vez que são funções que podem passar por atualizações, mudanças. Isso porque, como não são funções exportadas, alguns pacotes podem passar por atualizações, e desse modo, estas funções também podem ser atualizadas ou até mesmo alteradas.\r\nOutro ponto interessante é que não se recomenda a utilização de importação de funções internas de outros pacotes no desenvolvimento de pacotes, uma vez que são funções que podem passar por mudanças drásticas, e portanto, gerar problemas nas rotinas. Se uma função em um pacote não foi exportada, é porque o desenvolvedor tem um bom motivo para tal situação. As funções exportadas são de fato a essência do objetivo de um pacote, e por isso que elas são exportadas.\r\n\r\n Ambientes e Caminho de busca\r\nNa seção sobre funções, discutimos dois pontos interessantes sobre objetos, que é a atribuição e o escopo. E esses dois pontos estão intimamente relacionados ao objeto ambiente, de tipo \"environment\". O ambiente é um objeto que armazena, em forma de lista, as ligações dos nomes associados aos objetos. Porém, existem diferenças entre o objeto lista do objeto ambiente, com quatro exceções (Wickham (2019)):\r\nCada nome deve ser único;\r\nOs nomes em um ambiente não são ordenados;\r\nUm ambiente tem um pai ou também chamado de ambiente superior;\r\nAmbientes não são copiados quando modificados.\r\nMuitas dessas definições são complexas para esse momento. E uma profundidade sobre o assunto, será abordada no módulo Programação em R (Nível Intermediário). Contudo, introduziremos algumas características importantes para os objetos do tipo environment.\r\nO ambiente de trabalho do R é conhecido como ambiente global, pois é onde todo o processo de interação da linguagem ocorre. Existe um nome específico associado a esse objeto, que é .GlobalEnv, ou também pode ser acessado pela função globalenv(). Para sabermos quais os nomes que existem nesse ambiente, usamos a função ls(), isto é,\r\n\r\n\r\n\r\n\r\n\r\n# Nomes no ambiente global\r\nls()\r\n\r\n\r\ncharacter(0)\r\n\r\nQuando o resultado da função é character(0), significa que não existem nomes criados no ambiente global. O ambiente corrente de trabalho é informado pela função environment(), isto é,\r\n\r\n\r\n# Comparando os ambientes\r\nidentical(environment(), .GlobalEnv)\r\n\r\n\r\n[1] TRUE\r\n\r\n# Forma errada de comparar ambientes (Erro...)\r\nenvironment() == .GlobalEnv\r\n\r\n\r\nError in environment() == .GlobalEnv: comparação (1) é possível apenas para tipos lista ou atômicos\r\n\r\nA segunda forma é equivocada, porque o operador booleano, ==, é aplicado apenas a vetores, e o objeto ambiente não é um vetor. Acrescentamos ainda que não podemos utilizar o sistema de indexação, isto é,\r\n\r\n\r\n# Criando objetos no ambiente global\r\nb <- 2; a <- \"Ben\"; x <- TRUE\r\n# Verificando os nomes no ambiente global\r\nls()\r\n\r\n\r\n[1] \"a\" \"b\" \"x\"\r\n\r\n# Acessando o objeto \"a\"\r\n.GlobalEnv$a\r\n\r\n\r\n[1] \"Ben\"\r\n\r\n.GlobalEnv[[\"a\"]]\r\n\r\n\r\n[1] \"Ben\"\r\n\r\n# Acessando o primeiro nome (Erro...)\r\n.GlobalEnv[[1]]\r\n\r\n\r\nError in .GlobalEnv[[1]]: argumentos errados para obtenção de subconjuntos de um ambiente\r\n\r\n\r\n\r\n\r\nA última linha de comando retorna um erro, porque os nomes em ambientes não são ordenados, ao invés, devemos chamar os resultados por meio de $ ou [[<nome_obj>]].\r\nPoderemos criar um ambiente pela função new.env(), e inserir ligações dentro dele, como apresentados a seguir.\r\n\r\n\r\n\r\n\r\n\r\n# Criando objetos no ambiente global\r\nb <- 2; a <- \"Ben\"; x <- TRUE\r\n# Verificando os nomes no ambiente global\r\nls()\r\n\r\n\r\n[1] \"a\" \"b\" \"x\"\r\n\r\n# Criando um objeto ambiente no ambiente global\r\namb1 <- new.env()\r\n# Inserindo nomes nesse no ambiente \"amb1\"\r\namb1$d <- 3; amb1$e <- \"FALSE\"\r\n# Verificando nomes no ambiente global\r\nls()\r\n\r\n\r\n[1] \"a\"    \"amb1\" \"b\"    \"x\"   \r\n\r\n# Verificando nomes no ambiente \"amb1\"\r\nls(envir = amb1)\r\n\r\n\r\n[1] \"d\" \"e\"\r\n\r\n\r\n\r\n\r\nTodo ambiente tem um ambiente pai ou ambiente superior. Quando um nome não é encontrado no ambiente corrente, o R procurará no ambiente pai. Para saber, use parent.env(), isto é,\r\n\r\n\r\nparent.env(amb1)\r\n\r\n\r\n<environment: R_GlobalEnv>\r\n\r\nO único ambiente que não tem pai é o ambiente vazio, objeto emptyenv(), que pode ser observado pela linha de comando:\r\n\r\n\r\nparent.env(emptyenv())\r\n\r\n\r\nError in parent.env(emptyenv()): o ambiente vazio não tem pai\r\n\r\nA superatribuição <<-\r\nA atribuição (<-) é uma função que associa um nome a um objeto no ambiente corrente. Quando usamos o R, quase sempre esse ambiente é o ambiente global. A superatribuição (<<-) cria um nome e o associa a um objeto no ambiente pai do ambiente de onde essa associação está sendo criada. Vejamos,\r\n\r\n\r\n# Criando o objeto x e o imprimindo\r\nx <- 0; x\r\n\r\n\r\n[1] 0\r\n\r\n# Criando uma funcao com a superatribuicao\r\nf1 <-  function() {\r\n  # Obj2\r\n  x <- 1\r\n  # Modificando x do ambiente global\r\n  x <<- 2\r\n  # Imprimindo o ambiente de execucao\r\n  env <- environment()\r\n  # Imprimindo o Obj2\r\n  res <- list(x = x, \"Ambiente de execução\" = env, \"Ambiente Pai\" = parent.env(env))\r\n  # Retornando a lista\r\n  return(res)\r\n}\r\n# Imprimindo f1\r\nf1()\r\n\r\n\r\n$x\r\n[1] 1\r\n\r\n$`Ambiente de execução`\r\n<environment: 0x000000002abf05a8>\r\n\r\n$`Ambiente Pai`\r\n<environment: R_GlobalEnv>\r\n\r\n# Imprimindo x\r\nx\r\n\r\n\r\n[1] 2\r\n\r\n# Imprimindo o ambiente envolvente de f1\r\nenvironment(f1)\r\n\r\n\r\n<environment: R_GlobalEnv>\r\n\r\n# Imprimindo os nomes do ambiente global\r\nls()\r\n\r\n\r\n[1] \"a\"       \"amb1\"    \"b\"       \"cran\"    \"f1\"      \"github\" \r\n[7] \"rlink\"   \"rstudio\" \"x\"      \r\n\r\nEsse caso é interessante porque vemos dois nomes associados a objetos em ambientes diferentes. Alguns ambientes são criados pela função function(), são os chamados ambientes funcionais. Um deles é o ambiente envolvente, já comentado na seção sobre funções. O ambiente envolvente da função f1 é o ambiente global. Já no corpo da função f1, um outro ambiente surge quando a função é chamada, é o ambiente de execução. Toda vez que a função é chamada, cria-se um novo ambiente de execução. Observemos os identificadores, em Ambiente de execução, quando executamos a função mais de uma vez,\r\n\r\n\r\nf1()$`Ambiente de execução`\r\n\r\n\r\n<environment: 0x0000000028865e40>\r\n\r\nf1()$`Ambiente de execução`\r\n\r\n\r\n<environment: 0x0000000009308820>\r\n\r\nf1()$`Ambiente de execução`\r\n\r\n\r\n<environment: 0x000000000927e6a0>\r\n\r\nO ambiente pai do ambiente de execução, é o ambiente envolvente de f1, que nesse caso é o ambiente global. Assim, observe que o ocorre quando executamos o comando de superatribuição. O nome x no ambiente global passou a está associado ao valor 2, porque foi alterado por <<-, mas o nome x continuou associado ao valor 1, porque a função f1() retornou o valor 1. Isso mostra que a superatribuição não cria um objeto no ambiente atual, mas em um ambiente pai se não existe ou altera o nome existente. Vejamos o complemento dessa afirmação no próximo exemplo.\r\n\r\n\r\n\r\n\r\n\r\n# Verificando os nomes no ambiente global\r\nls()\r\n\r\n\r\ncharacter(0)\r\n\r\n# Criando uma funcao\r\nf2 <-  function() {\r\n  x <<- 2\r\n}\r\n# Executando f2\r\nf2()\r\n# Verificando novamente os nomes no ambiente global\r\nls()\r\n\r\n\r\n[1] \"f2\" \"x\" \r\n\r\n# Verificando o valor de x\r\nx\r\n\r\n\r\n[1] 2\r\n\r\n\r\n\r\n\r\nCom a superatribuição executada dentro de f2() e como no ambiente pai não eistia o nome x, este foi criado e associado ao valor 2. Um próximo exemplo, consideramos um ambiente envolvente que não seja o ambiente global. Vejamos,\r\n\r\n\r\n# Funcao contador\r\ncontador <- function() {\r\n  i <- 0\r\n  env1 <- environment()\r\n  aux <- function() {\r\n    # do something useful, then ...\r\n    i <<- i + 1\r\n    env2 <- environment()\r\n    res2 <- list(i = i, `AmbExec_aux` = env2, `AmbExec_contador` = env1)\r\n    return(res2)\r\n  }\r\n}\r\n# Chamada de funcao\r\ncontador1 <- contador()\r\ncontador1()\r\n\r\n\r\n$i\r\n[1] 1\r\n\r\n$AmbExec_aux\r\n<environment: 0x0000000008e955d8>\r\n\r\n$AmbExec_contador\r\n<environment: 0x0000000008f9d728>\r\n\r\ncontador1()\r\n\r\n\r\n$i\r\n[1] 2\r\n\r\n$AmbExec_aux\r\n<environment: 0x00000000087fbe20>\r\n\r\n$AmbExec_contador\r\n<environment: 0x0000000008f9d728>\r\n\r\ncontador1()\r\n\r\n\r\n$i\r\n[1] 3\r\n\r\n$AmbExec_aux\r\n<environment: 0x000000000863dea8>\r\n\r\n$AmbExec_contador\r\n<environment: 0x0000000008f9d728>\r\n\r\n# Chamada de funcao\r\ncontador2 <- contador()\r\ncontador2()\r\n\r\n\r\n$i\r\n[1] 1\r\n\r\n$AmbExec_aux\r\n<environment: 0x000000002afa9fc0>\r\n\r\n$AmbExec_contador\r\n<environment: 0x00000000083c3e60>\r\n\r\nQuando uma função function() é criada dentro de outra função function() o ambiente de execução da função superior, contador(), é o ambiente envolvente da função interna, aux(). Dessa forma, o ambiente de execução de contador() não será mais efêmero, isto é, não será apagado após a execução, como pode ser visto em contador1(). Observamos que executamos contador1() três vezes. O nome i foi atualizado, devido a superatribuição, a cada chamada da mesma função. Ao passo que, quando realizamos uma nova chamada de contador(), por meio de contador2(), o resultado de i retora o valor 1, porque um novo ambiente de execução para contador() foi criado, como pode ser observado.\r\nOs demais ambiente funcionais e exemplos, serão descritos no módulo Programação em R (Nível Intermediário).\r\nCaminho de busca\r\nPor fim, uma última forma do R encontrar os nomes é pelo caminho de busca, que além dos ambientes criados e o ambiente global, existem os ambientes de pacotes. Toda vez que um pacote é anexado ao caminho de busca, o ambiente de pacote anexado será sempre o pai do ambiente global. Vejamos,\r\n\r\n\r\n\r\n\r\n\r\n# Caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"        \"package:magrittr\"  \"package:leaflet\"  \r\n [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\r\n [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \r\n[10] \"Autoloads\"         \"package:base\"     \r\n\r\n# Anexando o pacote SMR\r\nlibrary(SMR)\r\n# Verificando o caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"        \"package:SMR\"       \"package:magrittr\" \r\n [4] \"package:leaflet\"   \"package:stats\"     \"package:graphics\" \r\n [7] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \r\n[10] \"package:methods\"   \"Autoloads\"         \"package:base\"     \r\n\r\n# Carregando o pacote midrangeMCP\r\nlibrary(midrangeMCP)\r\n# Verificando o caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"package:midrangeMCP\" \"package:SMR\"        \r\n [4] \"package:magrittr\"    \"package:leaflet\"     \"package:stats\"      \r\n [7] \"package:graphics\"    \"package:grDevices\"   \"package:utils\"      \r\n[10] \"package:datasets\"    \"package:methods\"     \"Autoloads\"          \r\n[13] \"package:base\"       \r\n\r\nA lista dos ambientes no caminho de busca segue a ordem hierárquica dos ambientes, de modo que o ambiente global será sempre o ambiente de trabalho, isto é, o ambiente corrente. Não foi apresentado nessa lista, o ambiente vazio, emptyenv(). Mas, poderemos utilizar o pacote rlang para isso.\r\n\r\n\r\n# Criando um ambiente\r\namb2 <- new.env()\r\n# Verificando seus parentais\r\nrlang::env_parents(env = amb2, last = emptyenv())\r\n\r\n\r\n [[1]] $ <env: global>\r\n [[2]] $ <env: package:midrangeMCP>\r\n [[3]] $ <env: package:SMR>\r\n [[4]] $ <env: package:magrittr>\r\n [[5]] $ <env: package:leaflet>\r\n [[6]] $ <env: package:stats>\r\n [[7]] $ <env: package:graphics>\r\n [[8]] $ <env: package:grDevices>\r\n [[9]] $ <env: package:utils>\r\n[[10]] $ <env: package:datasets>\r\n[[11]] $ <env: package:methods>\r\n[[12]] $ <env: Autoloads>\r\n[[13]] $ <env: package:base>\r\n[[14]] $ <env: empty>\r\n\r\nDessa forma, é caminho de busca que o R procurará pelos nomes. Isso significa, que se o ambiente envolvente de uma função, por exemplo, for o ambiente vazio, o R procurará pelas funções básicas no pacote base e não será encontrado, pois nesse ambiente não há nomes e nem ambientes parentais. Por isso, que o R depende do escopo léxico para tudo. Vejamos,\r\n\r\n\r\n# Criando uma funcao\r\nf3 <- function() x + 1\r\n\r\n# Modificando o ambiente envolvente de f3\r\nenvironment(f3) <- emptyenv()\r\n\r\n# Dependencias externas da funcao f3\r\ncodetools::findGlobals(f3)\r\n\r\n\r\n[1] \"+\" \"x\"\r\n\r\n# Chamando a funcao f3\r\nf3()\r\n\r\n\r\nError in x + 1: não foi possível encontrar a função \"+\"\r\n\r\nIsso não ocorre quando definimos o ambiente envolvente de f3() como sendo o ambiente global, porque quando a função buscar pelo operador de soma neste ambiente e não encontrar, f3() seguirá até o ambiente package:base, para encontrar o operador “+.”\r\nPor isso, que usar a função attach() para anexar objetos do tipo quadro de dados (data frames), por exemplo, pode se tornar um problema em um código, quando temos nomes iguais para objetos diferentes. Para isso, apresentamos o código a seguir.\r\n\r\n\r\n# objeto quadro de dados\r\ndados <- data.frame(sd = 1:3, var = (1:3)^2)\r\n# Caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"package:midrangeMCP\" \"package:SMR\"        \r\n [4] \"package:magrittr\"    \"package:leaflet\"     \"package:stats\"      \r\n [7] \"package:graphics\"    \"package:grDevices\"   \"package:utils\"      \r\n[10] \"package:datasets\"    \"package:methods\"     \"Autoloads\"          \r\n[13] \"package:base\"       \r\n\r\n# anexando \"dados\" ao caminho de busca\r\nattach(dados)\r\n# Verificando novamente o caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"dados\"               \"package:midrangeMCP\"\r\n [4] \"package:SMR\"         \"package:magrittr\"    \"package:leaflet\"    \r\n [7] \"package:stats\"       \"package:graphics\"    \"package:grDevices\"  \r\n[10] \"package:utils\"       \"package:datasets\"    \"package:methods\"    \r\n[13] \"Autoloads\"           \"package:base\"       \r\n\r\n# Imprimindo sd\r\nsd\r\n\r\n\r\n[1] 1 2 3\r\n\r\n# Desanexando \"dados\"\r\ndetach(dados)\r\n# Imprimindo sd\r\nsd\r\n\r\n\r\nfunction (x, na.rm = FALSE) \r\nsqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \r\n    na.rm = na.rm))\r\n<bytecode: 0x000000002ad2b308>\r\n<environment: namespace:stats>\r\n\r\nQuando criamos o objeto dados, uma de suas colunas estava nomeada por sd, que também é o nome de uma função do pacote stats, que representa a variância. Porém, quando anexamos o objeto dados no caminho de busca, um novo ambiente é criado, como pai do ambiente global e com mesmo nome do objeto, e os elementos do objeto dados são copiados para esse ambiente. Assim, o nome sd foi procurado e não encontrado, seguindo a busca para o próximo ambiente que foi dados, e daí foi encontrado. Percebemos que também existe esse nome no ambiente do pacote stats, que é do tipo função. Entretanto, como o primeiro objeto encontrado associado a esse nome estava no ambiente dados, ele é retornado. Nesses casos, se usarmos a superatribuição, a alteração ocorrerá apenas na cópia dos elementos no ambiente anexado, e não nos elementos do objeto original. Caso haja a atribuição, o nome será criado no ambiente global.\r\nIsso pode acabar se tornando um problema se muitos objetos forem anexados. Por isso, é preferível o uso da indexação ou $ para acessar os elementos de uma lista ou quadro de dados, evitando assim, conflitos na procura de nomes.\r\nDesse mesmo modo, poderíamos pensar que esses mesmo conflitos poderiam surgir dentro de um pacote. Porém, graças ao NAMESPACE, isso não ocorre, sendo um dos assuntos abordados nos próximos módulos.\r\n\r\n\r\n\r\n\r\n Interfaces com outras linguagens\r\n\r\n\r\nComo afirmado no terceiro princício,\r\n\r\n\r\nPrincípio da Interface: Interfaces para outros programas são parte do R,\r\n\r\nna base do R temos integrações prontas para implementar códigos em C e FORTRAN, como também outras linguagens. Por exemplo, na base do R existe um pacote chamado tcltk que integra a linguagem Tcl/Tk para o R. Esse pacote nos permite desenvolver interfaces gráficas para os nossos códigos.\r\nDiversos outros pacotes, disponibilizados sob o CRAN realizaram diversas outras linguagens, que elencamos alguns,\r\nPacote\r\nLinguagem integrada\r\ntcltk\r\nLinguagem Tcl/Tk\r\nRGtk2\r\nLinguagem Gtk+\r\nrJava\r\nLinguagem Java\r\nrmarkdown\r\nLinguagens HTML, JavaScript, CSS, Markdown, \\(\\LaTeX\\)\r\nreticulate\r\nLinguagem Python\r\nJuliaCall, XRJulia\r\nLinguagem Julia\r\nRcpp\r\nLinguagem C++\r\ngecoder\r\nLinguagem Ruby\r\nExiste um aplicativo da web bem interessante que integra as linguagem Julia, Python e R, chamado Jupyter. Muitas outras interfaces são integradas ao R. Ao longo do que formos pesquisando sobre mais pacotes, vamos atualizando a tabela.\r\nComo motivação para esse momento, iremos realizar uma aplicação com as linguagens Python, C++ e Tcl/tk, para verificarmos que essas integrações são fáceis de serem realizadas. Claro, em algumas outras situações, como a integração do código C para R usando as funções .C() ou .Call() exigem um pouco mais de conhecimento. Contudo, no módulo Programação em R (Nível Avançado), iremos realizar algumas integrações com um abordagem mais profunda para algumas linguagens.\r\n\r\nImplementação em Python\r\nVamos inicialmente instalar o pacote reticulate,\r\n\r\n\r\ninstall.packages(reticulate)\r\n\r\n\r\n\r\nExistem diversas formas de integração. Vamos pensar na forma mais básica, isto é, temos um script Python, isto é, um arquivo com a extensão .py, e vamos carregá-lo no R. O script, chamaremos de add.py, que segue:\r\n\r\ndef add(x, y):\r\n  return x + y\r\n\r\nVamos agora chamar a função add() em um script R:\r\n\r\n\r\n# Carregando o script add.py\r\nreticulate::source_python('add.py') \r\n# Chamando a funcao add\r\nadd(5, 10)\r\n\r\n\r\n[1] 15\r\n\r\nImplementação em C++\r\nVamos instalar o pacote Rcpp,\r\n\r\n\r\ninstall.packages(Rcpp)\r\n\r\n\r\n\r\nVamos realizar a mesma aplicação feita em Python, que segue o script C++, com extensão .cpp,\r\n\r\n#include <Rcpp.h>\r\nusing namespace Rcpp;\r\n\r\n// [[Rcpp::export]]\r\nint add(int x, int y) {\r\n  return x + y;\r\n}\r\n\r\nVamos agora chamar a função add() em um script R:\r\n\r\n\r\n# Carregando o script add.cpp\r\nRcpp::sourceCpp(\"add.cpp\")\r\n# Chamando a funcao add\r\nadd(5, 10)\r\n\r\n\r\n[1] 15\r\n\r\nImplementação em TclTk\r\nNesse caso, não precisaremos instalar pacotes, pois o pacote tcltk é da Base do R. Ao invés, anexe-o no caminho de busca, use library(tcltk). Iremos implementar uma interface gráfica contendo uma janela com entradas de dois números e um botão para calcular a soma. Segue o script,\r\n\r\n\r\n# Anexando o pacote\r\nlibrary(tcltk)\r\n\r\n# Janela principal\r\nmain <- tktoplevel(width = 400, height = 300)\r\ntkpack.propagate(main, FALSE)\r\n\r\n# Texto inicial\r\ntkpack(tklabel(main, text = \"Soma de dois números inteiros\"))\r\n\r\n# Quadro 1\r\ntkpack(q1 <- tkframe(main), side = \"top\")\r\ntkpack(tklabel(q1, text = \"Insira o primeiro número: \", padx = 3), side = \"left\", anchor = \"e\")\r\n\r\n\r\n# Entrada 1\r\nvar1 <- tclVar(\"Insira um número inteiro\")\r\ntkpack(entry1 <- tkentry(q1, textvariable = var1, width = 25), side = \"left\", anchor = \"ne\")\r\n\r\n# Quadro 2\r\ntkpack(q2 <- tkframe(main), side = \"top\")\r\ntkpack(tklabel(q2, text = \"Insira o segundo número: \", padx = 3), side = \"left\", anchor = \"e\")\r\n\r\n# Entrada 2\r\nvar2 <- tclVar(\"Insira um número inteiro\")\r\ntkpack(entry2 <- tkentry(q2, textvariable = var2, width = 25), side = \"left\", anchor = \"ne\")\r\n# Botao \r\ntkpack(botao <- tkbutton(main, text = \"Somar dois números\"), side = \"top\")\r\n# Funcao auxiliar\r\nf1 <- function(...) {\r\n  if ((is.na(as.numeric(tclvalue(var1))) | is.na(as.numeric(tclvalue(var2))))) {\r\n    tkpack(tklabel(main, text = \"Insira Valores numéricos!\"), side = \"top\")\r\n  } else {\r\n    res <- as.numeric(tclvalue(var1)) + as.numeric(tclvalue(var2))\r\n    tkpack(tklabel(main, text = paste(\"A soma é igual a \", res)), side = \"top\")\r\n  }\r\n} \r\n# Acao ao Botao\r\ntkbind(botao, \"<ButtonRelease>\", f1)\r\n\r\n\r\n\r\nO vídeo abaixo apresenta o resultado da interface.\r\n\r\n\r\n\r\nExistem outras formas de chamar as rotinas em Python, C++ e Tcl/Tk no R, implementadas nos pacotes reticulate, Rcpp e tcltk, respecitvamente. Contudo, iremos apresentá-los no módulo Programação em R (Nível Avançado), bem como a integração de outras linguagens.\r\n\r\n Considerações e preparação para o módulo Programação em R (Nível Intermediário)\r\n\r\n\r\nNesse módulo, tentamos tratar as ideias básicas por trás dos três princípios do R, mas principalmente os fundamentos de um objeto e a ideia sobre função. Tentamos repassar algo mais técnico sobre esta linguagem. Contudo, sabemos que algo introdutório deve ter uma flexibilidade quanto a profundidade das discussões e exemplos abordados. Mesmo assim, esse módulo dará suporte para problemas mais complexos que abordaremos para os módulos seguintes.\r\nFaremos constantemente atualizações, quando necessárias, para melhorar esse material, e assim, auxiliar nos estudos de quem desejar entrar no mundo da linguagem R. Para isso, pedimos também a sua contribuição como leitor. Caso encontre alguma discordância nesse material ou complementos sobre a discussão, entre em contato pelas nossas redes sociais, como também por email: ben.deivide@ufsj.edu.br. Será muito bom podermos compartilhar as nossas experiências, uma vez que o conhecimento é uma liberdade necessária.\r\nNa Figura 20, apresentamos um resumo do que vem para o módulo Programação em R (Nível Intermediário).\r\n\r\n\r\n\r\nFigure 20: Relembrando como o R funciona.\r\n\r\n\r\n\r\nDentre os assuntos abordados, teremos:\r\nAprofundamento sobre os objetos, associando-os com a tipagem da linguagem C;\r\nCópias de objetos;\r\nAprofundamento sobre Ambientes;\r\nProgramação Orientada a objetos, bem como estudo de Métodos e Classes;\r\nProgramação Funcional:\r\nEvitando loops;\r\nEficiência;\r\nProgramando em baixo nível;\r\nProgramação defensiva;\r\n\r\nIntrodução a Criação de Pacotes;\r\nGráficos;\r\nCriação de documentos estáticas e dinâmicas;\r\nDessa forma, agradecemos imensamente o interesse como leitor, e também lhe provoco para participar juntamente conosco nessa propagação de conhecimento. Até o próximo módulo!\r\n\r\n\r\n\r\n\r\nChambers, John M. 2016. Extending R. The R Series. Boca Raton, Florida: Chapman; Hall/CRC.\r\n\r\n\r\nParadis, Emmanuel. 2005. “R for Beginners.” https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf.\r\n\r\n\r\nWickham, Hadley. 2015. R Packages. 2nd ed. O’Reilly Media. https://r-pkgs.org/index.html.\r\n\r\n\r\n———. 2019. Advanced R. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\nFonte das fotos: Robert Gentleman do site: https://biocasia2020.bioconductor.org/ e Ross Ihaka do site: https://www.stat.auckland.ac.nz/en/about/news-and-events-5/news/news-2017/2017/12/ross-ihaka-retires.html↩︎\r\nFontes: https://cran.r-project.org/doc/html/interface98-paper/paper_2.html e https://www.r-project.org/contributors.html↩︎\r\nFonte: https://stat.ethz.ch/pipermail/r-announce/1997/000001.html↩︎\r\nFonte: https://www.gnu.org/philosophy/free-sw.html↩︎\r\nFonte: https://www.gnu.org/philosophy/open-source-misses-the-point.html↩︎\r\nFonte: https://www.gnu.org/philosophy/open-source-misses-the-point.html↩︎\r\nhttps://cran.r-project.org/doc/html/interface98-paper/paper_1.html↩︎\r\nhttps://cran.r-project.org/doc/html/interface98-paper/paper_1.html↩︎\r\nFonte da foto: https://rstudio.com/speakers/j.j.-allaire/↩︎\r\nDo ingles, Integrated Development Environment, que significa Ambiente de Desenvolvimento Integrado, como por exemplo, o RStudio, Emacs, dentre outros, para o R.↩︎\r\nComprehensive R Archive Network↩︎\r\nFonte da foto: https://www.ufpr.br/portalufpr/noticias/disciplinas-transversais-para-programas-de-pos-graduacao-abrem-inscricoes-nesta-segunda-feira/↩︎\r\nFonte da foto: Retirada de sua página pessoal, https://statweb.stanford.edu/~jmc4/↩︎\r\nBasta usar a função invisible(10 + 15), que a expressão é avaliada mas não impressa↩︎\r\nou também double, usando a função typeof()↩︎\r\nsinônimo: string, cadeia de caracteres.↩︎\r\nDiferente de outras linguagens, como a C, que o contador começa do número 0.↩︎\r\nPara esse caso, use mode() para verificar.↩︎\r\nA anexação de um pacote no caminho de busca pressupõe que este esteja instalado no seu computador↩︎\r\nUse a função typeof() para verificar.↩︎\r\nUse a função typeof() para verificar.↩︎\r\nUse typeof() para verificar o modo.↩︎\r\n",
      "last_modified": "2021-10-15T21:12:48-03:00"
    },
    {
      "path": "nintermediario.html",
      "title": "Programação em R (Nível Intermediário)",
      "description": "Esse módulo terá o objetivo de detalhar o ambiente R, caracterizando melhor a sua linguagem, aprofundando **manipulações de objetos**, **cópias de objetos**, bem como **ambientes**. Falaremos sobre a criação de gráficos e **documentações em R**. Complementaremos também, sobre assuntos mais aprofundados como **programação funcional**, **programação orientada a objetos**, **metaprogramação** e uma introdução sobre **desenvolvimento de pacotes**. Por fim, ainda apresenderemos a desenvolver **gráficos**, e **banco de dados**.\n",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n\r\nSumário\r\n Caracterizando melhor o ambiente R\r\n Programação orientada a objetos\r\nNem tudo é orientado a objetos no R\r\nObjetos base\r\nSistemas de POO no R\r\nSistema S3\r\nFunções genéricas\r\nEntendendo melhor a chamada UseMethod\r\nCriando funções genéricas\r\nClasse e classe implícita\r\nMétodo S3\r\nEnvio de método e mecanismo de herança  \r\n\r\n\r\n Entendendo um pouco mais sobre objetos no R\r\nEstruturas atômicas e recursivas\r\nUsando vector(), is.vector() e as.vector()\r\nConhecendo outros objetos\r\nObjeto para datas, horas, tempo, durações e fusos horários \r\n\r\nCópia ao modificar, modificação no local e tamanho de objetos\r\nColetor de lixo e desvinculação\r\n\r\n Aprofundamento sobre ambientes\r\n Programação Funcional\r\nComposição de funções\r\nOperadores binários\r\nAvaliação preguiçosa dos argumentos de uma função\r\nSaídas implícitas, explícitas, invisíveis de funções\r\nFunções de substituição    \r\nProgramação defensiva\r\nControle de fluxos usando paralelização\r\n\r\n Banco de dados\r\n Gráficos\r\n Projetos no RStudio\r\n Projetos R no GitHub\r\n Introdução a desenvolvimento de pacotes\r\n Criação de documentações no R\r\nDocumentos Web\r\nPáginas estatísticas\r\nPáginas dinâmicas\r\n\r\nDocumentações de pacotes\r\nDocumentações de ajuda .Rd\r\nPágina Web de pacotes\r\n\r\nLivros\r\nBlogs e websites\r\nRelatórios\r\nRelatórios animados\r\nRelatórios dinâmicos\r\n\r\nDemais documentos (PDF, WORD, EPUB)\r\n\r\nSlides de Aulas\r\nAula 26: Apresentação do Curso\r\nAula 27: Caracterizando melhor o ambiente R\r\nAula 28: Introdução a POO no ambiente R\r\nAula 29: Tipos de objetos base\r\nAula 30: Sistemas de POO no R\r\nAula 31: Sistema S3\r\nAula 32: Sistema S3: Funções genéricas (POO no R)\r\nAula 33: Sistema S3: Chamada UseMethod (POO no R)\r\nAula 34: Sistema S3: Criando funções genéricas (POO no R)\r\nAula 35: Sistema S3: Classes e classes implícitas (POO no R)\r\nAula 36: Sistema S3: Métodos (POO no R)\r\nAula 37: Revisão sobre as aulas 27 a 36 Slide Vídeo-aula Script R\r\nAula 38: Sistema S3: Envio (despacho) de métodos\r\nAula 39: Sistema S3: Mecanismo de herança  \r\nAula 40: Entendendo um pouco mais sobre objetos: estruturas atômicas ou recursivos\r\nAula 41: Conhecendo outros objetos: Datas\r\nAula 42: Conhecendo outros objetos: Datas, horas e fusos horários\r\nAula 43: Cópia ao modificar, modificação no local de vetores\r\nAula 44: Cópia ao modificar, modificação no local em funções\r\nAula 45: Cópia ao modificar, modificação no local em listas\r\nAula 46: Cópia ao modificar, modificação no local em quadro de dados (Data frames)\r\nAula 47: Cópia ao modificar, modificação no local de vetores caracteres (strings)\r\nAula 48: Tamanho de objetos \r\nAula 49: Ambientes: Introdução aprofundada\r\nAula 50: Ambientes funcionais\r\nAula 51: Ambientes em pacotes\r\nAula 52: Programação funcional: Introdução\r\nAula 53: Programação funcional: Composição de funções\r\nAula 54: Programação funcional: Operadores unários e binários\r\nAula 55: Programação funcional: Avaliação preguiçosa dos argumentos de uma função\r\nAula 56: Programação funcional: Saídas implícitas, explícitas, invisíveis de funções\r\nAula 57: Programação funcional: funções de substituição\r\nAula 58: Programação funcional: Vetorização de funções\r\nAula 59: Programação funcional: funções da família apply\r\nAula 60: Programação funcional: funções recursivas\r\nAula 61: Programação defensiva em funções\r\nAula 62: Projetos no RStudio\r\nAula 63: Projetos no Github\r\nAula 64: Introdução a desenvolvimento de pacotes\r\nAula 65: Introdução a criação de documentos no R\r\nAula 66: Criações de livros\r\nAula 67: Página web via pacote distill\r\nAula 68: Página web via pacote blogdown\r\nAula 69: Página web via pacote pkgdown\r\nAula 70: Preparação para o módulo avançado\r\nScripts\r\nScript 00:\r\nExercícios e Scripts via Shiny\r\nCurso R via Shiny\r\n\r\n Apresentação do curso\r\n\r\n\r\nO Curso R será todo aprensentado no formato online, sendo que as aulas terão vídeos como suporte, postados no canal Youtube/Ben Dêivide divulgados ao longo do material. Os vídeos serão bem objetivos de curta duração para que usem como suporte com o material escrito. Como complemento desse material, disponibilizaremos os scripts com os comandos utilizados em cada aula e sua versão em Shiny para os que não quiserem realizar inicialmente a instalação do R e do RStudio, poderão utilizar uma versão online do material juntamente com a linguagem R.\r\n Caracterizando melhor o ambiente R\r\n\r\n\r\nAo estudarmos o módulo básico do Curso R, conseguimos obter uma visão geral sobre o ambiente R, de modo que o aprofundamento sobre a linguagem se faz necessário, para quem deseja não apenas executar rotinas prontas, mas de fato, um contribuidor para a linguagem, como também um desenvolvedor de suas próprias funções.\r\nNa Figura 1, apresentamos um resumo do que buscamos repassar no primeiro módulo. Agora, iremos no módulo intermediário, de fato, entender os dois princípios: Objeto e Função, para que fique claro que nem tudo no R é orientado a objetos, e que a rigor o R não é uma linguagem de programação funcional. Com essas informações, dentre outras, o programador poderá ter um maior controle sobre o desenvolvimento de suas próprias rotinas e funções.\r\n\r\n\r\n\r\nFigure 1: Relembrando como o R funciona.\r\n\r\n\r\n\r\nVamos inicialmente caracterizar melhor o R. Por que usamos os termos linguagem, software ou ambiente para o R? Na página do R, na seção about se inicia com a primeira pergunta: O que é o R? Em resposta da própria página e utilizando também como resposta a nossa indagação inicial, o “R é uma linguagem e ambiente para computação estatística e gráficos,” que ainda complementa que essa linguagem é uma implementação diferente da linguagem S, linguagem essa do qual inclui as principais implementações para análise estatística. Contudo, ocorrem algumas diferenças dentre as quais já apresentamos no módulo básico, a presença do escopo léxico no R, que não ocorre na linguagem S. Desse modo, percebemos que o R é uma linguagem interpretada, pois além da linguagem S (o que fácil para os usuários a implementação do código), a sua base foi programada em C e FORTRAN (para computação mais intensiva). Mas também, adjetivamos o R como ambiente de software ao invés de apenas software, e aqui predominaremos esse termo, pois segundo ainda na própia página do R se “pretende caracterizá-lo como um sistema totalmente planejado e coerente, ao invés de um acréscimo incremental de ferramentas muito específicas e inflexíveis, como é frequentemente o caso com outros softwares de análise de dados.” Assim, esse ambiente inclui:\r\nmanipulação de dados;\r\noperações com matrizes;\r\ncoleção de ferramentas para análise de dados;\r\ncriação e apresentações gráficas, para apresentação dos dados;\r\nlinguagem que inclui condicionais, fluxos de controle, funções recursivas definidas pelo usuário e recursos de entrada e saída;\r\nDocumentação e relatórios de análises.\r\nExistem linguagens como C e FORTRAN, por exemplo, que a execução do código nessas linguagem precisam de uma compilação, para depois serem executadas, isto é, as linhas de códigos programadas pelo usuário precisam ser convertidas na linguagem de máquina, para que depois seja executa. Porém, no R, quando escrevemos uma linha de comando no console, do tipo:\r\n\r\n\r\n(x <- 10)\r\n\r\n\r\n[1] 10\r\n\r\nPercebemos no R o código é automaticamente interpretado conforme o usuário executa. Desse modo, caracterizamos a linguagem de programação dinâmica. A ideia se estende a avaliação de funções, a extensão da linguagem sem o uso de macros, e a manipulação com ambiente. Ainda mais, podemos afirmar também que essa dinamicidade está relacionada ao fato do R também ser uma linguagem fortemente e dinamicamente tipada. Nesse caso, os valores contidos nos objetos é que são tipados. Por exemplo, vetores atômicos apresentam sempre elementos com mesmo tipo. Porém, à medida que adicionamos elementos ao vetor, pode haver a coersão da tipagem dos elementos, quando esses elementos apresentam tipos diferentes, como foi abordado no módulo básico, na seção coersão. Vejamos um exemplo, a seguir.\r\n\r\n\r\nvetor <- TRUE; typeof(vetor)\r\n\r\n\r\n[1] \"logical\"\r\n\r\nvetor[2] <- 1; typeof(vetor)\r\n\r\n\r\n[1] \"double\"\r\n\r\nvetor[3] <- \"1\"; typeof(vetor)\r\n\r\n\r\n[1] \"character\"\r\n\r\nvetor\r\n\r\n\r\n[1] \"1\" \"1\" \"1\"\r\n\r\nObservemos que o objeto associado ao nome vetor vai alterando a tipagem por coersão, é o comportamento dinâmico da linguagem. Observe que o nome vetor é um objeto de tipo symbol e o vetor c(\"1\", \"1\" \"1\") é outro objeto, cujos os elementos foram coagidos a tipagem character. Claro, que o acesso ao vetor só é possível recuperar da memória ativa, se este estiver associado a algum nome, no caso vetor. Porém, não é o nome que altera o seu tipo, mas os elementos do objeto associado a este nome, em que, por ser um verto atômico, seus elementos devem apresentar o mesmo tipo.\r\nA ideia do R como uma linguagem de programação com estilo funcional, se deve pelo fato da linguagem ter funções de primeira classe, function(), isto é, funções que se comportam como qualquer outro objeto no ambiente R. Por exemplo, podemos atribuir nomes as nossas funções, armazená-las em listas, serem criadas dentro de outras funções, serem argumentos de outras funções, ou até ser um resultado de uma função. Inclusive na versão do R 4.1, a função function() ganhou um novo formato, que também pode ser usado. Vejamos o exemplo:\r\n\r\n\r\n# Forma original\r\nsoma1 <- function(x) x + 1; soma1(1)\r\n\r\n\r\n[1] 2\r\n\r\n# Forma alternativa (>= R 4.1)\r\nsoma1 <- \\(x) x + 1; soma1(1)\r\n\r\n\r\n[1] 2\r\n\r\nPara complementar atualizações dessa versão, uma outra importante foi implemento da função pipe (%>%). Originalmente, a função pipe (lê-se paipe) é do pacote magrittr da família de pacotes tidyverse, do qual é um operador binário em que o primeiro operando é um objeto para a entrada de dados, e o segundo é uma função. Nesse caso, o objeto no primeiro operando entrará no primeiro argumento da função no segundo operando. Vejamos um exemplo, a seguir.\r\n\r\n\r\n# install.packages(magrittr) # Instalando o pacote\r\nlibrary(magrittr) # anexando o pacote\r\n1:10 %>% mean\r\n\r\n\r\n[1] 5.5\r\n\r\nObserve que calculamos a média do vetor 1:10. Agora, a versão do pipe nativa no R (>= 4.1), sua sintaxe é |>. Vejamos o mesmo exemplo usado anteriormente, agora com a função nativa, isto é,\r\n\r\n\r\n1:10 |> mean()\r\n\r\n\r\n[1] 5.5\r\n\r\nA diferença no caso do pipe nativo é que no segundo argumento, além do nome da função, acrescemos o parênteses sem seus argumentos. Lembrando que o primeiro operando entrará no primeiro argumento da função (segundo operando).\r\nRetornando a programação funcional, sabemos que o R não é estritamente funcional. A definição de programação funcional apresenta algumas características, dentre elas, que a linguagem apresente:\r\nComposição de funções;\r\nFunções puras;\r\nImutabilidade;\r\nEfeito colateral;\r\nA ideia da composição de funções representa a criação de funções por meio de outras funções, e isso está dentro da linguagem R. Por exemplo, vamos criar uma função que calcula a média de um conjunto de dados, usando a função, mean(), já existente no pacote base, isto é,\r\n\r\n\r\nx <- 1:10\r\nmedia <- function(x) mean(x)\r\nmedia(x)\r\n\r\n\r\n[1] 5.5\r\n\r\nA caracterização de funções puras, significa que as funções sempre retornam o mesmo resultado, dados os mesmos parâmetros de entrada, isto significa que não existe efeito colateral. Um exemplo de função pura, pode ser como:\r\n\r\n\r\nfpura <- function(x) {\r\n  if (!is.numeric(x)) stop(\"x deve ser numérico\")\r\n  x + 1\r\n}\r\nfpura(x = 2)\r\n\r\n\r\n[1] 3\r\n\r\nObserve que fpura() toda vez que a entrada for x = 2, o resultado sempre será o resultado 3. Porém, o R se exclui dessa característica estritamente funcional, quando aprensentamos funções: runif(), rnorm(), read.csv(), dentre outras. Por exemplo, a função rnorm() representa um gerador de números aleatórios de uma distribuição normal, do qual se executarmos essa função, mais de uma vez, usando a mesma entrada para o argumento n = 3, o resultado não será sempre o mesmo, observe:\r\n\r\n\r\nrnorm(n = 3)\r\n\r\n\r\n[1]  1.0337700  0.3647557 -0.2428575\r\n\r\nrnorm(n = 3)\r\n\r\n\r\n[1] -1.5657441  0.6763031 -1.4781201\r\n\r\nA imutabilidade na programação funcional apresenta em uma linguagem na situação em que uma variável ou objeto é criado, e este não pode ser modificado. Esta é outra característica que ocorre no R, mas não para todos os objetos em que exitem nomes associados, é o caso da modificação no local. Por exemplo, vamos apresentar um contra-exemplo de que nem todos os objetos no R são imutáveis. Vejamos:\r\n\r\n\r\n# Criamos um vetor e associamos ao nome 'x'\r\nx <- c(1, 2, 3)\r\n# Vejamos o identificador de memória\r\nlobstr::obj_addr(x)\r\n# > \"0xcf09be4708\"\r\n# Modificando no local\r\nx[2] <- 4; x\r\n# [1] 1 4 3\r\n# Mesmo modificando o objeto, o identificador eh o mesmo\r\nlobstr::obj_addr(x)\r\n# > \"0xcf09be4708\"\r\n\r\n\r\n\r\nPara a execução dessas linhas de comando, sugerimos que não utilizem diretamente o RStudio, porque a IDE sempre faz uma referência a cada objeto. Sugerimos que utilize a própria interface do R. Esse tema será aprodundado mais a frente, na seção entendendo um pouco mais sobre objetos.\r\nPor fim, duas outras características importantes do estilo funcional da linguagem, é o escopo léxico das funções, assunto abordado no módulo básico, e a execução preguiçosa, do qual o argumentos das funções são avaliados apenas quando utilizados. Vejamos, o exemplo a seguir.\r\n\r\n\r\npreguicoso <- function(a, b = faux())  a * 100\r\npreguicoso(4)\r\n\r\n\r\n[1] 400\r\n\r\nObservemos nesse caso, que o argumento b recebe uma função aux() que não existe. Contudo, ao executar a linha de comando seguindo, a função preguicoso retorna o resultado 400 sem erro. Isso porque como não foi necessário utilizar o argumento b no corpo da função, este não foi avaliado, e portanto, sem retorno de erro da função preguicoso. Iremos mais a frente, detalhar essa característica de modo mais aprofundado.\r\nO R não é uma linguagem totalmente orientada a objetos, como afirmado por alguns. Apesar, de um dos princípios do R que tudo é um objeto, não significa dizer que tudo é orientado a objetos. Isso se deve ao fato de que os primeiro objetos criados no R, que chamaremos de objetos base, foram desenvolvidos baseados na linguagem S. E nesse tempo não havia qualquer cogitação de que fosse necessário um sistema de programação orientada a objetos (POO). Veremos mais a frente, que a distinção básica entre objetos base e objetos baseados em sistemas orientados a objetos, chamaremos de objetos POO, é que estes últimos terão o atributo class, do qual podemos consultá-lo pela função attr(). Vejamos, alguns exemplos:\r\n\r\n\r\n# Objetos POO\r\nattr(ggplot2::diamonds, \"class\")\r\n\r\n\r\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\r\n\r\n# Objetos base\r\nattr(1:10, \"class\")\r\n\r\n\r\nNULL\r\n\r\nQuando não há o atributo class, isto é, NULL, é objeto base. Contudo, iremos na seção Programação orientada a objetos saber em que sistemas esses objetos estão orientados, porque no R, diferentemente de outras linguagens, existem vários sistemas POO, como: S3, S4 R5 (classes de referências), R6, dentre outros.\r\nPor fim, como última caracterização do R abordada é como uma linguagem de programação metaparadigma ocorre porque pela própria linguagem, poderemos inspecioná-la, modificá-la, por ela mesma, como se fosse um objeto, o que acaba tornando uma ferramenta muito poderosa. E isso será tema abordado mais a frente.\r\nPortanto, esclarecido isso, e ainda com as demais características apresentadas no módulo básico, dizemos que o R é:\r\num ambiente de software livre e código aberto, com licença GNU;\r\numalinguagem de programação interpretada;\r\numa linguagem de programação dinâmica;\r\numa linguagem de programação funcional;\r\nde escopo lêxico;\r\navaliação preguiçosa;\r\n\r\numa linguagem de programação orientada a objetos;\r\numa linguagem de tipagem forte e dinâmica; e\r\numa linguagem de programação metaparadigma.\r\n Programação orientada a objetos\r\n\r\n\r\nAssim como no nosso dia a dia podemos realizar uma mesma tarefa de modos diferentes, isso ocorre também na programação. Nesse caso, dizemos que esses modos são os paradigmas da programação. E a programação orientada a objetos (POO) é um desses paradigmas que veio para contornar alguns problemas da programação estrutural, um outro paradigma.\r\nAntes de apresentarmos outras diferenças entre os objetos base e objetos OO, se faz necessário entendermos alguns conceitos da POO, do qual tudo se desencadeará pelos termos classe, objeto e método. Para isso, vamos ilustrar alguns termos baseados no nosso cotidiano. Uma das grandes cobiças nessa era digital é ter um bom smartphone para que possamos estar conectados nessa era digital, bem não sei se foi bem esse objetivo do smartphone, mas consideremos que tenha sido. Essa escolha se deve a algumas características tamanho, cor, desempenho, câmera, dentre outras. Outro fator que pode ter sido o motido da sua escolha é o comportamento desse celular, como o seu desempenho do processador, a velocidade com o qual se desenvolve as atividades, a forma como os aplicativos reagem as suas ações, o sistema como o algoritmo baseado em inteligência artificial interage com todo o sistema operacional do aparelho, dentre outros. Nesse momento, fazendo uma relação com o ambiente R, dizemos que o celular que desejamos é o objeto, suas características são os atributos do objeto, e o comportamento será o método aplicado a este objeto na programação orientada a objetos.\r\nMesmo que seu aparelho apresente um IMEI (Código de identificação do aparelho) único, nós sabemos que existem diversos aparelhos com essa mesma configuração, modelo e marca, alguns outros com pequenas características que o diferenciam, mas conseguimos identificar ainda assim, esse objeto como um celular. Portanto, podemos dizer que o celular é uma classe para o ambiente R, em que apesar de termos diversos objetos, estes são identificados dentro de um conjunto de características que o definem como celular. Nesse caso, dizemos ainda que o celular que escolhemos é uma instância dessa classe, que apesar de ter atributos próprios, ainda assim, é identificado como um celular. Desse modo, ao ser definidos as classes de determinados objetos, a linguagem saberá utilizar o método correto para tal objeto, isso significa que mesmo que não saibamos como ocorre, devemos confiar que ocorrerá. Isso é programação orientada a objetos.\r\nTeríamos mais analogias para abordar, como encapsulamento, hierarquias , envio (ou despacho) de método, polimorfismo, subclasses, superclasses, dentre outras. Mas, vamos deixar para discutir ao longo das aplicações.\r\nAssim, esse paradigma da programação permite associarmos o desenvolvimento do nosso código pra dentro de nossa realidade humana. Porém a ideia de POO dentro do R sai do escopo de implementações densenvolvidas em outras linguagens. Antes de entrarmos no tema propriamente dito, queremos ressaltar que não estamos interessados em repassar uma POO eficiente, devido a todo o cunho teórico exigido para o assunto. Mas, queremos repassar como os principais sistemas de POO foram desenvolvidos dentro do R.\r\nNem tudo é orientado a objetos no R\r\n\r\n\r\nUma primeira ideia que temos que saber é que apenas de um dos princípios que tudo no R é um objeto, mas nem tudo é orientado a objetos. Isso ocorre, porque discutimos anteriormente, que o R é um dialeto da linguagem S. No início do desenvolvimento da linguagem S, John Chambers e seus colaboradores nem cogitavam para a implementação do código a programação orientada a objetos, desse modo, o R quando começou a ser densevolvido, os primeiros objetos desenvolvidos foram vêm dessas primeiras versões da linguagem S, sem ainda a implementação de POO.\r\nDessa forma, vamos distinguir o R com dois tipos de objetos:\r\nObjetos POO (Objetos para POO)\r\nObjetos base (Objetos não voltados a POO)\r\nA principal diferença técnica é que um objeto POO terá o atributo class, e o objeto base, não. Vejamos,\r\n\r\n\r\n# Objeto \"data.frame\"\r\nobjPOO <- data.frame(a = 1, b = \"1\", c = TRUE)\r\n# Objeto \"data.frame\" eh um objeto POO?\r\nis.object(objPOO)\r\n\r\n\r\n[1] TRUE\r\n\r\n# Vetor de comprimento 10\r\nobjBASE <- 1:10\r\n# O vetor eh um objeto POO?\r\nis.object(objBASE)\r\n\r\n\r\n[1] FALSE\r\n\r\nPela função is.object(), sabemos se um objeto é de POO ou não. Entretanto, no R temos diversos sistemas POO, alguns da base de instalação do programa, e outros disponíveis no CRAN. Detalharemos os tipos, a seguir.\r\nObjetos base\r\nExistem 24 tipos de objetos diferentes no R (antes eram 26, porém o objetos referentes a fatores e fatores ordenados foram retirados). A base de criação desses objetos foram a linguagem C, e que na realidade são ponteiros para uma estrutura com typedef SEXPREC. Os seus tipos estão representados por SEXPTYPE, que determina como as características da estrutura são usadas. Para mais detalhes, ler R Language Definition e R Internals. Alguns tipos são importantes para o usuário R, outros apenas com importância interna ao ambiente R, dos quais esses tipos podem ser identificados pela função typeof(), que segue:\r\nRepresentação em R\r\nRepresentação em C (SEXPTYPE)\r\nDescrição\r\nNULL\r\nNILSXP\r\nÚnico vetor que tem comprimento zero e não pode ter atributo\r\nlogical\r\nLGLSXP\r\nVetores lógicos\r\ninteger\r\nINTSXP\r\nVetores inteiros\r\ndouble\r\nREALSXP\r\nVetores reais\r\ncomplex\r\nCPLXSXP\r\nVetores complexos\r\ncharacter\r\nSTRSXP\r\nVetores caracteres (strings)\r\nlist\r\nVECSXP\r\nListas\r\nraw\r\nRAWSXP\r\nVetores brutos\r\nclosure\r\nCLOSXP\r\nFunções criadas por meio de function()\r\nspecial\r\nSPECIALSXP\r\nFunções primitivas (funções básicas e operadores) que são escritas principalmente na linguagem C. Desse modo, essas funções não apresentam as três estruturas básicas de uma função do tipo closure, como formals(), body(), environment(), que são todas NULL. Aprofundaremos esse objeto no módulo avançado\r\nbultin\r\nBUILTINSXP\r\nFunções primitivas (funções básicas e operadores) que são escritas principalmente na linguagem C. Desse modo, essas funções não apresentam as três estruturas básicas de uma função do tipo closure, como formals(), body(), environment(), que são todas NULL. Aprofundaremos esse objeto no módulo avançado\r\nenvironment\r\nENVSXP\r\nAmbientes\r\nS4\r\nS4SXP\r\nObjetos com sistema POO S4\r\nsymbol\r\nSYMSXP\r\nNomes associados aos objetos\r\nlanguage\r\nLANGSXP\r\nObjetos de linguagem, que abordaremos na seção sobre metaprogramação\r\npairlist\r\nLISTSXP\r\nArgumento das funções\r\nexpression\r\nEXPRESXP\r\nVetores de expressão\r\nexternalptr\r\nEXTPTRSXP\r\nPonteiro externo, são vetores exóticos que tem importância para a linguagem C\r\nweakref\r\nWEAKREFSXP\r\nReferência fraca, são vetores exóticos que tem importância para a linguagem C\r\nbytecode\r\nBCODESXP\r\nCódigo de byte, são vetores exóticos que tem importância para a linguagem C\r\npromise\r\nPROMSXP\r\nPromessas, são objetos responsáveis pelo pelo carregamento preguiçoso dos argumentos de uma função\r\n...\r\nDOTSXP\r\nObjeto utilizado como um argumento da função, após a criação de uma função, ainda assim, podem ser inseridos mais argumentos\r\nany\r\nANYSXP\r\nObjeto que representa qualquer tipo. Raramente utilizado em R, mas aparece por exemplo em as.vector(x, mode = \"any\"), considerando que x é um objeto R\r\n-\r\nCHARSXP\r\nCadeia de caracteres internas, isto é, um tipo de escalar string, usado somente internamente\r\nTodas as funcões que usam esses objetos base e apresentam comportamento diferentes, não usam o sitema POO, porque foram implementadas em sua maioria na linguagem C, usando a instrução switch, em que também aprofundaremos no módulo avançado.\r\nSistemas de POO no R\r\n\r\n\r\nUsando as ideias de Chambers (2016), complementadas por Wickham (2019), dizemos que o paradigma da programação orientada a objetos pode ser dividida em dois ramos:\r\nPOO encapsulada: os métodos são encapsulado em suas classes, isto é, os objetos nesse estilo de programação contém os seus comportamentos;\r\nPOO funcional: os métodos pertencem as funções, das quais serão aplicadas aos objetos de determinada classe.\r\nO R em sua base, apresenta três sistemas de POO: S3, S4 e CR (classes de referência). No CRAN, existem diversas implementações de POO, das quais podemos citar: R6 (pacote R6), R.oo, proto, dentre outros.\r\nExploraremos para esse momento, apenas o sistema S3 (POO funcional), em que o sitema S4 também apresenta o paradigma POO funcional. Esses dois sistemas foram a evolução da implementação de POO na linguagem S implementadas no R. Contudo, os seus nomes geram a impressão de que também haviam os sistemas S1 e S2, mas não, os nomes S3 e S4 se devem as versões da linguagem S, como evolução da linguagem em si. Nesses momentos, foram o marco para a incorporação da programação orientada a objetos na linguagem, em que antes não existia, por isso, não haver sistemas S1 e S2.\r\nPara complementar a carcterização dos sistemas citados, os sistemas RC e R6 apresentam o paradigma POO encapsulado. Os demais sistemas implementados nos pacotes disponíveis no CRAN, como R.oo fornece algum formalismo em cima de S3 e torna possível ter objetos S3 mutáveis (Wickham (2019)), e proto que implementa outro estilo de OOP baseado na ideia de protótipos , que confundem as distinções entre classes e instâncias de classes (objetos) (Wickham (2019)), do qual foi o sistema implementado para o pacote ggplot2.\r\nSistema S3\r\n\r\n\r\n\r\nPoderíamos descrever todos os sistemas, porém restringiremos ao sistema S3, por uma única razão, é o sistema amplamente empregado aos objetos dos pacotes base e stats, bem como na maioria dos pacotes disponíveis no CRAN. Mais detalhes sobre o sistema, sugerimos leituras em Chambers (2016), Wickham (2019), Chambers (2008), Chambers and Hastie (1991), dentre outros materiais.\r\nComo falado anteriormente, um objeto POO terá sempre um atributo class, em que podemos utilizar a função atributes para verificar isso. Vejamos,\r\n\r\n\r\nquadro_dados <- data.frame(a = 1, b = TRUE, c = \"A\")\r\nattributes(quadro_dados)\r\n\r\n\r\n$names\r\n[1] \"a\" \"b\" \"c\"\r\n\r\n$class\r\n[1] \"data.frame\"\r\n\r\n$row.names\r\n[1] 1\r\n\r\nO fato do objeto quadro_dados ter o atributo class=data.frame, lhe dá um comportamento especial a determinadas funções genéricas. Vejamos como imprimos essa função pela funcão print(), isto é,\r\n\r\n\r\nprint(quadro_dados)\r\n\r\n\r\n  a    b c\r\n1 1 TRUE A\r\n\r\nRemovendo esse atributo do objeto, por meio da função unclass(), voltamos ao tipo de objeto base subjascente. Dessa forma, a função print perde esse comportamento especial, apresentada a seguir.\r\n\r\n\r\nprint(unclass(quadro_dados))\r\n\r\n\r\n$a\r\n[1] 1\r\n\r\n$b\r\n[1] TRUE\r\n\r\n$c\r\n[1] \"A\"\r\n\r\nattr(,\"row.names\")\r\n[1] 1\r\n\r\nIsso significa, que o objeto data.frame perde seu comportamento especial e retorna ao mesmo comportamento de uma lista. Afinal, falamos no módulo básico que um objeto data.frame é uma lista.\r\nFunções genéricas\r\n\r\n\r\nA base do sistema S3 está nas funções genéricas ou também podemos chamar de genéricos, que buscam o método específico para determinada classe de um objeto. Esta função representa um intermediário do sistema S3, do qual define os argumentos de entrada, e na sequência, encontra o método certo, baseado na classe do objeto associado ao primeiro argumento da função genérica. Para sabermos se uma função é genérica, temos algumas funções: utils::isS3stdGeneric() e sloop::ftype(). Verificando esta última função, além de informar se é uma função genérica, informa também o sistema POO, além do que a função utils::isS3stdGeneric() apenas retorna TRUE, as funções genéricas S3 que apresentam no corpo de sua função, a chamada UseMethod. Vale lembrar, que funções primitivas/internas não apresentam essa chamada de função. Dessa forma, usaremos, principalmente, a função sloop::ftype() como pesquisa por funções genéricas. Vejamos,\r\n\r\n\r\n# Funcoes do tipo \"closure\" que nao pertencem ao sistema S3\r\nutils::isS3stdGeneric(data)\r\n\r\n\r\n[1] FALSE\r\n\r\nsloop::ftype(data)\r\n\r\n\r\n[1] \"function\"\r\n\r\n# Funcao generica S3 em funcoes do tipo \"closure\"\r\nutils::isS3stdGeneric(mean)\r\n\r\n\r\nmean \r\nTRUE \r\n\r\nsloop::ftype(mean)\r\n\r\n\r\n[1] \"S3\"      \"generic\"\r\n\r\n# funcoes primitivas e internas que nao pertencem ao sistema S3\r\nutils::isS3stdGeneric(inherits)\r\n\r\n\r\n[1] FALSE\r\n\r\nsloop::ftype(inherits)\r\n\r\n\r\n[1] \"internal\"\r\n\r\n#-----\r\nutils::isS3stdGeneric(unclass)\r\n\r\n\r\n[1] FALSE\r\n\r\nsloop::ftype(unclass)\r\n\r\n\r\n[1] \"primitive\"\r\n\r\n# funcoes genericas do sistema S3 que sao primitivas e internas\r\nutils::isS3stdGeneric(length)\r\n\r\n\r\n[1] FALSE\r\n\r\nsloop::ftype(length)\r\n\r\n\r\n[1] \"primitive\" \"generic\"  \r\n\r\n#--\r\nutils::isS3stdGeneric(unlist)\r\n\r\n\r\n[1] FALSE\r\n\r\nsloop::ftype(unlist)\r\n\r\n\r\n[1] \"internal\" \"generic\" \r\n\r\nA função sloop::ftype() retorna um vetor de caracteres de comprimento 1 ou 2. Quando retorna apenas um valor, do qual não obtemos o resultado generic, significa que esta função não é genérica, como é o caso da função data. Quando há um retorno de dois valores, e um deles é generic, significa dizer que a função é genérica, em que o primeiro valor, representa o sistema POO, como é o caso da função mean. No caso, das funções primitivas/internas que estão no pacote base, o primeiro resultado da função sloop::ftype() para a referida função será primitive ou internal, e se houver o segundo valor de nome generic, se confirma que também é um função primitiva genérica do método S3.\r\nAs funções genéricas do tipo closure terão no corpo de sua função a chamada UseMethod, uma função primitiva . Essa é a identificação básica de uma função genérica. Podemos observar, como exemplo, a função mean:\r\n\r\n\r\nmean\r\n\r\n\r\nfunction (x, ...) \r\nUseMethod(\"mean\")\r\n<bytecode: 0x0000000008634560>\r\n<environment: namespace:base>\r\n\r\nEntretanto, funções primitivas e internas são escritas em linguagem C, mas também podem ser funções genéricas. Não há função no R para acesso direto do código interno interno dessas funções, bem como de seus argumentos. O que na realidade deve ser feito é acessar código fonte. Para isso, podemos pesquisar sobre alguma função primitiva, por exemplo '[[', por pryr::show_c_source(.Primitive(\"[[\")).\r\nO que ocorre nesse caso, é que estas funções não usam a chamada UseMethod. Desse modo, as funções primitivas e internas podem ser identificadas, pelo objeto .S3PrimitiveGenerics, um vetor de caracteres, que seguem:\r\n\r\n\r\n.S3PrimitiveGenerics\r\n\r\n\r\n [1] \"anyNA\"          \"as.character\"   \"as.complex\"    \r\n [4] \"as.double\"      \"as.environment\" \"as.integer\"    \r\n [7] \"as.logical\"     \"as.call\"        \"as.numeric\"    \r\n[10] \"as.raw\"         \"c\"              \"dim\"           \r\n[13] \"dim<-\"          \"dimnames\"       \"dimnames<-\"    \r\n[16] \"is.array\"       \"is.finite\"      \"is.infinite\"   \r\n[19] \"is.matrix\"      \"is.na\"          \"is.nan\"        \r\n[22] \"is.numeric\"     \"length\"         \"length<-\"      \r\n[25] \"levels<-\"       \"names\"          \"names<-\"       \r\n[28] \"rep\"            \"seq.int\"        \"xtfrm\"         \r\n\r\n# Outras funcoes primitivas\r\n(outros_obj_S3_primitivos <- c(\"[\", \"[[\", \"$\", \"[<-\", \"[[<-\", \"$<-\"))\r\n\r\n\r\n[1] \"[\"    \"[[\"   \"$\"    \"[<-\"  \"[[<-\" \"$<-\" \r\n\r\n# Outras funcoes internas nao primitivas\r\n(outros_obj_S3_primitivos <- c(\"unlist\", \"cbind\", \"rbind\", \"as.vector\"))\r\n\r\n\r\n[1] \"unlist\"    \"cbind\"     \"rbind\"     \"as.vector\"\r\n\r\nAlgumas outras funções como is.name que é sinônimo da função is.symbol, assim como a função as.numeric é sinônimo da função as.double. Existem outras funções genéricas que também são primitivas/internas, são as funções genéricas do grupo S3 que não estão descritos no objeto .S3PrimitiveGenerics. Há quatro desses grupos para que os métodos S3 podem ser escritos, denominados: grupo Math, grupo Ops, grupo Summary e grupo Complex. Detalhamos as funções:\r\nGrupo Math:\r\nabs, sign, sqrt, floor, ceiling, trunc, round, signif\r\nexp, log, expm1, log1p, cos, sin, tan, cospi, sinpi, tanpi, acos, asin, atan, cosh, sinh, tanh, acosh, asinh, atanh\r\nlgamma, gamma, digamma, trigamma\r\ncumsum, cumprod, cummax, cummin\r\n\r\nGrupo Ops:\r\n\"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\r\n\"&\", \"|\", \"!\"\r\n\"==\", \"!=\", \"<\", \"<=\", \">=\", \">\"\r\n\r\nGrupo Summary:\r\nall, any, sum, prod, min, max, range\r\n\r\nGrupo Complex:\r\nArg, Conj, Im, Mod, Re\r\n\r\nApesar não termos funções com nomes Math, Ops, Summary e Complex no pacote base, e portanto, também não serem objetos R, podemos fornecer métodos para estes, como por exemplo, no pacote base, temos métodos como:\r\nMétodos de Math:\r\n\r\n\r\nmethods(\"Math\")\r\n\r\n\r\n [1] Math,CsparseMatrix-method  Math,ddenseMatrix-method  \r\n [3] Math,denseMatrix-method    Math,dgeMatrix-method     \r\n [5] Math,diagonalMatrix-method Math,nonStructure-method  \r\n [7] Math,sparseMatrix-method   Math,sparseVector-method  \r\n [9] Math,structure-method      Math.data.frame           \r\n[11] Math.Date                  Math.difftime             \r\n[13] Math.factor                Math.POSIXt               \r\n[15] Math.quosure*              Math.vctrs_sclr*          \r\n[17] Math.vctrs_vctr*          \r\nsee '?methods' for accessing help and source code\r\n\r\nMétodos de Summary:\r\n\r\n\r\nmethods(\"Summary\")\r\n\r\n\r\n [1] Summary,abIndex-method       Summary,ddenseMatrix-method \r\n [3] Summary,ddiMatrix-method     Summary,dsparseMatrix-method\r\n [5] Summary,indMatrix-method     Summary,ldenseMatrix-method \r\n [7] Summary,ldiMatrix-method     Summary,lMatrix-method      \r\n [9] Summary,Matrix-method        Summary,ndenseMatrix-method \r\n[11] Summary,nMatrix-method       Summary,nsparseVector-method\r\n[13] Summary,sparseVector-method  Summary.data.frame          \r\n[15] Summary.Date                 Summary.difftime            \r\n[17] Summary.factor               Summary.numeric_version     \r\n[19] Summary.ordered              Summary.POSIXct             \r\n[21] Summary.POSIXlt              Summary.quosure*            \r\n[23] Summary.roman*               Summary.unit*               \r\n[25] Summary.vctrs_sclr*          Summary.vctrs_vctr*         \r\nsee '?methods' for accessing help and source code\r\n\r\nMétodos de Complex:\r\n\r\n\r\nmethods(\"Complex\")\r\n\r\n\r\n[1] Complex.vctrs_sclr*\r\nsee '?methods' for accessing help and source code\r\n\r\nOs métodos que estão com asterisco é porque não são exportados do namespace dos pacotes em que essas funções foram criadas. Para isso, use :::, getS3method ou getAnywhere. Por exemplo, se tentarmos procurar pelo método str.data.frame no console, não iremos encontrar porque ela não foi exportada pelo namespace do pacote utils. Para acessar o referido método, segue:\r\n\r\n\r\n# Primeira forma:\r\ngetAnywhere(\"str.data.frame\")\r\n\r\n\r\nA single object matching 'str.data.frame' was found\r\nIt was found in the following places\r\n  registered S3 method for str from namespace utils\r\n  namespace:utils\r\nwith value\r\n\r\nfunction (object, ...) \r\n{\r\n    if (!is.data.frame(object)) {\r\n        warning(\"str.data.frame() called with non-data.frame -- coercing to one.\")\r\n        object <- data.frame(object)\r\n    }\r\n    cl <- oldClass(object)\r\n    cl <- cl[cl != \"data.frame\"]\r\n    if (0 < length(cl)) \r\n        cat(\"Classes\", paste(sQuote(cl), collapse = \", \"), \"and \")\r\n    cat(\"'data.frame':\\t\", nrow(object), \" obs. of  \", (p <- length(object)), \r\n        \" variable\", if (p != 1) \r\n            \"s\", if (p > 0) \r\n            \":\", \"\\n\", sep = \"\")\r\n    if (length(l <- list(...)) && any(\"give.length\" == names(l))) \r\n        invisible(NextMethod(\"str\", ...))\r\n    else invisible(NextMethod(\"str\", give.length = structure(FALSE, \r\n        from = \"data.frame\"), ...))\r\n}\r\n<bytecode: 0x00000000272095f8>\r\n<environment: namespace:utils>\r\n\r\n# Segunda forma (Sistema S3 apenas):\r\ngetS3method(\"str\", \"data.frame\")\r\n\r\n\r\nfunction (object, ...) \r\n{\r\n    if (!is.data.frame(object)) {\r\n        warning(\"str.data.frame() called with non-data.frame -- coercing to one.\")\r\n        object <- data.frame(object)\r\n    }\r\n    cl <- oldClass(object)\r\n    cl <- cl[cl != \"data.frame\"]\r\n    if (0 < length(cl)) \r\n        cat(\"Classes\", paste(sQuote(cl), collapse = \", \"), \"and \")\r\n    cat(\"'data.frame':\\t\", nrow(object), \" obs. of  \", (p <- length(object)), \r\n        \" variable\", if (p != 1) \r\n            \"s\", if (p > 0) \r\n            \":\", \"\\n\", sep = \"\")\r\n    if (length(l <- list(...)) && any(\"give.length\" == names(l))) \r\n        invisible(NextMethod(\"str\", ...))\r\n    else invisible(NextMethod(\"str\", give.length = structure(FALSE, \r\n        from = \"data.frame\"), ...))\r\n}\r\n<bytecode: 0x00000000272095f8>\r\n<environment: namespace:utils>\r\n\r\n# Terceira forma\r\nutils:::str.data.frame\r\n\r\n\r\nfunction (object, ...) \r\n{\r\n    if (!is.data.frame(object)) {\r\n        warning(\"str.data.frame() called with non-data.frame -- coercing to one.\")\r\n        object <- data.frame(object)\r\n    }\r\n    cl <- oldClass(object)\r\n    cl <- cl[cl != \"data.frame\"]\r\n    if (0 < length(cl)) \r\n        cat(\"Classes\", paste(sQuote(cl), collapse = \", \"), \"and \")\r\n    cat(\"'data.frame':\\t\", nrow(object), \" obs. of  \", (p <- length(object)), \r\n        \" variable\", if (p != 1) \r\n            \"s\", if (p > 0) \r\n            \":\", \"\\n\", sep = \"\")\r\n    if (length(l <- list(...)) && any(\"give.length\" == names(l))) \r\n        invisible(NextMethod(\"str\", ...))\r\n    else invisible(NextMethod(\"str\", give.length = structure(FALSE, \r\n        from = \"data.frame\"), ...))\r\n}\r\n<bytecode: 0x00000000272095f8>\r\n<environment: namespace:utils>\r\n\r\nOs métodos desenvolvidos no pacote base com asterisco dos métodos genéricos de grupo não são acessados pelas funções anteriores. Por fim, vamos criar uma pequena rotina, adaptado de Chambers (2016), para vermos quais e quantas funções genéricas primitivas existem no pacote base, a seguir.\r\n\r\n\r\n# Todos os objetos do pacote 'base'\r\ntodosobj <- objects(baseenv(), all.names = TRUE); \r\n# Mostre apenas os primeiros (ver todos remova 'head')\r\nhead(todosobj)\r\n\r\n\r\n[1] \"-\"         \"-.Date\"    \"-.POSIXt\"  \"!\"         \"!.hexmode\"\r\n[6] \"!.octmode\"\r\n\r\n# Quantos objetos no pacote 'base'?\r\nlength(todosobj)\r\n\r\n\r\n[1] 1373\r\n\r\n# Quais sao funcoes primitivas?\r\nobjprimitivos <- todosobj[sapply(todosobj,  function(x) is.primitive(get(x, envir = baseenv())))]\r\n# Mostre os primeiros (ver todos remova 'head')\r\nhead(objprimitivos)\r\n\r\n\r\n[1] \"-\"   \"!\"   \"!=\"  \"$\"   \"$<-\" \"%%\" \r\n\r\n# Quantos primitivos ('buitin' ou 'special')?\r\nlength(objprimitivos)\r\n\r\n\r\n[1] 204\r\n\r\n# Quais sao primitivos genéricos (Sistema S3)?\r\nehPrimitivaGenerica <- function(primitiva) {\r\n  fprimitiva <- getFunction(primitiva, mustFind = FALSE, where =asNamespace(\"base\"))\r\n  ehgenerica <- sloop::ftype(fprimitiva)\r\n  if (any(ehgenerica == \"generic\")) {\r\n    TRUE\r\n  } else FALSE\r\n}\r\n# Mostre os primeiros (ver todos remova 'head')\r\nhead(sapply(objprimitivos, ehPrimitivaGenerica))\r\n\r\n\r\n    -     !    !=     $   $<-    %% \r\n TRUE FALSE  TRUE  TRUE  TRUE  TRUE \r\n\r\n# Quantas sao primitivas genericas?\r\nsum(sapply(objprimitivos, ehPrimitivaGenerica))\r\n\r\n\r\n[1] 100\r\n\r\nEntendendo melhor a chamada UseMethod\r\n\r\n\r\nNa seção anterior, falamos que as funções genéricas do tipo closure, usam no corpo da função a chamada UseMethod. Esta é uma função primitiva, desenvolvida em C, porém usa a correspondência padrão de argumentos, com sintaxe dada por:\r\n\r\n\r\nUseMethod(generic, object)\r\n\r\n\r\n\r\nem que o argumento generic representa o nome da função genérica (obrigatório para utilizar na chamada de UseMethod), e o segundo argumento object é o objeto cuja classe determina o método a ser enviado para execução pela função genérica. O argumento objeto representa o primeiro argumento da função genérica, e portanto, na prática usamos apenas o argumento generic, uma vez que a função UseMethod se encarrega do resto.\r\nUma outra coisa importante é que a chamada da função UseMethod deve ser usada apenas no corpo de uma função, isto é, function(x) UseMethod(\"fgenerica\"). Caso contrário, ocorre o retorno de erro, isto é,\r\n\r\n\r\nfgenerica <- function(x) print(x)\r\nUseMethod(\"fgenerica\")\r\n\r\n\r\nError in eval(expr, envir, enclos): 'função' genérica não é uma função\r\n\r\nDesse modo, a forma correta de declarar a chamada de função Usemethod, baseado no exemplo anterior, deve ser apresentado como segue,\r\n\r\n\r\n# Primeira sintaxe\r\nfgenerica <- function(x) UseMethod(\"fgenerica\")\r\n# Segunda sintaxe\r\nfgenerica <- function(x) {\r\n  UseMethod(\"fgenerica\")\r\n}\r\n# Terceira sintaxe\r\nfgenerica <- \\(x) UseMethod(\"fgenerica\")\r\n# Quarta sintaxe\r\nfgenerica <- \\(x) {\r\n  UseMethod(\"fgenerica\")\r\n} \r\n\r\n\r\n\r\nPortanto, o objeto associado ao nome fgenerica é o que chamamos de função genérica. Nesse caso, o código interno de UseMethod examina o atributo class no objeto do primeiro argumento da função genérica, que no caso da função genérica fgenerica anterior, é o argumento x.\r\nA chamada UseMethod insere objetos especiais no ambiente de avaliação da função genérica, que são .Class, .Generic e .Method. Eles são responsáveis pelo despacho de método e os mecanismos de herança. O objeto .Class representa a classe do objeto (primeiro argumento da função genérica), .Generic é o nome da função genérica, e .Method é o nome do método usado. Poderá surgir também um outro objeto chamado .Group, quando funções genéricas são primitivas que se enquandram dentro das funções genéricas de grupo, visto mais a frente. De todo modo, isso é serviço para o R internamente e o usuário não precisará se preocupar. Vejamos o código a seguir, para observamos como podemos obter informações desses objetos.\r\n\r\n\r\ngenerico <- function(x) UseMethod(\"generico\")\r\n\r\ngenerico.metodo <- function(x) cat(\"Imprima o valor dos objetos .Generic, .Class e .Method, respectivamente:\\n\", .Generic, \"\\n\", .Class, \"\\n\", .Method)\r\n\r\nx <- 1; class(x) <- \"metodo\"\r\ngenerico(x)\r\n\r\n\r\nImprima o valor dos objetos .Generic, .Class e .Method, respectivamente:\r\n generico \r\n metodo \r\n generico.metodo\r\n\r\nUma coisa interessante, é que a função UseMethod por ser primitiva, não cria seu próprio ambiente, mas a sua chamada ocorre no ambiente de chamada, isto é, no ambiente de execução da função genérica. Além do mais, como o ambiente de chamada da função UseMethod é o ambiente de execução da função genérica, um código interno em UseMethod faz com que o ambiente de chamada seja finalizado após o método ter sido avaliado. Em outras palavras, o que for escrito no corpo da função genérica após a chamada UseMethod, não será executado nem avaliado. Vejamos um exemplo, para clarear o que estamos falando, que segue,\r\n\r\n\r\n# Funcao generica\r\nquem <- function(x) {\r\n  print(\"Isso pode ser impresso!\")\r\n  UseMethod(\"quem\")\r\n  ## Apos a Chamada UseMethod o ambiente eh encerrado!\r\n  print(\"Isso nao sera impresso!\")\r\n}\r\n## Metodo\r\nquem.eh <- function(x) print(\"Sou eu! (arg x)\")\r\n# Aplicacao:\r\npessoa <- \"ben\" # objeto sem atributo 'class'\r\nclass(pessoa) <- \"eh\"\r\nquem(pessoa)\r\n\r\n\r\n[1] \"Isso pode ser impresso!\"\r\n[1] \"Sou eu! (arg x)\"\r\n\r\nObservemos nesse caso, que a linha de comando no corpo da função genérica quem, antes da chamada UseMethod é avaliada e executada, porém, o que ocorre após não é executado, uma vez, que não é impresso no console o resultado \"Isso nao sera impresso!\". Logo, após a chamada de UseMethod e o envio de método para quem.eh e a ocorrência de sua execução, o ambiente de execução de quem é finalizado, do qual, print(\"Isso nao sera impresso!\") não é executado.\r\nCriando funções genéricas\r\n\r\n\r\nComo já mostrado em alguns exemplos na seção anterior, a forma de criar uma função genérica é por meio da inserção no corpo da criação de uma função, a chamada UseMethod. A ideia da função genérica, é encontrar o método específico para uma determinada instância de classe (objeto). Desse modo, criamos uma função genérica da seguinte forma:\r\n\r\n\r\n# Funcao generica\r\nquem <- function(x) {\r\n  UseMethod(\"quem\")\r\n}\r\n\r\n\r\n\r\nAssim, quem é uma função genérica. Esta função tem o objetivo, por meio de UseMethod, identificar a classe do objeto definido em x, e depois o envio de método, isto é, encontrar o método (objeto função) específico para a classe do objeto em x.\r\nClasse e classe implícita\r\n\r\n\r\nUsuário de outras linguagens que estudaram POO , por exemplo em Java, C++, Python, devem estar muito confusos, até esse momento, como o sistema S3 não tem uma forma usual de definir uma classe. Para isso, basta usar o atributo class em um objeto. Desse modo, este se torna uma instância da classe.\r\nJá vimos no módulo básico como verificar os atributos em um objeto, por meio da função attributes(). Vamos expandir um pouco mais, antes de passarmos para o atributo class. Vejamos a seguir, como inserir um ou mais de um atributo aos objetos, bem como eliminá-los.\r\n\r\n\r\n# Objeto\r\n(x <- 1:10)\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\n# Inserindo atributos em um objeto (1ª Forma)\r\nattr(x,\"dim\") <- c(2, 5) # 1º Atributo 'dim'\r\nattr(x,\"class\") <- \"ben\" # 2º Atributo 'ben'\r\nattr(x,\"nada\") <- \"1\"  # 3º Atributo 'nada'\r\n\r\n# Visualizar os atributos em x\r\nattributes(x)\r\n\r\n\r\n$dim\r\n[1] 2 5\r\n\r\n$class\r\n[1] \"ben\"\r\n\r\n$nada\r\n[1] \"1\"\r\n\r\n# Eliminando um determinado atributo ('nada')\r\nattr(x,\"nada\") <- NULL # Remove atribuindo 'NULL'\r\n\r\n# Visualizar os atributos em x, sem o atributo 'nada'\r\nattributes(x)\r\n\r\n\r\n$dim\r\n[1] 2 5\r\n\r\n$class\r\n[1] \"ben\"\r\n\r\n# Eliminar todos os atributos\r\nattributes(x) <- NULL\r\n\r\n# Visualizando x sem atributos\r\nattributes(x)\r\n\r\n\r\nNULL\r\n\r\n# Inserindo os atributos todos de uma vez\r\nmostattributes(x) <- list(dim = c(2, 5), class = \"ben\", nada = \"1\")\r\n\r\n# Verificando se um objeto apresenta determinado atributo, por exemplo, class='nada'\r\ninherits(x, \"nada\")\r\n\r\n\r\n[1] FALSE\r\n\r\n# Outra forma de inserir mais de um atributo\r\nx <- structure(1:10, dim = c(2, 5), class = \"ben\", nada = \"1\")\r\n\r\n# Casos especificos, podem ter funcoes proprias\r\n# para inserir atributos, por exemplo, 'class'\r\nattr(x,\"class\") <- NULL; attributes(x) # removendo o atributo 'class'\r\n\r\n\r\n$dim\r\n[1] 2 5\r\n\r\n$nada\r\n[1] \"1\"\r\n\r\nclass(x) <- \"ben\"; attributes(x)\r\n\r\n\r\n$dim\r\n[1] 2 5\r\n\r\n$nada\r\n[1] \"1\"\r\n\r\n$class\r\n[1] \"ben\"\r\n\r\nPercebemos que alguns atributos têm funções próprias, além do atributo class, temos dim, levels, names, dimnames, dentre outros.\r\nPara esse caso, iremos nos concentrar apenas no atributo class. Seguindo as próprias recomendações de Wickham (2019), e com razão, podemos utilizar qualquer conjunto de caracteres para nominar a classe de interesse. Porém, evitemos utilizar o ponto (“.”) como parte dos caracteres para nominar a classe, porque na próxima seção, veremos que o ponto é parte sintática da criação de um método, em que nominamos o método pela junção do nome da função genérica mais o nome da classe, separados por um ponto. E para evitar confusão, seguiremos essa sugestão.\r\nDesse modo, poderemos retirar um objeto como instância de uma classe, removendo o atributo class. Essa flexibilidade na prática, não apresenta grandes problemas, um vez que como afirmado por Wickham (2019), o R não impede do programador atirar no próprio pé, desde que ele não aponte a arma para o pé e puxe o gatilho. Mais a frente, apresentaremos algumas sugestões propostas por Wickham (2019), do qual adotaremos.\r\nUma outra característica do atributo class é que este pode ser um vetor de caracteres. Por exemplo, um vetor atômico do tipo fator é largamente utilizado na estatística, quando queremos representar os níveis de um tratamento, em que para usar a função aov(), função para a realização da análise de variância, um dos argumentos da função faz-se necessário ser um fator. Em algumas situações, além de ser um fator, é importante que os níveis sejam ordenados, na estatística descritiva, chamamos também de variáveis qualitativas ordinais.\r\nPara criarmos um vetor do tipo fator, usamos a função factor, e a sua ordenação, ou usamos em factor, o argumento ordered=TRUE, ou criamos um fator ordenado pela função ordered(). Usando este último, e associando a um nome, vamos perceber que o atributo class desse objeto é um vetor de comprimento 2, isto é,\r\n\r\n\r\n# Objeto e sua classe\r\nx <- ordered(1:5)\r\nclass(x)\r\n\r\n\r\n[1] \"ordered\" \"factor\" \r\n\r\n# Observando os atributos do objeto\r\nattributes(x)\r\n\r\n\r\n$levels\r\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\r\n\r\n$class\r\n[1] \"ordered\" \"factor\" \r\n\r\nEssa sequência será responsável pelo mecanismo de herança de métodos, que discutiremos mais a frente. No entanto, quando o objeto em R não é objeto POO, a função class pode retornar resultados equivocados quanto ao despacho do método. Por exemplo, vamos criar um vetor multidimensional, do tipo array, e verificarmos o que a função class retorna,\r\n\r\n\r\n# Objeto e sua classe\r\ny <- array(1:3, c(2,4))\r\nclass(y)\r\n\r\n\r\n[1] \"matrix\" \"array\" \r\n\r\n# Observando os atributos do objeto\r\nattributes(y)\r\n\r\n\r\n$dim\r\n[1] 2 4\r\n\r\nPorém, usando a função sloop::s3_class() ou .class2, perceberemos uma maior detalhamento, observemos:\r\n\r\n\r\ny <- array(1:3, c(2,4))\r\nsloop::s3_class(y)\r\n\r\n\r\n[1] \"matrix\"  \"integer\" \"numeric\"\r\n\r\n.class2(y)\r\n\r\n\r\n[1] \"matrix\"  \"array\"   \"integer\" \"numeric\"\r\n\r\nIsso é o que chamamos de classes implícitas aos objetos base, que não tem o atributo class definido. Segundo Wickham (2019), a classe implícita, obtida de objetos base, apresenta um vetor de três conjuntos de caracteres (strings):\r\narray ou matrix, se o objeto tiver dimensão;\r\nresultado de typeof, com algumas variações;\r\nnumeric, se os valores forem integer (inteiro) ou double (real).\r\nPara mostrarmos que a função class não retorna corretamente o despacho de método utilizado, isto é, para qual método a chamada da função genérica (UseMethod) foi executado, vamos utilizar a função sloop::s3_dispatch(). O despacho ocorrerá no método que contém (=>). Vejamos,\r\n\r\n\r\n# Imprimindo o despacho do objeto associado a 'y'\r\nsloop::s3_dispatch(print(y))\r\n\r\n\r\n   print.matrix\r\n   print.integer\r\n   print.numeric\r\n=> print.default\r\n\r\nObserve que o despacho ocorreu em print.default. O que fica mais claro, nesse segundo exemplo, o que queremos afirmar,\r\n\r\n\r\n# Objeto com classe implícita (sem atributo 'class')\r\nw <- 1\r\n# Imprimindo class\r\nclass(w)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\n# Verificando o despacho em 'print'\r\nsloop::s3_dispatch(print(w))\r\n\r\n\r\n   print.double\r\n   print.numeric\r\n=> print.default\r\n\r\nObservemos nesse caso que class retorna numeric, e o despacho ocorre em print.default, e não em print.numeric como verificado por class, ficando mais evidente o que falamos anteriormente. Na seção envio de método e mecanismos de herança, detalharemos um pouco mais sobre o assunto.\r\nPor fim, um último ponto que queríamos abordar são os termos técnicos como subclasse e superclasse. Anteriormente, vimos o objeto x <- ordered(1:5) que era um fator ordenado, e que o seu atributo class era um vetor de comprimento 2, isto é, \"ordered\" \"factor\". Dizemos que \"ordered\" é uma subclasse de \"factor\" porque o antecede no vetor, assim como \"factor\" é considerada uma superclasse para \"ordered\" porque o precede. A rigor, o sistema S3 não faz imposição nenhuma a estas classes, mas veremos na seção envio de método e mecanismos de herança, algumas estratégias para isso.\r\nMétodo S3\r\n\r\n\r\nO método no sistema S3 tem a seguinte estrutura no nome da função 'nome_funcao_generica'.'nome_classe'. Vamos supor que criamos uma classe para o objeto pessoa, com atributo class sendo eh, isto é,\r\n\r\n\r\n# Objeto\r\npessoa <- \"ben\"\r\n# Atribuindo classe ao objeto 'pessoa'\r\nclass(pessoa) <- \"eh\"\r\n\r\n\r\n\r\nComo falado no módulo básico, os atributos não modificam os valores dos objetos. Então até aqui, nada de novo. Para criarmos o método, baseado na função genérica quem, criada anteriormente, e na classe eh, criamos um método (objeto de modo function no R, ou tipo closure) quem.eh, isto é,\r\n\r\n\r\n## Metodo\r\nquem.eh <- function(x) print(\"Sou eu!\")\r\n\r\n\r\n\r\nAlgo muito importante no método é que a função deve ter os mesmos argumentos da função genérica, a menos que seja utilizado o objeto ... na função genérica. De um modo geral, apresentamos alguns aspectos e sugestões para a criação de um método, que destacamos:\r\nUm método deve ser criado considerando a existência de uma função genérica ou uma classe;\r\nO método deve apresentar os mesmos argumentos que a função genérica, e estes não se alteram no código interno da função genérica. Caso a função genérica apresente o objeto '...', o número de argumentos entre a função genérica e o método podem ser diferentes;\r\nReforçando, evitem nos nomes das funções genéricas ou classes o uso de pontos, porque o ponto é uma forma sintática de criarmos o nome do método, isso evitará problemas para o despacho correto. Um exemplo é a função t.test, que poderíamos imaginar que fosse um método, em que t é a função genérica e test a classe. Na realidade, t.test é uma função genérica, pois usa a chamada UseMethod. A criação desse objeto o R deve ter ocorrido, muito provavelmente, antes da implementação do sistema S3 a base do R;\r\nA chamada de função deve ser realizada, preferencialmente pela função genérica, porém nada impede de ser realizada pelo próprio método. Nesse caso, ocorrem alguns aspectos internos ao código, que chamaremos atenção mais a frente;\r\nNa criação de funções genéricas em pacotes, deem preferências ao nome das classes exatamente igual ao nome do pacote em desenvolvimento. Isso evitará possíveis conflitos de nomes de classes;\r\nFinalizado a criação do método, o que ocorrerá agora é que não precisaremos chamar o método pelo próprio método, mas pela função genérica, é o que chamamos de envio de método (ou despacho de método). Essa é a caixa preta da POO, devemos acreditar que isso ocorrerá, claro, se todo o processo de criação estiver correto.\r\nUm outro método que se sugere criar é o padrão (default), para que se a função genérica não encontrar o método específico, ela procurará pelo método padrão. Se não existir o método padrão, caso não encontre o método específico, a função genérica pode retornar uma mensagem de erro. Vejamos a implementação, a seguir.\r\n\r\n\r\n# Objeto\r\npessoa <- \"ben\"\r\n# Atribuindo classe ao objeto 'pessoa'\r\nclass(pessoa) <- \"eh\"\r\n## Metodo 'eh'\r\nquem.eh <- function(x) print(\"Sou eu!\")\r\n## Metodo 'padrao'\r\nquem.default <- function(x, y) print(\"??\")\r\n#-----------------------------------------\r\n# Aplicacao:\r\npessoa <- \"ben\" # objeto sem atributo 'class'\r\n# Usando a funcao generica\r\nquem(pessoa) # Aplicando o metodo padrao\r\n\r\n\r\n[1] \"??\"\r\n\r\n#--------\r\nclass(pessoa) <- \"eh\"\r\nquem(pessoa) # Aplicando o metodo eh\r\n\r\n\r\n[1] \"Sou eu!\"\r\n\r\nRetornando sobre a função UseMethod, quando inserimos os dois argumentos generic e object no corpo da função genérica, e definimos em object qual o objeto que a função observará o atributo class, a chamada de função UseMethod desconsiderará o primeiro argumento da função genérica, independente de ter um atributo class ou não. Vejamos um exemplo,\r\n\r\n\r\n# Funcao generica\r\nquem <- function(y) UseMethod(\"quem\", x)\r\n# Metodos\r\nquem.eh <- function(y) print(\"Sou eu!\")\r\nquem.outro <- function(y) print(\"Outro!\")\r\nquem.default <- function(y) print(\"Qualquer um!\")\r\n# Objeto em UseMethod sem o atributo 'class'\r\nx <- \"ben\"\r\n# Objeto no primeiro argument de fgenerica\r\ny <- \"ninguem\"\r\nclass(y) <- \"outro\"\r\n# O despacho ocorre em quem.default\r\nquem(y)\r\n\r\n\r\n[1] \"Qualquer um!\"\r\n\r\n# Removendo quem.defaul, a fgenerica retorna erro\r\nrm(\"quem.default\"); quem(y)\r\n\r\n\r\nError in UseMethod(\"quem\", x): método não aplicável para 'quem' aplicado a um objeto de classe \"character\"\r\n\r\nContudo, se o objeto definido em object não tiver o atributo class, e não houver um despacho para o método fgenerica.default, a função genérica (fgenerica) retorna um erro. Vejamos outro exemplo,\r\n\r\n\r\nquem <- function(y) UseMethod(\"quem\", x)\r\nquem.eh <- function(y) print(\"Sou eu!\")\r\nquem.outro <- function(y) print(\"Outro!\")\r\nquem.default <- function(y) print(\"Qualquer um!\")\r\n\r\n# Objeto em UseMethod\r\nx <- \"ben\"\r\nclass(x) <- \"eh\"\r\n# Objeto no primeiro argument de fgenerica\r\ny <- \"ninguem\"\r\nclass(y) <- \"outro\"\r\n# Executando a funcao generica\r\nquem(y)\r\n\r\n\r\n[1] \"Sou eu!\"\r\n\r\nUma coisa interessante que ocorre com a chamada UseMethod, que foge a exceção do padrão de chamadas das funções. Vejamos o código a seguir.\r\n\r\n\r\n# Funcao (Primeiro caso)\r\nh <- function(x, y) {\r\n  x <- 10\r\n  y <- 10\r\n  c(x = x, y = y)\r\n}\r\nx <- 1\r\ny <- 1\r\nh(x, y)\r\n\r\n\r\n x  y \r\n10 10 \r\n\r\n#----------------------------------------\r\n# Funcao generica e metodo (Segundo caso)\r\ng <- function(x, y) {\r\n  x <- 10\r\n  y <- 10\r\n  UseMethod(\"g\")\r\n}\r\n# metodo padrao\r\ng.default <- function(x, y) c(x = x, y = y)\r\n# Avaliacao\r\nx <- 1\r\ny <- 1\r\ng(x, y)\r\n\r\n\r\nx y \r\n1 1 \r\n\r\n#----------------------------------------\r\n# Funcao generica e metodo (Terceiro caso)\r\ng <- function(x) {\r\n  x <- 10\r\n  y <- 10\r\n  UseMethod(\"g\")\r\n}\r\n# metodo padrao\r\ng.default <- function(x) c(x = x, y = y)\r\n# Avaliacao\r\nx <- 1\r\ny <- 1\r\ng(x)\r\n\r\n\r\n x  y \r\n 1 10 \r\n\r\n#-----------------------------------------\r\n# Funcao generica e metodo (Quarto caso)\r\ng.default <- function(x) c(x = x, y = y)\r\n# Avaliacao\r\nx <- 1\r\ny <- 1\r\ng.default(x)\r\n\r\n\r\nx y \r\n1 1 \r\n\r\nObservemos no primeiro caso, em que definimos duas variáveis globais x <- 1 e y <- 1, ao serem utilizadas como argumentos da função h(), percebemos que após a chamada de h(), o ambiente de execução é criado temporariamente, e lá existe três instâncias x <- 10, y <- 10 e a chamada c(x = x, y = y), em que esta última busca por x e y, que é encontrado nas duas instâncias anteriores, e que portanto, sobrepõe a entrada dos argumentos. Logo, o resultado de h(x, y) será um vetor de comprimento 2, com valores 10 e 10, respectivamente.\r\nNo segundo caso, temos uma função genérica, e aqui surge algo meio inconsistente, aparentemente com a chamada UseMethod no corpo da função genérica. Mais vez, esta função nos surpreende, porque ela não permite a alteração dos argumentos definidos na função genérica com variáveis definidas no código interno dessa função, para posteriormente, seguir no despacho do método. Observemos na função genéricag(), que apesar de associado valores para os nomes x e y, todos iguais a 10, ao chamarmos g(), definimos para os seus argumentos x e y valores iguais a 1, e o que ocorre após a chamada dessa função é um vetor de 1s (uns). Isto siginifica, que as instâncias internas da função genérica, não alteraram os argumentos da função, e o despacho de método segue para g.default().\r\nNo terceiro caso, a função genérica apresenta apenas um argumento, x. Observemos nesse caso, que o código interno do método g.default() procura por um objeto associado a y, que é encontrado primeiro no ambiente de execução da função genérica, cujo resultado é 10. Porém, mesmo havendo um nome x associado ao valor 10, no ambiente de execução da função genérica, a chamada UseMethod preserva o argumento x = 1 definido em g(), que despacha para o método. Ao final, o resultado da função genérica é um vetor com valores 1 e 10, respectivamente.\r\nPor fim, o quarto caso, cuja a chamada de função ocorre diretamente pelo método e não pela função genérica. Nesse caso, o resultado será igual ao que ocorre com a função h(), porque não há o despacho pela chamada UseMethod, e portanto, não se preserva os argumentos da função no código interno da função genérica.\r\nRetornando a criação de métodos, uma forma de criar um método é por meio de funções primitivas genéricas. No fim da seção Funções genéricas, mostramos um código como encontrar as funções primitivas genéricas. O procedimento será o mesmo, isto é, determinado a função genérica, por exemplo, print, e posteriormente, definir uma classe específica para um objeto. Vamos implementar um método para print, a seguir.\r\n\r\n\r\n# Objeto classe 'comp'\r\nx <- 1:10; class(x) <- \"comp\"\r\n# Metodo 'comp'\r\nprint.comp <- function(x) {\r\n  x <- unclass(x)\r\n  cat(\"O comprimento de \", x, \" eh \", length(x))\r\n}\r\n# Aplicacao\r\nprint(x) # Metodo 'comp'\r\n\r\n\r\nO comprimento de  1 2 3 4 5 6 7 8 9 10  eh  10\r\n\r\nprint(unclass(x)) # Metodo 'defaut'\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nAlém de as funções internas/primitivas não terem a chamada UseMethod1, que podem dificultar a identificação de uma função genérica, alguns de seus métodos não estão exportadas pelo namespace do pacote base. Para verificarmos o código interno (instruções) desses métodos, podemos usar três funções: :::, getS3method ou getAnywhere, já comentados na seção Funções genéricas.\r\nPodemos usar a função utils::methods(), sloop::s3_methods_generic() ou sloop::s3_methods_class(). Com essas, funções podemos saber por meio do nome ou da função genérica ou pelo nome da classe, quais os métodos disponíveis. Vejamos pelo código a seguir, por exemplo usando a função genérica print, quais os métodos disponíveis, isto é,\r\n\r\n\r\n# Usando o nome da funcao generica\r\n# utils::methods(print) \r\n##  [1] print.acf*                        \r\n##  [2] print.AES*                        \r\n##  [3] print.all_vars*                   \r\n##  [4] print.anova*                      \r\n##  [5] print.ansi_string*                \r\n##  [6] print.ansi_style* \r\n##  ...\r\n# Usando agora a funcao s3_methods_generic\r\nsloop::s3_methods_generic(\"print\")\r\n\r\n\r\n# A tibble: 310 x 4\r\n   generic class    visible source             \r\n   <chr>   <chr>    <lgl>   <chr>              \r\n 1 print   acf      FALSE   registered S3method\r\n 2 print   AES      FALSE   registered S3method\r\n 3 print   all_vars FALSE   registered S3method\r\n 4 print   anova    FALSE   registered S3method\r\n 5 print   any_vars FALSE   registered S3method\r\n 6 print   aov      FALSE   registered S3method\r\n 7 print   aovlist  FALSE   registered S3method\r\n 8 print   ar       FALSE   registered S3method\r\n 9 print   Arima    FALSE   registered S3method\r\n10 print   arima0   FALSE   registered S3method\r\n# ... with 300 more rows\r\n\r\nObservamos, pelos pacotes instalados no computador do qual escrevemos esse material, apresenta para a função genérica print, 284 métodos. Porém, observamos que a última função sloop::s3_methods_generic() apresenta um maior detalhamento dos métodos, como por exemplo, a visibilidade de suas instruções no console, e ainda de qual pacote o método foi desenvolvido. Nesse caso, quando na coluna visible, um determinado método retorna FALSE, que é equivalente a um asterisco no resultado, por meio da função methods(), que significa que o método não é exportado do namespace do pacote, em que esse método foi desenvolvido. Contudo, mostramos anteriormente, alternativas de como acessar esses métodos.\r\nDe outro modo, poderíamos está interessados em métodos baseados em uma determinada classe. Nesse caso, vejamos um exemplo para a classe factor, a seguir.\r\n\r\n\r\n# Usando o nome da funcao generica\r\nutils::methods(class = factor) # Imprimindo os primeiros metodos para a classe 'factor'\r\n\r\n\r\n [1] [             [[            [[<-          [<-          \r\n [5] all.equal     Arith         as.character  as.data.frame\r\n [9] as.Date       as.list       as.logical    as.POSIXlt   \r\n[13] as.vector     c             cbind2        coerce       \r\n[17] Compare       droplevels    format        initialize   \r\n[21] is.na<-       length<-      levels<-      Logic        \r\n[25] Math          Ops           plot          print        \r\n[29] rbind2        relevel       relist        rep          \r\n[33] show          slotsFromS3   summary       Summary      \r\n[37] xtfrm        \r\nsee '?methods' for accessing help and source code\r\n\r\n# Usando agora a funcao s3_methods_generic\r\nsloop::s3_methods_class(\"factor\")\r\n\r\n\r\n# A tibble: 28 x 4\r\n   generic       class  visible source\r\n   <chr>         <chr>  <lgl>   <chr> \r\n 1 [             factor TRUE    base  \r\n 2 [[            factor TRUE    base  \r\n 3 [[<-          factor TRUE    base  \r\n 4 [<-           factor TRUE    base  \r\n 5 all.equal     factor TRUE    base  \r\n 6 as.character  factor TRUE    base  \r\n 7 as.data.frame factor TRUE    base  \r\n 8 as.Date       factor TRUE    base  \r\n 9 as.list       factor TRUE    base  \r\n10 as.logical    factor TRUE    base  \r\n# ... with 18 more rows\r\n\r\nPara o caso dos genéricos de grupo, sabemos que os grupos Math, Ops, Summary, e Complex não são objetos R, porém esses nomes podem ser usados para a criação de métodos S3. Uma outra coisa interessante nessa situação é que os objetos .Generic, .Class e .Methods, sofrem uma pequena variação da forma convencional dos nomes da função genérica, da classe e do método, respectivamente. Vamos tomar como exemplo a função sum() que pertence ao grupo Summary, e vamos criar um método para o grupo Summary, a seguir.\r\n\r\n\r\n# Metodo ben\r\nSummary.ben <- function(..., na.rm=FALSE) {\r\n  c(.Generic, .Class, .Method)\r\n}\r\n# Vamos aplicar a funcao sum em um obj de classe 'ben'\r\nx <- structure(1, class = \"ben\")\r\nsum(x)\r\n\r\n\r\n[1] \"sum\"         \"ben\"         \"Summary.ben\"\r\n\r\nObservamos nesse primeiro exemplo que o objeto .Generic acaba recebendo o nome da função genérica do grupo e não o nome do grupo, como poderíamos pensar. Porém, o nome do método acaba sendo relacionado com o nome do grupo e não da função genérica aplicada, nesse caso. No que isso interfere na semântica do sistema S3? Tudo! Vejamos um outro exemplo, com o código a seguir.\r\n\r\n\r\n# Metodo\r\nSummary.ben <- function(..., na.rm=FALSE) {\r\n  \"Eu sou do grupo 'Summary'\"\r\n}\r\n# Objeto de classe 'ben'\r\nx <- structure(2, class = \"ben\")\r\n# Genericos do grupo 'Summary'\r\nall(x); any(x); sum(x); prod(x); min(x); max(x); range(x) \r\n\r\n\r\n[1] \"Eu sou do grupo 'Summary'\"\r\n[1] \"Eu sou do grupo 'Summary'\"\r\n[1] \"Eu sou do grupo 'Summary'\"\r\n[1] \"Eu sou do grupo 'Summary'\"\r\n[1] \"Eu sou do grupo 'Summary'\"\r\n[1] \"Eu sou do grupo 'Summary'\"\r\n[1] \"Eu sou do grupo 'Summary'\"\r\n\r\nComo criamos o método a partir do nome do grupo, todas as funções genéricas desse grupo despacharão nesse método, e o resultado para todas as funções será o mesmo. Um outro recurso, seria utilizar a função switch() para diferenciar o despache de método, apesar desse envio ser no próprio Summary.ben(). Vejamos o próximo código para esse elucidar o que acabamos de falar.\r\n\r\n\r\n# Metodo\r\nSummary.ben <- function(..., na.rm=FALSE) {\r\n  switch(.Generic,\r\n         all = paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic),\r\n         any = paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic),\r\n         sum = paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic),\r\n         prod = paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic),\r\n         min = paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic),\r\n         max = paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic),\r\n         range = paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic))\r\n  \r\n}\r\n# Objeto de classe 'ben'\r\nx <- structure(2, class = \"ben\")\r\n# Genericos do grupo 'Summary'\r\nall(x); any(x); sum(x); prod(x); min(x); max(x); range(x) \r\n\r\n\r\n[1] \"Eu sou do grupo 'Summary', mas generico: all\"\r\n[1] \"Eu sou do grupo 'Summary', mas generico: any\"\r\n[1] \"Eu sou do grupo 'Summary', mas generico: sum\"\r\n[1] \"Eu sou do grupo 'Summary', mas generico: prod\"\r\n[1] \"Eu sou do grupo 'Summary', mas generico: min\"\r\n[1] \"Eu sou do grupo 'Summary', mas generico: max\"\r\n[1] \"Eu sou do grupo 'Summary', mas generico: range\"\r\n\r\nOu ainda, poderíamos ter criado um método apenas para uma função genérica específica do grupo. Desse modo, não criamos o método a partir do nome do grupo, mas da própria função. Vejamos o próximo código.\r\n\r\n\r\n\r\n\r\n\r\n# Metodo para o generico 'min'\r\nmin.ben <- function(..., na.rm = FALSE) paste0(\"Eu sou do grupo 'Summary', mas generico: \", .Generic)\r\n# Objeto de classe 'ben'\r\nx <- structure(2, class = \"ben\")\r\n# Generico do grupo 'Summary': min()\r\nmin(x)\r\n\r\n\r\n[1] \"Eu sou do grupo 'Summary', mas generico: min\"\r\n\r\n# Ja com um outro generico de 'Summary', o resultado eh diferente\r\nmax(x)\r\n\r\n\r\n[1] 2\r\n\r\nUma vez entendido a criação de método, vamos entender na sequência, os detalhes que a chamada UseMethod() realiza para o envio de método e os mecanismos de herança e como esse processo ocorre para as funções genéricas primitivas e os grupos genéricos, que não apresentam a chamada UseMethod() en seu código interno.\r\nEnvio de método e mecanismo de herança\r\nComo falado anteriormente, o atributo class em um objeto, pode ser um vetor de strings, e ter diversos nomes. Já comentamos anteriormente sobre o envio de método ou também podemos chamar como despacho de método.\r\nEnvio ou despacho de método\r\n\r\n\r\nA ideia do envio de método e a criação de um vetor de potenciais nomes de métodos, como por exemplo esse:\r\n\r\n\r\nx <- 1:10\r\npaste0(\"generic\", \".\", c(class(x), \"default\"))\r\n\r\n\r\n[1] \"generic.integer\" \"generic.default\"\r\n\r\nE desse modo a chamada UseMethod se encarregará de verificar quais os métodos que existem. Pode haver mais de uma existência de método, será chamado o primeiro método na sequência de métodos existentes. Para verificar isso, podemos usar a função sloop::s3_dispatch(), isto é,\r\n\r\n\r\n# Objeto de classe 'data.frame'\r\nx <- data.frame() \r\n# Despacho (envio) do generico 'print'\r\nsloop::s3_dispatch(print(x))\r\n\r\n\r\n=> print.data.frame\r\n * print.default\r\n\r\nO resultado da chamada sloop::s3_dispatch() pode apresentar três símbolos antes dos potenciais nomes de métodos:\r\n=>: este símbolo indica que a função genérica despachou no referido método;\r\n*: este símbolo indica que este método existe, mas a função genérica não despachou nele;\r\n->: indica o método chamado subjacente, após o método com o símbolo => ter sido chamado. Isso ocorre, por no método representado por \"=>\" existe uma função nominada por NextMethod que faz o serviço de chamar o próximo método. Veremos esse ponto mais a frente.\r\nNo código anterior, vimos os dois símbolos => e *. Interpretamos que a função genérica print(x) despachou em print.data.frame(), mas que o método print.default existia, porém não foi utilizado.\r\nVejamos o próximo código para entendermos o que significa o símbolo (->) na saída da função sloop::s3_dispatch().\r\n\r\n\r\n# Funcao generica\r\nquem_sou_eu <- function(x, ...){\r\n  UseMethod(\"quem_sou_eu\")\r\n}\r\n\r\n# Metodo numero natural\r\nquem_sou_eu.numero_natural <- function(x, ...){\r\n  message(\"Eu sou um numero natural\")\r\n  NextMethod(\"quem_sou_eu\")\r\n}\r\n\r\n# Metodo numerico\r\nquem_sou_eu.numerico <- function(x, ...){\r\n  message(\"Eu sou numerico\")\r\n}\r\n\r\nx <- 1:10\r\n\r\nclass(x) <- c(\"numero_complexo\",\"numero_natural\",\"numerico\")\r\n\r\nsloop::s3_dispatch(quem_sou_eu(x))\r\n\r\n\r\n   quem_sou_eu.numero_complexo\r\n=> quem_sou_eu.numero_natural\r\n-> quem_sou_eu.numerico\r\n   quem_sou_eu.default\r\n\r\nObservemos que a função genérica quem_sou_eu() despachou no método quem_sou_eu.numero_natural, símbolo (=>), mas internamente nesse método, nós temos a chamada NextMethod() que invoca o próximo método. Nesse caso foi quem_sou_eu.numerico, com o símbolo (->). Os demais métodos não existem, pois não apresentam o asterisco (*). Entenderemos um pouco mais sobre a chamada NextMethod() mais a frente.\r\nFunções primitivas genéricas e genéricos de grupo\r\nAnteriormente falamos sobre as funções primitivas genéricas. Dissemos que eram funções escritas em linguagem C, não apresentavam as três composições básicas de uma função: formals(), body(), environment(), e que não apresentavam internamente a chamada UseMethod. Então, se o objeto inserido no primeiro argumento dessas funções não tiverem o atributo class (objeto base), o despacho para métodos não ocorrerá, isto é, as funções primitivas genéricas não usarão as classes implícitas. Isso porque, as funções que se comportam de modo diferente para diferentes tipos de objetos base, apresentam essa característica não porque formam um sistema POO, mas porque estas funções primitivas usam instruções da linguagem C do tipo switch. Nós temos a versão da função switch() em R, e foi comentada no módulo Básico. Vejamos a função primitiva genérica cbind(), como exemplo a seguir.\r\n\r\n\r\n# Eh primitiva generica?\r\nsloop::is_s3_generic(\"cbind\")\r\n\r\n\r\n[1] TRUE\r\n\r\n# Onde ocorre o despacho?\r\nsloop::s3_dispatch(cbind(1:10))\r\n\r\n\r\n   cbind.integer\r\n   cbind.numeric\r\n   cbind.default\r\n=> cbind (internal)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nPercebemos nesse caso, como o objeto 1:10 não apresenta o atributo class, a função interna foi a chamada, e nenhuma das classes implícitas são utilizadas. Nesse caso, apenas função primitiva/interna é utilizada.\r\nNo caso dos genéricos de grupo, sabemos que o nome dos grupos podem fazer parte da criação do método e o despacho de todos os genéricos serão realizados nesse método. Mas também, podemos criar métodos específicos para um determinado genérico de um grupo, sem influenciar no despacho dos demais genéricos. Nesses casos, os genéricos de grupo procurarão inicialmente pelos métodos relacionados as funções primitivas genéricas (fpgenerica.classe), e não achando, procurará pelos métodos relacioado aos nomes dos grupos (grupo.classe), não achando, despachará na função primitiva. Pode haver também o mecanismo de herança, por meio da chamada NextMethod(). Vejamos o código a seguir para o primeiro caso.\r\n\r\n\r\n# Objeto de classe factor\r\nx <- factor(1:5)\r\n# Verificando o despacho de sqrt() do grupo 'Math'\r\nsloop::s3_dispatch(sqrt(x))\r\n\r\n\r\n   sqrt.factor\r\n   sqrt.default\r\n=> Math.factor\r\n   Math.default\r\n * sqrt (internal)\r\n\r\n# Verificando o metodo Math.factor()\r\nMath.factor\r\n\r\n\r\nfunction (x, ...) \r\nstop(gettextf(\"%s not meaningful for factors\", sQuote(.Generic)))\r\n<bytecode: 0x0000000024c9a2d0>\r\n<environment: namespace:base>\r\n\r\nObservamos nessa situação que o objeto do tipo factor, apesar de ser um resultado numérico, não se comporta como numérico. Nesse caso, calcular a raiz quadrado de cada elemento não será possível, ou qualquer outra operação do grupo 'Math', e assim, uma proteção para esse caso é assegurado logo no método Math.factor() (=>) com a chamada stop(). A ideia da função gettextf()2 no ambiente Ré similar a printf() para a linguagem C. No despacho, percebemos que existe a função primitiva (*) sqrt(), porém nesse caso, não foi utilizada.\r\nPara os demais casos, podemos observar o código na sequência, para entendermos o que falamos anteriormente.\r\n\r\n\r\n# Primeira situacao:\r\n# ------------------\r\n# Metodo de grupo\r\nSummary.ben <- function(..., na.rm=FALSE) {\r\n  \"Eu despacho em todo grupo 'Summary'\"\r\n}\r\n# Objeto de classe 'ben'\r\nx <- structure(TRUE, class = \"ben\")\r\n# Despacho para funcao 'all'\r\nsloop::s3_dispatch(all(x))\r\n\r\n\r\n   all.ben\r\n   all.default\r\n=> Summary.ben\r\n   Summary.default\r\n * all (internal)\r\n\r\n####################\r\n# Segunda situacao:\r\n# ------------------\r\n# Metodo apenas para a funcao 'all'\r\nall.ben <- function(..., na.rm=FALSE) {\r\n  \"Eu despacho apenas para 'all.ben'\"\r\n}\r\n# Metodo de grupo\r\nSummary.ben <- function(..., na.rm=FALSE) {\r\n  NextMethod(.Generic)\r\n}\r\n# Objeto de classe 'ben'\r\nx <- structure(TRUE, class = \"ben\")\r\n# Despacho para funcao 'all'\r\nsloop::s3_dispatch(all(x))\r\n\r\n\r\n=> all.ben\r\n   all.default\r\n * Summary.ben\r\n   Summary.default\r\n * all (internal)\r\n\r\n###################\r\n# Terceira situacao:\r\n# ------------------\r\n# Metodo apenas para a funcao 'all'\r\nall.ben <- function(..., na.rm=FALSE) {\r\n  NextMethod(.Generic)\r\n}\r\n# Metodo de grupo\r\nSummary.ben <- function(..., na.rm=FALSE) {\r\n  \"Eu passei por 'all.ben', mas terminei em 'Summary.ben'\"\r\n}\r\n# Objeto de classe 'ben'\r\nx <- structure(TRUE, class = \"ben\")\r\n# Despacho para funcao 'all'\r\nsloop::s3_dispatch(all(x))\r\n\r\n\r\n=> all.ben\r\n   all.default\r\n-> Summary.ben\r\n   Summary.default\r\n * all (internal)\r\n\r\n###################\r\n# Quarta situacao:\r\n# ------------------\r\n# Metodo apenas para a funcao 'all'\r\nall.ben <- function(..., na.rm=FALSE) {\r\n  NextMethod(.Generic)\r\n}\r\n# Metodo de grupo\r\nSummary.ben <- function(..., na.rm=FALSE) {\r\n  NextMethod(.Generic)\r\n}\r\n# Objeto de classe 'ben'\r\nx <- structure(TRUE, class = \"ben\")\r\n# Despacho para funcao 'all'\r\nsloop::s3_dispatch(all(x))\r\n\r\n\r\n=> all.ben\r\n   all.default\r\n-> Summary.ben\r\n   Summary.default\r\n-> all (internal)\r\n\r\nA primeira situação o envio de método ocorre para Summary.ben() (=>), se verifica a função primita all() (*), porém não executada. Na segunda situação, observamos a existência do método Summary.ben() (*) e a função primitiva all() (*), porém o descpacho ocorre em all.ben() (=>). Na terceira situação, o despacho ocorre em all.ben() (=>), que intermanente chama NextMethod(), delegando para Summary.ben() (->). Por fim, na quarta situação o envio de método ocorre em all.ben() (=>) que delega para Summary.ben (->), que delega para a função primitiva all() (->).\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChamada NextMethod()\r\nVimos anteriormente que a chamada UseMethod() é responsável pelo envio de método, isto é, dado um objeto com um atributo class inserido no primeiro argumento do genérico, a chamada UseMethod() procurará pelo método específico dessa classe. Contudo, falamos anteriormente, que o atributo class pode ser um vetor de caracteres. Dessa forma é que entra a chamada NextMethod(). A ideia é aplicar o genérico para o próximo método. Já mostramos anteriormente essa semântica, e vamos reforçar com o código a seguir.\r\n\r\n\r\n# Generico\r\nfgenerica <- function(x) UseMethod(\"fgenerica\")\r\n# Metodo 1\r\nfgenerica.clas1 <- function(x) {\r\n  print(\"Despache para o metodo 1\")\r\n  NextMethod(\"fgenerica\")\r\n}\r\n# Metodo 2\r\nfgenerica.clas2 <- function(x) print(\"Despache para o metodo 2\")\r\n############\r\n# Avaliacao:\r\n# Objeto clas1 e clas2\r\nfgenerica(structure(2, class = c(\"clas1\", \"clas2\")))\r\n\r\n\r\n[1] \"Despache para o metodo 1\"\r\n[1] \"Despache para o metodo 2\"\r\n\r\n# Objeto clas2\r\nfgenerica(structure(2, class = c(\"clas2\")))\r\n\r\n\r\n[1] \"Despache para o metodo 2\"\r\n\r\n# Despacho\r\nsloop::s3_dispatch(fgenerica(structure(2, class = c(\"clas1\", \"clas2\"))))\r\n\r\n\r\n=> fgenerica.clas1\r\n-> fgenerica.clas2\r\n   fgenerica.default\r\n\r\nO que caracteriza a chamada NextMethod() é a ocorrência do símbolo (->) na saída em sloop::s3_dispatch(). O que essa chamada de função faz é executar o próximo método.\r\nDe modo formal, apresentamos a sintaxe como NextMethod(generic, object, ...). Se nenhum argumento for adionado em NextMethod(), os argumentos serão os mesmos em quantidade, ordem e nome do método corrente, e por consequência também dos argumentos do genérico. Outra coisa interessante é que por meio de '...', podemos inserir mais argumentos para essa chamada, do qual todos os argumentos são anexados em uma lista como promessas, isto é, os argumentos não são avaliados. Porém se foram avaliados no ambiente atual ou no ambiente anterior, permanecerão avaliados. Vejamos alguns outros aspectos, dos quais alguns foram citados por Chambers and Hastie (1993):\r\nOs argumentos são transmitidos do método corrente para o método herdado com seus valores atuais no momento em que NextMethod() é chamado;\r\nUm objeto com mesmo nome de um dos argumentos (até mesmo o primeiro argumento) do método corrente, definido no ambiente de chamada de NextMethod(), pode ser passado para o método herdado, sendo um valor diferente definido no argumento do método corrente. No caso da chamada UseMethod(), é preservado o valor definido nos argumentos do genérico;\r\nAlterar o primeiro argumento do genérico em uma chamada NextMethod() afeta os argumentos recebidos no método herdado, mas não na escolha desse método.\r\nA avaliação preguiçosa dos argumentos continuam. Se um argumento não foi avaliado, continua não avaliado;\r\nArgumentos ausentes permanecem ausentes no método herdado;\r\nAlguns objetos definidos no método atual, se informados em NextMethod(), passarão para o método herdado, desde esse objeto seja um argumento do método herdado;\r\nO ambiente de chamada de NextMethod() não é encerrado após finalizado a chamado do método herdado, como ocorre com UseMethod();\r\nA chamada NextMethod() é importante em algumas situações para evitar um loop infinito.\r\nApresentaremos a seguir, um código para exemplificar esses pontos. E um código seguinte será específico para o último ponto.\r\n\r\n\r\n# Generico\r\nfgenerica <- function(x, ...) UseMethod(\"fgenerica\")\r\n# Metodo 1\r\nfgenerica.clas1 <- function(x, z = faux(), ...) {\r\n  x <- 3\r\n  y <- 5\r\n  NextMethod(generic = .Generic, object = x, y, z)\r\n  cat(\"Passei pelo metodo 1\")\r\n}\r\n# Metodo 2\r\nfgenerica.clas2 <- function(x, y, ...) {\r\n  cat(\"Chegando no metodo 2, consigo imprimir x:\", x, \"e y:\", y, \"\\n\")\r\n  cat(\"Existe classe em x? \", print(attr(x, \"class\")), \"\\n\")\r\n  \r\n}\r\n############\r\n# Avaliacao:\r\n# Chamada do generico com objeto  de classe: clas1 e clas2\r\nfgenerica(structure(2, class = c(\"clas1\", \"clas2\")))\r\n\r\n\r\nChegando no metodo 2, consigo imprimir x: 3 e y: 5 \r\nNULL\r\nExiste classe em x?  \r\nPassei pelo metodo 1\r\n\r\nObservemos no momento da chamada NextMethod() no método fgenerica.clas1() que o objeto do primeiro argumento x do genérico foi alterado [(1), (2) e (3)]. Inicialmente tinha o valor 2 com atributo class, porém no ambiente de execução do método fgenerica.clas1(), um objeto associado ao mesmo nome x <- 3 foi criado e passado para NextMethod(). Nesse caso, esse novo objeto não apresenta mais o atributo class (Observe a saída: Existe classe em x?  NULL), e desse modo é repassado para o método herdado, porém observemos que o fato de não ter o atributo class não prejudicou nas escolhas dos métodos (3).\r\nAinda no método fgenerica.clas1() surge um argumento z que apresenta uma função faux() não existente, isso é a característica de avaliação preguiçosa dos argumentos por parte das funções (4), isso significa, que enquanto esse argumento não for chamado internamente, ele não será avaliado. E isso pode ser verificado, pois o genérico retorna o resultado esperado, sem mensagem de erros.\r\nUm outro ponto importante é o objeto y definido no corpo do método fgenerica.clas1(), que não definido como seu argumento, mas sim como argumento na chamada NextMethod(), do qual pode ser repassada para o método herdado (6). Isso foi possível também porque y também entrou como argumento para o método fgenerica.clas2().\r\nDiferentemente de UseMethod(), a chamada NextMethod() não encerra o ambiente de chamada (7). Isso pode ser verificado com o resultado do genérico imprimindo Passei pelo metodo 1, isto é, o genérico despacha em fgenerica.clas1() que herda o método fgenerica.clas2(), por meio de NextMethod(). Após o fechamento de fgenerica.clas2() e posteriormente da chamada NextMethod(), o ambiente de execução de fgenerica.clas1() continua a executar as suas instruções, do qual segue com a execução de cat(\"Passei pelo metodo 1\"), e posteriormente ocorre o seu fechamento.\r\nPor fim, a justificativa do último ponto, vamos apresentar uma aplicação muito importante que ocorre com a função primitiva genérica [. Por exemplo, se tivermos um vetor associado ao nome x com um atributo class e desejarmos o segundo elemento, isto é, x[2]. Este resultado não preserva a classe de x. Para isto, precisamos criar um método para esse genérico, apresentado a seguir.\r\n\r\n\r\n# Criando um objeto de classe 'cpf'\r\nnew_cpf <- function(x) {\r\n  structure(x, class = \"cpf\")\r\n}\r\n# Metodo print para 'cpf'\r\nprint.cpf <- function(x, ...) {\r\n  x <- as.character(x)\r\n  substr(x, 3, 9) <- \"*******\"\r\n  print(x)\r\n}\r\n# Criando e imprimindo x\r\nx <- new_cpf(c(12345678912,\r\n               78945612323,\r\n               98765432112)); x\r\n\r\n\r\n[1] \"12*******12\" \"78*******23\" \"98*******12\"\r\n\r\n# Selecionando o segundo cpf\r\nx[2]\r\n\r\n\r\n[1] 78945612323\r\n\r\nObservamos nesse exemplo que a função primitiva [ é um genérico mas que não tem o método para classe cpf, e por isso retorno o valor do cpf na íntegra, algo que não queríamos como resultado. Nesse caso, precisamos criar um método para tal, sendo apresentado três soluções a seguir.\r\n\r\n\r\n# Primeira solucao (menos eficiente pq cria copia de x)\r\n`[.cpf` <- function(x, i) {\r\n  x <- unclass(x)\r\n  new_cpf(x[i])\r\n}\r\nx[2]\r\n\r\n\r\n[1] \"78*******23\"\r\n\r\n# Segunda solucao\r\n`[.cpf` <- function(x, i) {\r\n  class(x) <- NULL\r\n  new_cpf(x[i])\r\n}\r\nx[2]\r\n\r\n\r\n[1] \"78*******23\"\r\n\r\n# Terceira solucao\r\n`[.cpf` <- function(x, i) {\r\n  new_cpf(NextMethod())\r\n}\r\nx[2]\r\n\r\n\r\n[1] \"78*******23\"\r\n\r\n# Quarta solucao: Loop infinito\r\n`[.cpf` <- function(x, i) {\r\n  new_cpf(x[i])\r\n}\r\nx[2]\r\n\r\n\r\nError: avaliação aninhada demais; recursão infinita / options(expressions=)?\r\n\r\nUma primeira tentativa, resolve o problema, porém perdemos eficiência por fazer uma cópia do objeto x. A segunda e terceira tentativas, são mais eficientes, sendo que a última usa a chamada NextMethod(). Essa chamada procura pelo próximo método que é a própria função primitiva, que ao ser executada retorna o resultado, e este entra como um argumento da função new_cpf(). Então, o ocorre a chamada new_cpf() que retorna novamente um objeto de classe cpf. Por fim, a quarta tentativa gera um loop infinito, porque ao criar o método [.cpf(), percebemos que internamente usamos a função primitiva genérica [, e como o objeto x tem o atributo class igual a cpf, este procurará novamente o método, e assim por diante.\r\nNa sequência, veremos em detalhes o mecanismo de herança de modo como o UseMethod() despacha para um determinado método, como também a chamada NextMethod() é usada para a busca do método herdado.\r\nMecanismo de herança\r\n\r\n\r\nO mecanismo de herança ocorre de acordo com os elementos do vetor de atributo class pela função genérica. Esse vetor pode ter qualquer comprimento. Além desses elementos, temos ainda uma pseudoclasse chamada default que não aparece no atributo class. O genérico procurará inicialmente pelo método para o primeiro elemento do vetor do atributo class, se o método para essa classe não existir, procurará pelo método observando pelo segundo elemento, e assim por diante. Caso o genérico percorra por todo o vetor, e não encontre o método para a classe desejada, o despacho ocorre no método default. E por fim, se este método não existir, o genérico retornará uma mensagem de erro erro.\r\nO mecanismo de herança, ocorre por meio da chamada NextMethod(). Vejamos o código a seguir.\r\n\r\n\r\n# Construtor\r\nnew_intparord <- function(x, ..., inteiro = FALSE, ordenado = FALSE) {\r\n  stopifnot(is.numeric(x))\r\n  classe = c(\"par\", \"ordenado\", \"inteiro\")\r\n  if (inteiro) {\r\n    classe <- c(\"inteiro\")\r\n  }\r\n  if (ordenado) {\r\n    classe = c(\"ordenado\", \"inteiro\")\r\n  }\r\n  structure(x, class = classe)\r\n}\r\n\r\n# Método inteiro para o generico print\r\nprint.par <- function(x, ...) {\r\n  NextMethod(.Generic, x = x[!as.logical(trunc(x) %% 2)])\r\n}\r\n\r\n# Método ordenado para o generico print\r\nprint.ordenado <- function(x, ...) {\r\n  NextMethod(.Generic, x = sort(x))\r\n}\r\n\r\n# Método inteiro para o generico print\r\nprint.inteiro <- function(x, ...) {\r\n  attributes(x) <- NULL\r\n  print(as.integer(x))\r\n  invisible(x)\r\n}\r\n\r\nx <- new_intparord(x = 10:1); x\r\n\r\n\r\n[1]  2  4  6  8 10\r\n\r\nattributes(x)\r\n\r\n\r\n$class\r\n[1] \"par\"      \"ordenado\" \"inteiro\" \r\n\r\nCriamos uma função chamada de new_intparord, que é um construtor de instâncias de uma classe. Essa estratégia é importante principalmente quando temos classes com características mais complexas. O objeto criado desse construtor tem um atributo class de comprimento até de três classes: \"par\", \"ordenado\" e \"inteiro\". Isto é, a classe mais geral é \"inteiro\" e a chamamos no contexto de POO de superclasse, uma vez que é uma classe que abrange características mais gerais. Essa classe representa os números inteiros. A próxima classe é \"ordenada\", que é uma organização dos números inteiros. Essa classe herda de \"inteiro\" a característica de que além de ordenado, esses elementos devem ser número inteiros. Essa herança ocorre por meio de NextMethod(). Por fim, a classe \"par\" que representa apenas os números pares, mas também, herda a sua ordenação da classe \"ordenado\", que por sua vez, herda a condição dos número serem inteiros da classe \"inteiro\". Nessa situação, fica claro que \"par\" é uma subclasse de \"inteiro\", uma vez que representa um grupo mais restrito da classe mais abrangente. De um modo geral, dizemos que uma subclasse são as classes mais à esqueda no atributo class e a superclasse mais à direita.\r\nEsse exemplo nos mostra a importância da chamada NextMethod() para o mecanismo de herança. Mais ainda, a rigor o sistema S3 não impõe restrições nenhuma entre subclasses e superclasses. Porém, o desenvolver deve pensar nesse aspecto, uma vez que em termos práticos, a construção das ideias se tornam mais fáceis na criação de suas rotinas. Não estamos falando necessariamente que a implementação de subclasses e superclasses seja algo fácil. Para contextualizar, percebamos que o objeto x do código anterior, desejássemo a impressão do segundo elemento, usaríamos x[2]. Retornaríamos o valor correto, porém a sua classe não seria presevada. Por quê? Porque a função primitiva genérica [ não tem esses métodos implementados, isto é, [.par, [.ordenado e [.inteiro. Assim, também vale a aplicação do objeto x para os demais genéricos. Vejamos em código o que acabamos de falar.\r\n\r\n\r\nx <- new_intparord(x = 10:1); class(x); x[2]; class(x[2])\r\n\r\n\r\n[1] \"par\"      \"ordenado\" \"inteiro\" \r\n[1] 9\r\n[1] \"integer\"\r\n\r\nCada subclasse que for inserida no objeto x irá exigir sempre mais trabalho para que o desenvolve, porque necessita garantir teoricamente a herança.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nEntendendo um pouco mais sobre objetos\r\nDepois de termos abordado a ideia de objetos no sentido de programação orientada a objetos, retornamos a ideia inicial abordada no módulo básico, do tipo do objeto no sentido da forma de como seus valores são organizados. Afirmamos que tínhamos a estrutura mais de objeto é um vetor, conhecidos como estruturas atômicas pois os seus valores são de mesmo modo (character, logical, numeric, complex e raw). Falamos também dos objetos do tipo lista, que armazenam outros objetos que podem ter modos diferentes.\r\nEstruturas atômicas e recursivas\r\n\r\n\r\nA ideia de estrutura atômica ficou bem claro. Temos agora uma outra ideia que é a estrutura recursiva, que representa a condição dos objetos conterem elementos de sua própria estrutura. Por exemplo, uma lista pode ter um objeto que é uma lista, uma função também é uma estrutura recursiva, porque seus argumentos podem ser uma função, e assim por diante.\r\nPara sabermos se um objeto é atômico ou recursivo, usamos as funções respectivamente, is.atomic() e is.recursive(). Assim, vejamos o código a seguir.\r\n\r\n\r\n# Funcao auxiliar\r\neh_atom_ou_recur <- function(x) c(atomico = is.atomic(x), recursivo = is.recursive(x))\r\n# Testando alguns objetos\r\neh_atom_ou_recur(c(a = 1, d = 3)) # TRUE FALSE\r\n\r\n\r\n  atomico recursivo \r\n     TRUE     FALSE \r\n\r\neh_atom_ou_recur(list())          # FALSE TRUE \r\n\r\n\r\n  atomico recursivo \r\n    FALSE      TRUE \r\n\r\neh_atom_ou_recur(list(2))         # FALSE TRUE\r\n\r\n\r\n  atomico recursivo \r\n    FALSE      TRUE \r\n\r\neh_atom_ou_recur(mean)              # FALSE TRUE\r\n\r\n\r\n  atomico recursivo \r\n    FALSE      TRUE \r\n\r\neh_atom_ou_recur(y ~ x)           # FALSE TRUE\r\n\r\n\r\n  atomico recursivo \r\n    FALSE      TRUE \r\n\r\neh_atom_ou_recur(expression(x^2 + 2)) # FALSE TRUE\r\n\r\n\r\n  atomico recursivo \r\n    FALSE      TRUE \r\n\r\neh_atom_ou_recur(quote(sqrt))      # FALSE FALSE\r\n\r\n\r\n  atomico recursivo \r\n    FALSE     FALSE \r\n\r\nNa última execução, percebemos que a função quote, apesar de função ela é primitiva. Nesse caso, esse objeto fugirá a regra de atomicidade e recursividade, porque em seu único argumento expr, tudo que for inserido nele será uma expressão, e não será avaliado. O resultado de quote(), apesar de mode() retornar call ou name, este último quando remos uma constante, o seu resultado pode ser qualquer tipo.\r\nPor que uma lista é uma lista, por exemplo? Podemos escrever uma lista da seguinte forma:\r\n\r\n\r\nlista <- list(x = 2, y = list(z = 3)); lista\r\n\r\n\r\n$x\r\n[1] 2\r\n\r\n$y\r\n$y$z\r\n[1] 3\r\n\r\nUm outro caso é o objeto função. Podemos escrever uma função dentro de outra função, isto é,\r\n\r\n\r\nfun1 <- function(x) {\r\n  fun2 <- function(y) x + y\r\n  fun2(x)\r\n}\r\nfun1(2)\r\n\r\n\r\n[1] 4\r\n\r\nA maioria dos objetos R são recursivos, exceções para os atômicos, NULL, objetos tipo \"symbols\", objetos \"S4\", objetos \"externalptr\", objetos \"bytecode\" e \"weakref\". Esses últimos raramente vísiveis ao usuário.\r\nUsando vector(), is.vector() e as.vector()\r\nApesar de conhecermos vetores como vetores atômicos, observemos que um objeto pode ser atômico mas não um vetor. Observemos o código a seguir.\r\n\r\n\r\n# Objeto NULL\r\nis.vector(NULL); is.atomic(NULL)\r\n\r\n\r\n[1] FALSE\r\n[1] TRUE\r\n\r\nA criação de vetores pode ser denvolvida pela função vector(mode, length), cujos argumentos são mode tipagem de acordo com a linguagem S (\"logical\", \"numeric\", \"complex\", \"character\" e \"raw\"). O argumento mode permite também \"integer\" e \"double\" de acordo com a tipagem da linguagem C. O argumento length representa o comprimento do vetor. Desse modo, criando um vetor de modo \"logical\" e de comprimento 5, temos:\r\n\r\n\r\nvector(mode = \"logical\", length = 5)\r\n\r\n\r\n[1] FALSE FALSE FALSE FALSE FALSE\r\n\r\nA identificação de um vetor é realizada por is.vector(), resultando em TRUE para um objeto tipo vetor, e FALSE, caso contrário. A afirmação anterior de que um objeto pode ser atômico mas não um vetor, ocorre porque quando usamos atributos aos vetores, exceto nomes, o retorno de is.vector() é FALSE. Vejamos o próximo código para essa confirmação.\r\n\r\n\r\nx <- structure(1:10, atrib1 = \"atributo 1\")\r\nis.atomic(x); is.vector(x); as.vector(x)\r\n\r\n\r\n[1] TRUE\r\n[1] FALSE\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nComo esperado, is.vector(x) retorna FALSE por causa do atributo atrib1. Porém, quando coagimos x a um vetor, usando as.vector(), esse novo objeto retorna os valores sem seus atributos. A exceção ocorre apenas para o atributo name, isto é,\r\n\r\n\r\nx <- c(arg1 = 1, arg2 = 2); x; attributes(x)\r\n\r\n\r\narg1 arg2 \r\n   1    2 \r\n$names\r\n[1] \"arg1\" \"arg2\"\r\n\r\nis.atomic(x); is.vector(x)\r\n\r\n\r\n[1] TRUE\r\n[1] TRUE\r\n\r\nSempre nos confundimos quando desejamos verificar a tipagem do vetor usando typeof() ou mode(), que já mencionamos também que o primeiro se relaciona com a tipagem C e o segundo com a tipagem S. Desse modo, a condição de equivalência ocorre, apesar de nomes diferentes entre algumas tipagens das linguagens, isto é,\r\n\r\n\r\n# Objeto tipo 'integer' e 'numeric'\r\nx <- 1L\r\n# Vericando\r\nis.vector(x, mode = \"numeric\")\r\n\r\n\r\n[1] TRUE\r\n\r\nis.vector(x, mode = \"integer\")\r\n\r\n\r\n[1] TRUE\r\n\r\ntypeof(x)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nmode(x)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nVimos na seção objetos base os tipos de objeto baseados na tipagem C. Os objetos tipo \"integer\" e \"double\" são equivalentes a \"numeric\" para a linguagem S, assim como o objeto \"symbol\" tem seu equivalente \"name\". Isso significa, que também poderemos usar is.vector() e as.vector() para saber se os objetos são desses tipos ou coagi-los, respectivamente, sendo monstrado exemplos a seguir.\r\n\r\n\r\n# Criando um objeto \"symbol\" ou \"name\"\r\nx <- as.vector(1, mode = \"symbol\")\r\n# Verificando\r\nis.vector(x, mode = \"symbol\")\r\n\r\n\r\n[1] TRUE\r\n\r\nis.vector(x, mode = \"name\")\r\n\r\n\r\n[1] TRUE\r\n\r\n# Criando um objeto \"pairlist\"\r\nfxy <- function(x, y) c(x, y)\r\nargumentos <- formals(fxy) \r\n# Verificando\r\nis.vector(argumentos, mode = \"pairlist\")\r\n\r\n\r\n[1] TRUE\r\n\r\nSe mode = any representa um objeto do tipo any, isto é, pode ser qualquer um dos tipos \"character\", \"integer\", \"double\", \"numeric\", \"complex\", \"raw\", \"list\" ou \"expression\". Desse modo, a função is.vector() retornará TRUE para todos esses tipos de objetos, porém quando usado a função mode() ou typeof(), esta retornará os seus tipos de origem e não \"any\", vejamos o código seguinte.\r\n\r\n\r\n# Criando um objeto \"any\"\r\nx <- as.vector(1, mode = \"any\")\r\n# Verificando o tipo\r\nis.vector(x, mode = \"any\")\r\n\r\n\r\n[1] TRUE\r\n\r\nis.vector(x, mode = \"numeric\")\r\n\r\n\r\n[1] TRUE\r\n\r\nmode(x)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\ntypeof(x)\r\n\r\n\r\n[1] \"double\"\r\n\r\nPor fim, se o argumento mode em is.vector for um tipo desconhecido, então o retorno será FALSE, ao invés de mensagem de erro.\r\nConhecendo outros objetos\r\nNo módulo básico, discutimos sobre alguns objetos que não demos detalhes adicionais ou não foram comentados.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nObjeto para datas, horas, tempo, durações e fusos horários\r\nO tempo intrínseco ao nosso dia a dia, e muitas vezes passamos despercebido em muitos aspectos. Vejamos, devido ao ano bissexto, alguns anos não têm 365 dias, nem 24 horas para um dia, muito menos 60 segundo para um minuto. Devido aos fenômenos de rotação e translação da terra, essas variáveis passam por alguns ajustes. Dessa forma, podemos perceber a complexidade de trabalhar com esses tipos de dados. Vamos aqui apresentar o básico para objetos que armazenam essas informações.\r\nDatas\r\nO objeto que armazena esses tipos de dados são vetores tipo \"double\", com classe Date, e portanto, um objeto POO do sistema S3. Para sabermos a data de hoje, usamos a função Sys.time(), isto é,\r\n\r\n\r\n# Qual a data de hoje?\r\nhoje <- Sys.Date()\r\n# Qual o tipo de objeto?\r\ntypeof(hoje)\r\n\r\n\r\n[1] \"double\"\r\n\r\n# Eh um vetor?\r\nis.vector(hoje)\r\n\r\n\r\n[1] FALSE\r\n\r\n# Eh 'double'?\r\nis.vector(hoje, mode = \"double\")\r\n\r\n\r\n[1] FALSE\r\n\r\n# Qual a sua classe?\r\nclass(hoje)\r\n\r\n\r\n[1] \"Date\"\r\n\r\nCalma que as execuções para is.vector() retornaram FALSE, devido o atributo class. Se excluirmos verificaremos a sua confirmação, apresentado a seguir.\r\n\r\n\r\n# Eh um vetor?\r\nis.vector(unclass(hoje))\r\n\r\n\r\n[1] TRUE\r\n\r\n# Eh 'double'?\r\nis.vector(unclass(hoje), mode = \"double\")\r\n\r\n\r\n[1] TRUE\r\n\r\n# Qual a sua classe?\r\nclass(hoje)\r\n\r\n\r\n[1] \"Date\"\r\n\r\nQuando retornamos a classe implícita desse objeto, recebemos o seguinte resultado:\r\n\r\n\r\nunclass(hoje)\r\n\r\n\r\n[1] 18915\r\n\r\nO resultado 18915 coagido a double se refere ao número de dias desde a data “1970-01-01.” Essa data é em homenagem ao marco zero do sistema de calendário utilizado pelo sistema UNIX.\r\nPodemos criar um objeto data com o construtor (gerador de instâncias de classe) chamado .Date(). O argumento de entrada será o número de dias após o marco “1970-01-01,” isto é,\r\n\r\n\r\n# O marco zero\r\n.Date(0)\r\n\r\n\r\n[1] \"1970-01-01\"\r\n\r\n# Um dia apos o marco\r\n.Date(1)\r\n\r\n\r\n[1] \"1970-01-02\"\r\n\r\n# Dez dias apos o marco\r\n.Date(10)\r\n\r\n\r\n[1] \"1970-01-11\"\r\n\r\nA função de coerção para um objeto data é uma função genérica para as classes implícitas \"character\" e \"numeric\", e para as classes \"POSIXct\", e para mais detalhes da função, use ?as.Data(). Vejamos alguns exemplos a seguir.\r\n\r\n\r\n# Objeto x tipo \"character\"\r\nx <- \"2017-08-02\"\r\n(data <- as.Date(x))\r\n\r\n\r\n[1] \"2017-08-02\"\r\n\r\nclass(data)\r\n\r\n\r\n[1] \"Date\"\r\n\r\n# Objeto x tipo \"numeric\"\r\nx <- 10\r\n# Com o objeto numerico, precisamos informar\r\n# a data inicial no argumento 'origin'. Nesse\r\n# caso, o retorno sera a data x dias apos \r\n# 'origin'\r\n# \r\n(data <- as.Date(x, origin = \"2017-08-02\")) \r\n\r\n\r\n[1] \"2017-08-12\"\r\n\r\n# Objeto de classe 'POSIXct'\r\nx <- as.POSIXct(\"2018-08-02 5:30\")\r\n(data <- as.Date(x))\r\n\r\n\r\n[1] \"2018-08-02\"\r\n\r\nclass(data)\r\n\r\n\r\n[1] \"Date\"\r\n\r\nExplicaremos posteriormente os objetos da classe \"POSIXct\". Podemos alterar o formato tanto da data como também da hora, que falaremos mais a frente, por meio da função format(), cuja sintaxe geral para essa função é dada por:\r\n\r\nformat(x, format, ...),\r\n\r\nem que x é o argumento que recebe um valor de data, e o argumento format é o argumento para informarmos o formato de apresentar essa data. O default é o formato \"%Y-%m-%d. Porém, já vamos adiantar algumas siglas importantes na Tabela 1, para a formatação das datas.\r\nTable 1:  Siglas importantes para o formato de datas e horas.\r\nSigla\r\nSignificado\r\nSigla\r\nSignificado\r\n%Y\r\nTodos os dígitos do ano\r\n%y\r\nOs dois últimos dígitos do ano\r\n%C\r\nSéculo (00-99)\r\n%c\r\nData e hora específico do local, formado \"%a %b %e %H:%M:%S %Y\"\r\n%B\r\nMês completo (Texto)\r\n%b ou %h\r\nMês abreviado (Texto)\r\n%m\r\nMês (Número)\r\n%j\r\nNúmero de dias no ano\r\n%A\r\nDia da semana completa\r\n%a\r\nDia da semana abreviada\r\n%D\r\nData completa no formato %m/%d/%y, padrão C99\r\n%d\r\nDia do mês\r\n%H\r\nHoras (24 horas)\r\n%l\r\nHoras (12 horas)\r\n%M\r\nMinutos\r\n%S\r\nSegundos\r\n%p\r\ninserção para as horas AM/PM\r\n\r\n\r\n%w\r\nDia da semana (texto)\r\n%W\r\nNúmero da semana no ano ()\r\n%x\r\nData específica de acordo com Sys.setlocale()\r\n%X\r\nHorário especificado de acordo com Sys.setlocale()\r\n%z\r\nCompensação em relação ao horário de Greenwich (GMT)\r\n%Z\r\nFuso horário\r\nMais detalhes dessas siglas, ?strptime(). Vejamos alguns exemplos no código a seguir.\r\n\r\n\r\n# Dia de hoje\r\nSys.Date()\r\n\r\n\r\n[1] \"2021-10-15\"\r\n\r\n# Formatando\r\nformat(Sys.time(), \"%d/%m/%Y\")\r\n\r\n\r\n[1] \"15/10/2021\"\r\n\r\nformat(Sys.time(), \"%d de %B de %Y\")\r\n\r\n\r\n[1] \"15 de outubro de 2021\"\r\n\r\nPara os objetos de classe \"Date\", as siglas utilizadas para a função format() devem estar relacionadas a data, isto é, dia, mês e ano. Lembrando que o resultado desse genérico, bem como de as.character(), retornam vetores de tipo caractere, sem a classe \"Date\".\r\nAlgumas funções genéricas estão prontas para serem utilizados nesses objetos, como +, -, seq(), rep(), etc. Para saber mais quais métodos para essa classe, use methods(class = \"Date\").\r\nDatas, horas e fusos horários\r\nSe observarmos os métodos disponíveis para o genérico as.Date(), usando methods(as.Date), direto ou indiretamente, internamente ao código há uma chamada as.POSIXlt() ou as.POSIXct(). Nesse caso, nas base do R a forma de armazenar a data e hora segue uma família de padrões especificados pela IEEE Computer Society chamado POSIX (do inglês, Portable Operating System Interface). O objetivo é manter um padrão para que haja uma compatibilidade entre os sistemas operacionais. Assim, os objetos contrutores para armazernar além das datas também as horas são respectivamente, .POSIXct() e .POSIXlt(). O primeiro se refere a data e hora do calendário (ct - calendar time), e o segundo a data e hora local (lt - local time).\r\nO construtor .POSIXct() é um vetor tipo double, em que seu primeiro argumento de entrada representa o número de segundos desde “1970-01-01.” Assim, esse construtor gera uma instância para as classes \"POSIXct\" e \"POSIXt\", que podemos observar a seguir.\r\n\r\n\r\n# Marco zero\r\n(mzero <- .POSIXct(0))\r\n\r\n\r\n[1] \"1969-12-31 21:00:00 -03\"\r\n\r\n# Classe\r\nclass(mzero)\r\n\r\n\r\n[1] \"POSIXct\" \"POSIXt\" \r\n\r\nPercebemos que o resultado mzero não representa a data “1970-01-01.” Quando investigamos a função .POSIXct(), percebemos que um dos argumentos é tz que representa o fuso horário. Por default tz = NULL, e nesse caso será buscado o fuso horário do calendário do sistema operacional. Vejamos,\r\n\r\n\r\n# Marco zero, baseado no calendario SO\r\n.POSIXct(0)\r\n\r\n\r\n[1] \"1969-12-31 21:00:00 -03\"\r\n\r\n# Marco zero, fuso Horario de Greenwich (GMT) ou Tempo Universal Coordenado (UTC)\r\n.POSIXct(0, tz = \"GMT\")\r\n\r\n\r\n[1] \"1970-01-01 GMT\"\r\n\r\n.POSIXct(0, tz = \"UTC\")\r\n\r\n\r\n[1] \"1970-01-01 UTC\"\r\n\r\nNesse caso, o resultado da chamada .POSIXct(0), foi executado de um sistema operacional (SO) com fuso horário no Brasil, horário de Brasília, com fuso -3GMT em relação ao fuso horário UTC ou GMT (do inglês, Greenwich Mean Time e Coordinated Universal Time, respectivamente), que representa o fuso horário de Greenwich e o Tempo Universal Coordenado, respectivamente. Para se alterar o fuso horário, o argumento tz deve ser usado. Para saber, acesse a lista de fusos horários chamando OlsonNames().\r\nA coersão para um objeto POSIXct, a função usada é as.POSIXct(), que pode coagir a partir de vetores caracteres e numéricos. Seguem as mesmas ideias que comentamos para as.Date(), porém agora acrescentamos as horas. O fuso horário pode ser captado pelo calendário do sistema operacional, ou pode ser inserido.\r\n\r\n\r\n# Objeto caractere\r\nx <- \"2021-09-02 22:46:30\"\r\ndata_hora1 <- as.POSIXct(x)\r\nclass(data_hora1)\r\n\r\n\r\n[1] \"POSIXct\" \"POSIXt\" \r\n\r\n# Objeto numerico\r\ndata_hora2 <- as.POSIXct(100, origin = \"1955-09-13\")\r\nclass(data_hora2)\r\n\r\n\r\n[1] \"POSIXct\" \"POSIXt\" \r\n\r\nA saída padrão é \"%Y-%m-%d %H:%M:%S\", seguido do fuso horário. Essa configuração é realizada pelo genérico format que despacha para o método apropriado.\r\nO outro contrutor é algo mais complicado de se trabalhar, porque ao invés de um vetor double, é uma lista com no mínimo 9 componentes que segue:\r\nTable 2:  Componentes do objeto POSIXlt.\r\nComponente\r\nDescrição\r\nsec\r\nSegundos\r\nmin\r\nMinutos\r\nhour\r\nHoras\r\nmon\r\nMês\r\nzone\r\nFuso horário\r\nwday\r\nDias da semana\r\nmday\r\nDias do mês\r\nyear\r\nAnos desde “1899-12-31.”\r\nisdst\r\nO fuso horário é utilizado para configurar o isdst, que representa o horário de verão\r\ngmtoff\r\nDeslocamento em segundos do horário de Greenwich (GMT)\r\nOs dois últimos componenente basicamente é o fuso horário que configura. O construtor é .POSIXlt(), e de forma mais direta, podemos usar stiptime() para converter vetores caracteres nesse classe. A classe desse objeto é \"POSIXlt\" e POSIXt\r\nVejamos alguns exemplos para criação desse objeto, com o código a seguir.\r\n\r\n\r\n# Marco zero\r\nxx <- list(sec = 0, min = 0, hour = 0, mday = 0,\r\n           mon = 0, year = 0, wday = 0, yday = 0,\r\n           isdst = 0, zone = \"America/Sao_Paulo\", gmtoff = \"\")\r\ntempo1 <- .POSIXlt(xx)\r\nclass(tempo1)\r\n\r\n\r\n[1] \"POSIXlt\" \"POSIXt\" \r\n\r\n# Objeto caractere -> POSIXlt\r\ntempo2 <- strptime(\"2021-09-02 03:21 am UTC\", \"%Y-%m-%d\"); tempo2; unlist(tempo2)\r\n\r\n\r\n[1] \"2021-09-02 -03\"\r\n   sec    min   hour   mday    mon   year   wday   yday  isdst   zone \r\n   \"0\"    \"0\"    \"0\"    \"2\"    \"8\"  \"121\"    \"4\"  \"244\"    \"0\"  \"-03\" \r\ngmtoff \r\n    NA \r\n\r\nclass(tempo2)\r\n\r\n\r\n[1] \"POSIXlt\" \"POSIXt\" \r\n\r\nMuitas outras funções podem ser utilizadas para manipulação de datas, mas deixaremos para o leitor em realizar as suas consultas adicionais: striftime(), Sys.setlocale(), Sys.getlocale(), .difftime(), as.difftime(), Sys.timezone(), Sys.time(), etc.\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\nTanto para datas, horas e fusos horários existem pacotes alternativos que podem facilitar a utilização desses tipos de dados, como por exemplo o pacote lubridate.\r\n\r\n\r\n\r\n\r\nCópia ao modificar, modificação no local e tamanho de objetos\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nMuitos dos problemas de perda de desempenho do código R pode estar envolvido a essa seção. Já abordamos no módulo básico de modo superficial, e agora iremos aprofundar um pouco mais. Outro assunto importante dentro do paradigma da programação funcional, que é a imutabilidade. Veremos que em algumas situações os objetos podem ser mutáveis, e com isso podemos afirmar a linguagem R não é estritamente funcional. Por fim, iremos perceber um grande equívoco que ocorre entre os programadores R quando cria um objeto associado ao nome x, afirma que criou um objeto x cujo valor está dentro dele. Perceberemos que na verdade, temos dois objetos envolvidos, e o que faz retornar o valor associado ao nome x é o ambiente onde esses objetos foram criados, de modo que, poderemos associar mais de um nome ao mesmo objeto.\r\nSugerimos que quando buscarmos pelo identificador de memória de onde os objetos foram alocados na memória ativa do seu sistema operacional, seja usado o interpretador do R ao invés do RStudio, porque a IDE faz uma referência a cada objeto para exibir informações sobre ele.\r\nQuando falamos dos tipos de objeto base, mencionamos os 24 tipos de objetos que existem no ambiente R. Vejamos o código a seguir.\r\nx <- 10\r\nFalamos também que o objeto nome é do tipo symbol, como no caso de x, e o objeto 10 é um vetor numérico tipo integer de comprimento 1. Ao criar esse objeto, a forma de recuperá-lo é associar um nome a ele, uma vez que o ambiente R não tem uma forma de recuperar o valor do objeto pelo identificador de memória onde ele foi reservado, pelo menos ainda limitados a compreensão de existência. As ligações desses objetos ficam armazenados como uma lista em um outro objeto, o ambiente. Nesse caso, essa ligação foi armazenada no ambiente global, .GlobalEnv. Na Figura 2, mostramos em detalhes essas ligações.\r\n\r\n\r\n\r\nFigure 2: Ligações entre objetos tipo 'symbol' e 'integer'.\r\n\r\n\r\n\r\nDiante disso, o que vem a ser a cópia de um objeto, nada mais é do que alocar um outro espaço de memória para armazenar o(s) valor(es) do objeto copiado. Isso significa, mais espaço de memória ativa. Há de se observar que o consumo de memória pelo R é um dos gargalos do ambiente, mas ao longo do tempo vem evoluindo bastante. Porém, muitas vezes é o mau uso na escrita das rotians desenvolvida pelos usuários que gera essas intempéries. Então, vamos lá para uma série de exemplos.\r\n\r\n\r\n# Exemplo 1\r\na <- b <- d <- 6\r\n# identificador de memoria\r\nlobstr::obj_addr(a)\r\n\r\n\r\n[1] \"0x2c8c9d80\"\r\n\r\nlobstr::obj_addr(b)\r\n\r\n\r\n[1] \"0x2c8c9d80\"\r\n\r\nlobstr::obj_addr(d)\r\n\r\n\r\n[1] \"0x2c8c9d80\"\r\n\r\nLembrando no módulo básico, que os identificadores de memória sempre se alteram, à medida que reiniciamos. Porém, percebam que ao chamar o objeto associado a esses nomes, todos retornam o valor 6. Ainda mais, o identificador de memória é o mesmo. Portanto, aqui fica claro que não está havendo cópia do objeto, e sim, mais nomes se associando ao mesmo objeto, observemos a Figura 3, é o que chamamos de vinculação compartilhada.\r\n\r\n\r\n\r\nFigure 3: Ligações de nomes associados ao objeto numérico.\r\n\r\n\r\n\r\nVamos agora apresentar um próximo código, para entendermos a definição de cópia ao modificar.\r\n\r\n\r\n# Vetor caractere ligado a dois nomes\r\nx <- y <- c(\"a\", \"b\", \"c\"); y; x\r\n\r\n\r\n[1] \"a\" \"b\" \"c\"\r\n[1] \"a\" \"b\" \"c\"\r\n\r\n# Identificador de memoria do obj associado aos nomes\r\nlobstr::obj_addr(y); lobstr::obj_addr(x)\r\n\r\n\r\n[1] \"0x247fafa8\"\r\n[1] \"0x247fafa8\"\r\n\r\n# Copia ao modificar\r\nx[1] <- \"f\"\r\n# Ident de mem do obj associado aos nomes apos a modificacao\r\nlobstr::obj_addr(y); lobstr::obj_addr(x)\r\n\r\n\r\n[1] \"0x247fafa8\"\r\n[1] \"0x1618af38\"\r\n\r\n# Imprimindo novamente os objetos\r\ny; x\r\n\r\n\r\n[1] \"a\" \"b\" \"c\"\r\n[1] \"f\" \"b\" \"c\"\r\n\r\nPercebam que criamos um vetor caractere de comprimento 3, e vinculamos a dois nomes, x e y. Posteriormente, alteramos o primeiro elemento do vetor x, mas isso não modificou o vetor y. O que aconteceu? O ambiente R preservou o objeto y, e fez uma cópia de 0x247fafa8 para 0x1618af38, com o valor alterado, e religou o nome x a esse objeto, Figura 4. Portanto, fazer uma cópia representa realocar um outro espaço de memória para armazenar os valores desse objeto, e assim, um outro identificador de memória será apresentado, diferente do objeto copiado.\r\n\r\n\r\n\r\nFigure 4: Cópia de objetos.\r\n\r\n\r\n\r\nA função tracemem() do pocote base, pode auxiliar na verificação de cópias de objetos. Após a vinculação de um nome a um objeto, essa função pode ser acionada, e após as alterações de valores do objeto, se houver cópia, uma mensagem é impressa no console informando a referida cópia. Vejamos no código a seguir.\r\n\r\n\r\n# Vetor numerico de comprimento 3\r\nw <- rnorm(3); w\r\n\r\n\r\n[1]  0.8546449  1.1350022 -0.3083730\r\n\r\n# Acionando a funcao 'tracemem()' e imprimindo o id de memoria\r\ncat(tracemem(w), \"\\n\")\r\n\r\n\r\n<000000004395CC38> \r\n\r\n# Vinculacao de outro nome e copia\r\nz <- w; z[2] <- 10\r\n\r\n\r\ntracemem[0x000000004395cc38 -> 0x0000000043b374f8]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> withCallingHandlers suppressMessages render_one FUN lapply sapply <Anonymous> <Anonymous> <Anonymous> \r\n\r\n# Desativando o rastreamento\r\nuntracemem(w)\r\n# Modificando novamente o obj z\r\nz[1] <- 100; z\r\n\r\n\r\n[1] 100.000000  10.000000  -0.308373\r\n\r\n# Identificador de memoria\r\nlobstr::obj_addr(z)\r\n\r\n\r\n[1] \"0x43b374f8\"\r\n\r\nApós vinculado o nome w ao vetor numerico de comprimento 3, que é um gerador de números aleatórios de uma distribuição normal padrão, acionamos a chamada tracemem(), e após a criação de cópias, a função mostrará a ocorrência dessas cópias. Se desejarmos que essa mensagem não seja mais acionada, devemos usar a chamada untracemem(), que desativará o rastreameto de cópia. Lembrando que o rastreamento só ocorrerá o objeto informado na função tracemem(). Por fim, fizemos mais uma alteração no objeto z, e nesse caso como o objeto se associa apenas a um nome, ocorre a modificação no local, um processo de otimização do R, em que usa a mesma alocação de memória, não havendo portanto, uma cópia de objeto.\r\nMas, fazendo alguns estudos e pesquisas, encontramos algumas funções primitivas, acessadas pela chamada .Internals(), denominada inspect(), address() e refcnt(), funções experimentais para imprimir informações de baixo nível dos objetos R. Essa função não é exposta ao nível superior da linguagem, e segundo a própria documentação, é um recurso para depuração/inpeção. A documentação ainda afirma que nem todas as informações foram implementadas. Para esse momento, o que está implementado é suficiente para identificarmos os procedimentos de cópia dos objetos. Uma segunda informação é que a partir da versão R 4.0.0, a decisão de cópia de objetos passaram a ser determinados pela contagem de referência, ao invés do mecanismo NAMED. Esse ponto realmente exige um entendimento de baixo nível na linguagem, isto é, a sua implementação em linguagem C. Vamos mostrar os resultados do código anterior, inspecionado por essas funções, a seguir.\r\n\r\n\r\n\r\n# Vetor numerico de comprimento 3\r\nw <- rnorm(3); w\r\n## [1]  0.2733585 -0.6819105 -0.1788905\r\n# inspecionando em baixo nivel o objeto w\r\n.Internal(inspect(w)); .Internal(address(w)); .Internal(refcnt(w))\r\n## @0x000000000a046838 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 0.273359,-0.68191,-0.17889\r\n## <pointer: 0x000000000a046838\r\n## [1] 1\r\n# Vinculacao de outro nome e copia\r\nz <- w\r\n# inspecionando em baixo nivel o objeto z\r\n.Internal(inspect(z)); .Internal(address(z)); .Internal(refcnt(z))\r\n## @0x000000000a046838 14 REALSXP g0c3 [REF(2)] (len=3, tl=0) 0.273359,-0.68191,-0.17889\r\n## <pointer: 0x000000000a046838>\r\n## [1] 2\r\n# Alterando z\r\nz[2] <- 10\r\n# inspecionando em baixo nivel o objeto z\r\n.Internal(inspect(z)); .Internal(address(z)); .Internal(refcnt(z))\r\n## @0x000000000a046518 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 0.273359,10,-0.17889\r\n## <pointer: 0x000000000a046518>\r\n## [1] 1\r\n# Modificando novamente o obj z\r\nz[1] <- 100; z\r\n## [1] 100.0000000  10.0000000  -0.1788905\r\n# inspecionando em baixo nivel o objeto z\r\n.Internal(inspect(z)); .Internal(address(z)); .Internal(refcnt(z))\r\n## @0x000000000a046518 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 100,10,-0.17889\r\n## <pointer: 0x000000000a046518>\r\n## [1] 1\r\n\r\n\r\n\r\nA função inspect() será melhor explorada no módulo avançado. O que vamos precisar de sua saída é a estrutura REF(#), que representa a contagem de referência, isto é, o símbolo # determina o número de nomes associados ao objeto inspecionado. Se # = 1, não ocorrerá cópia de objeto, e sim, uma modificação no local. Se # > 1, certamente ocorrerá uma cópia de objeto. Observemos que inicialmente, o objeto associado a z é inspecionado com REF(1), cujo número pode ser obtido também por .Internal(refcnt(w)). A chamada .Internal(address(w)) informa o identificador de memória, o mesmo obtido por lobstr::obj_addr(w) ou tracemem(w), este último com pequenas alterações. Na sequência, associamos um outro nome z ao objeto. Agora, observamos que a contagem de referência agora é REF(2). Dessa forma, qualquer alteração nos valores de w ou z, haverá cópia de objeto. E isso acaba ocorrendo quando executamos z[2] <- 10, verificando que o identificador de memória de z se alterou. Um outro fato muito importante surge nesse momento. A alteração do objeto foi realizada por uma função primitiva, e funções primitivas, geralmente, têm um melhor controle da contagem de referência, e nesse caso, percebemos que o novo objeto associado a z só existe esse nome, e portanto, a contagem de referência retorna a 1, isto é, REF(1). Por fim, alteramos novamente o objeto associado a z, porém a modificação ocorre no local, porque REF(1).\r\nUma outra consequência de cópia de objeto é a coersão. Vejamos o código na sequência para ilustrar.\r\n\r\n\r\n# Vetor inteiro de comprimento 10\r\nx <- integer(10)\r\n# Inspecionando x\r\n.Internal(inspect(x))\r\n## @0x00000000066297e0 13 INTSXP g0c4 [REF(1)] (len=10, tl=0) 0,0,0,0,0,...\r\n# Alterando x com um escalar tipo 'double'\r\nx[1] <- 10 # 10 eh 'double', 10L seria 'integer'\r\n# Inspecionando x\r\n.Internal(inspect(x))\r\n## @0x0000000008dfcf88 14 REALSXP g0c5 [REF(1)] (len=10, tl=0) 10,0,0,0,0,...\r\n\r\n\r\n\r\nFalamos anteriormente que, geralmente, as funções primitivas têm um controle melhor da contagem de referência para decidir se um objeto será copiado ou não. Mas, nem todas. Vejamos o código a seguir.\r\n\r\n\r\n# funcao primitiva c() - REF(1)\r\nb <- c(1, 2, 3, 4, 5)\r\n# Inspecao de b\r\n.Internal(inspect(b))\r\n\r\n\r\n@0x0000000044844690 14 REALSXP g0c4 [REF(2)] (len=5, tl=0) 1,2,3,4,5\r\n\r\n## @0x0000000006629620 14 REALSXP g0c4 [REF(1)] (len=5, tl=0) 1,2,3,4,5\r\n# Funcao primitiva `:` - REF(65535)\r\nb <- 1:10\r\n# inspecao de b\r\n.Internal(inspect(b))\r\n\r\n\r\n@0x0000000025309740 13 INTSXP g0c0 [REF(65535)]  1 : 10 (compact)\r\n\r\n## @0x000000000a060680 13 INTSXP g0c0 [REF(65535)]  1 : 10 (compact)\r\n# Funcao primitiva seq() - REF(65535)\r\nb <- seq(1L, 10L)\r\n# inspecao de b\r\n.Internal(inspect(b))\r\n\r\n\r\n@0x00000000264de810 13 INTSXP g0c0 [REF(65535)]  1 : 10 (compact)\r\n\r\n## @0x000000000a05f3e8 13 INTSXP g0c0 [REF(65535)]  1 : 10 (compact)\r\n# Funcao primitiva rep() - REF(1)\r\nb <- rep(1:10, 1) \r\n# Inspecao de b\r\n.Internal(inspect(b))\r\n\r\n\r\n@0x000000004484d708 13 INTSXP g0c4 [REF(2)] (len=10, tl=0) 1,2,3,4,5,...\r\n\r\n## @0x00000000066295b0 13 INTSXP g0c4 [REF(1)] (len=10, tl=0) 1,2,3,4,5,...\r\n\r\n\r\n\r\nObservemos que algumas funções são muito úteis para a implementação de nossas rotinas, porém estas geram cópias de objetos com a alteração de seus valores, ao invés de modificação no local. Por exemplo, as funções : e seq() são muito úteis para gerarmos uma sequência de valores espaçados igualmente, porém, observamos que suas contagens de referências são diferentes de 1. Isso significa que qualques alteração nos valores do objeto, criado por essas funções, geram cópias. Dependendo da implementação em um loop, por exemplo, o dispêndio de memória ativa pode ser muito alto, e por consequência, perda de desempenho.\r\nNo caso de funções tipo closure, isto é, criadas por function(), ocorre algo similar com a discussão anterior, porém, com algumas diferenças, vejamos o próximo código.\r\n\r\n\r\nf1 <- function(x) {\r\n  print(.Internal(inspect(x)))\r\n  x\r\n}\r\nf2 <- function(x) {\r\n  print(.Internal(inspect(x)))\r\n  x[1] <- 10\r\n  print(.Internal(inspect(x)))\r\n  x\r\n} \r\n# Caso 1\r\na <- c(1, 2, 3)\r\n.Internal(inspect(a))\r\n## @0x000000000a426578 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,2,3\r\nk1 <- f1(a)\r\n## @0x000000000a426578 14 REALSXP g0c3 [REF(2)] (len=3, tl=0) 1,2,3\r\n## [1] 1 2 3\r\n.Internal(inspect(k1))\r\n## @0x000000000a426578 14 REALSXP g0c3 [REF(2)] (len=3, tl=0) 1,2,3\r\n# Caso 2\r\na <- c(1, 2, 3)\r\n.Internal(inspect(a))\r\n## @0x000000000a426398 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,2,3\r\nk2 <- f2(a)\r\n## @0x000000000a426398 14 REALSXP g0c3 [REF(2)] (len=3, tl=0) 1,2,3\r\n## [1] 1 2 3\r\n## @0x000000000a426258 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 10,2,3\r\n## [1] 10  2  3\r\n.Internal(inspect(k2))\r\n## @0x000000000a426258 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 10,2,3\r\n\r\n\r\n\r\nO objeto quando é vinculado em um argumento de um função, entra como promessa, isto significa que ele não é avaliado, apenas quando for chamado no corpo da função. Se nenhuma alteração for realizada a esse objeto, nenhuma cópia é realizada, porém a contagem de referência terá um nível superior. Observe o objeto a, o seu identificador de memória é o mesmo quando chamamos a primeira vez o argumento x = a na função f1(). Isso significa que como essa função é uma identidade, apenas imprime o próprio argumento, portanto, nada é alterado no argumento x. Porém, REF(1) passa para REF(2), e o nome k1 passa a se associar também com o objeto, ao invés de uma cópia de objeto, que pode ser representado pela Figura 5. No segundo caso, criamos novamente o objeto a, ao ser chamado inicialmente agora na função f2, a contagem de referência passa para REF(2), porém sem cópia inicialmente. Quando a chamada [<- é executada ocorre uma cópia, por causa de REF(2), Figura 5. Ao ser copiado, essa função primitiva retorna a contagem de referência para 1, e a saída da função ocorre para REF(1). Nesse sentido, os objetos associados aos nomes k1 e k2, posteriormente, se alterados terão comportamentos diferentes. O objeto associado a k1 se alterado, será realizado uma cópia, e no caso de k2 ocorrerá uma modificação no local, tudo por causa da contagem de referência em cada um dos casos.\r\n\r\n\r\n\r\nFigure 5: Cópia e modificação no local de objetos.\r\n\r\n\r\n\r\nOs objetos tipo listas, que na realidade vetores mais complexos, apresentam comportamento semelhante na cópia na modificação, e na modificação no local. A ideia seguirá a mesma com a contagem de referência, REF(1) ocorre a modificação no local, e valores superiores a 1, cópia na modificação.\r\nComo visto no módulo básico, os elementos de uma lista são vetores atômicos, e até mesmo listas. Desse modo, diferentemente dos vetores cuja estrutura armazena os próprios valores, as listas armazenam as identificações de memória em que os objetos foram alocados. Vejamos a estrutura de baixo nível desse tipo de objeto.\r\n\r\n\r\n# Objeto lista\r\nl1 <- list(c(1, 2, 3), 10L, TRUE)\r\n# Inspecao do objeto\r\n.Internal(inspect(l1))\r\n## @0x00000000060b27f8 19 VECSXP g0c3 [REF(1)] (len=3, tl=0)\r\n##  @0x00000000060b2848 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,2,3\r\n##  @0x00000000060af018 13 INTSXP g0c1 [REF(3)] (len=1, tl=0) 10\r\n##  @0x00000000060aefa8 10 LGLSXP g0c1 [REF(3)] (len=1, tl=0) 1\r\n# Associacao de outro nome l2 ao obj lista\r\nl2 <- l1\r\n# Inspecao\r\n.Internal(inspect(l2))\r\n## @0x00000000060b27f8 19 VECSXP g0c3 [REF(2)] (len=3, tl=0)\r\n##  @0x00000000060b2848 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,2,3\r\n##  @0x00000000060af018 13 INTSXP g0c1 [REF(3)] (len=1, tl=0) 10\r\n##  @0x00000000060aefa8 10 LGLSXP g0c1 [REF(3)] (len=1, tl=0) 1\r\n# Alterando l2\r\nl2[[3]] <- 5\r\n# Inspecao\r\n.Internal(inspect(l2))\r\n## @0x00000000064fc860 19 VECSXP g0c3 [REF(1)] (len=3, tl=0)\r\n##  @0x00000000060b2848 14 REALSXP g0c3 [REF(2)] (len=3, tl=0) 1,2,3\r\n##  @0x00000000060af018 13 INTSXP g0c1 [REF(4)] (len=1, tl=0) 10\r\n##  @0x0000000007fc77e0 14 REALSXP g0c1 [REF(3)] (len=1, tl=0) 5\r\n\r\n\r\n\r\nNesse caso, podemos representar uma lista pela Figura 6. Observemos quando criamos mais de um nome associado ao objeto lista, e como os seus elementos apontam para os vetores.\r\n\r\n\r\n\r\nFigure 6: Vinculação de nomes ao objeto lista.\r\n\r\n\r\n\r\nA alteração do terceiro elemento da lista l2, proporciona uma cópia de l1, porém os dois primeiros elementos de l2 apontam para os mesmos dois primeiros objetos de l1, não havendo cópia sobre esses vetores, Figura 7. Para saber se determinado vetor de uma lista será copiado ou modificado no local, seguirá a mesma regra abordada em vetores com relação a contagem de referência dos vetores e não a contagem de referência da lista.\r\n\r\n\r\n\r\nFigure 7: Cópias de listas.\r\n\r\n\r\n\r\nAparentemente, os quadro de dados (Data frames) deveriam ter os mesmos comportamentos de uma lista na cópia ou modificação no local. Porém, apresentamos uma diferença marcante no quadro de dados, alterar uma coluna nesse objeto, modifica apenas essa coluna, contudo, modificar por linha, todo o objeto é copiado. Vejamos em código essa explicação.\r\n\r\n\r\nqd1 <- data.frame(c1 = c(1, 2, 3), c2 = c(4, 5, 6)) \r\n# Inspecao\r\n.Internal(inspect(qd1))\r\n## @0x0000000007ff9e78 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x0000000006382578 14 REALSXP g0c3 [REF(5)] (len=3, tl=0) 1,2,3\r\n##  @0x0000000006382528 14 REALSXP g0c3 [REF(5)] (len=3, tl=0) 4,5,6\r\n## ATTRIB:\r\n## ...\r\n# A primeira alteracao em copia\r\nqd1$c1[2] <- 10\r\n.Internal(inspect(qd1))\r\n## @0x0000000007ffa178 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x000000000985c8f8 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,10,3\r\n##  @0x0000000006382528 14 REALSXP g0c3 [REF(6)] (len=3, tl=0) 4,5,6\r\n## ATTRIB:\r\n## ...\r\n# Quando REF(1), a modificacao ocorre no local\r\nqd1$c1[1] <- 99\r\n.Internal(inspect(qd1))\r\n## @0x0000000007ffa1b8 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x000000000985c8f8 14 REALSXP g0c3 [REF(2)] (len=3, tl=0) 99,10,3\r\n##  @0x0000000006382528 14 REALSXP g0c3 [REF(7)] (len=3, tl=0) 4,5,6\r\n## ATTRIB:\r\n## ...\r\n# Porem, quando a alteracao ocorre em linha,\r\n# sempre havera copia na modificacao\r\nqd1[1,] <- c(00, 00)\r\n.Internal(inspect(qd1))\r\n## @0x0000000007c2f3c8 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x00000000098c3550 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 0,10,3\r\n##  @0x00000000098c3500 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 0,5,6\r\n## ATTRIB:\r\n## ...\r\n# Porem, mesmo com REF(1) e alteracao em linha,\r\n# havera copia na modificacao\r\nqd1[2,] <- c(11, 11)\r\n.Internal(inspect(qd1))\r\n## @0x0000000007c0abe8 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x00000000098c3230 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 0,11,3\r\n##  @0x00000000098c31e0 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 0,11,6\r\n## ATTRIB:\r\n## ...\r\n\r\n\r\n\r\nNo caso das modificações realizadas em coluna, podemos também verificar por meio da Figura 8. No caso das alterações realizadas em linha, sempre haverá cópia na modificação.\r\n\r\n\r\n\r\nFigure 8: Cópia de quadro de dados (data frames).\r\n\r\n\r\n\r\nQuando o objeto quadro de dados tem dois nomes associados, segue as mesmas ideias apresentadas nas listas, com a adição das características verificadas anteriormente para esse tipo de objeto, em que abaixo, apresentamos mais um código para análise.\r\n\r\n\r\n# Quadro de dados 1\r\nqd1 <- data.frame(c1 = c(1, 2, 3), c2 = c(4, 5, 6)) \r\n# Inspecao\r\n.Internal(inspect(qd1))\r\n## @0x00000000064d2db8 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x00000000099a0448 14 REALSXP g0c3 [REF(5)] (len=3, tl=0) 1,2,3\r\n##  @0x00000000099a03f8 14 REALSXP g0c3 [REF(5)] (len=3, tl=0) 4,5,6\r\n## ATTRIB:\r\n## ...\r\n# Quadro de dados 2\r\nqd2 <- qd1\r\n# Inspecao\r\n.Internal(inspect(qd2))\r\n## @0x00000000064d2db8 19 VECSXP g0c2 [OBJ,REF(2),ATT] (len=2, tl=0)\r\n##  @0x00000000099a0448 14 REALSXP g0c3 [REF(5)] (len=3, tl=0) 1,2,3\r\n##  @0x00000000099a03f8 14 REALSXP g0c3 [REF(5)] (len=3, tl=0) 4,5,6\r\n## ATTRIB:\r\n##  ...\r\n \r\n# A copia em coluna, o quadro de dado copia apenas a coluna\r\nqd2$c1[2] <- 10\r\n.Internal(inspect(qd2))\r\n## @0x00000000064d3238 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x00000000099cf960 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,10,3\r\n##  @0x00000000099a03f8 14 REALSXP g0c3 [REF(7)] (len=3, tl=0) 4,5,6\r\n## ATTRIB:\r\n##  ...\r\nqd2$c2 <- c(100, 100, 100)\r\n.Internal(inspect(qd2))\r\n## @0x00000000064d32b8 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x00000000099cf960 14 REALSXP g0c3 [REF(2)] (len=3, tl=0) 1,10,3\r\n##  @0x00000000099cf870 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 100,100,100\r\nqd2[1,] <- c(100, 100)\r\n.Internal(inspect(qd2))\r\n## @0x00000000064d34b8 19 VECSXP g0c2 [OBJ,REF(1),ATT] (len=2, tl=0)\r\n##  @0x00000000099cf5a0 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 100,10,3\r\n##  @0x00000000099cf550 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 100,100,100\r\n## ATTRIB:\r\n## ...\r\n\r\n\r\n\r\nPodemos perceber ao final algumas características para a modificação no local:\r\ncontagem de referência;\r\nobjetos associados a apenas um nome;\r\nobjetos tipo \"Environment\", ambientes. Será apresentado apenas nas seções seguintes, quando aprofundamentos as características desse tipo de objeto.\r\nPor fim, não poderíamos de reforçar o exemplo apresentado na Figura 4. Esses dois objetos são vetores tipo character, isto é string. Apesar de apresentarmos dessa forma: x <- c(\"a\", \"b\", \"d\"), e parecer um objeto alocado em um mesmo espaço de memória para armazenar seus valores, o que temos na realizadade é um ponteiro para cada elemento do vetor, apontando para uma string única dentro do conjunto de caracteres (strings) global, que nesse caso é um objeto tipo CHARSXP, apresentada na seção Objetos base, acessível apenas internamente ao ambiente R. Vejamos alguns exemplos pelo código a seguir.\r\n\r\n\r\n# Criamos tres objetos tipo 'character'\r\nx <- c(\"a\", \"b\", \"d\")\r\ny <- c(\"a\", \"abc\", \"e\")\r\nz <- c(\"f\", \"abc\", \"b\")\r\n# Inspecionando os objetos\r\n.Internal(inspect(x))\r\n## @0x0000000006f84908 16 STRSXP g0c3 [REF(1)] (len=3, tl=0)\r\n##  @0x0000000006589e38 09 CHARSXP g0c1 [MARK,REF(10),gp=0x61] [ASCII] [cached] \"a\"\r\n##  @0x0000000006c3d580 09 CHARSXP g0c1 [MARK,REF(14),gp=0x60] [ASCII] [cached] \"b\"\r\n##  @0x0000000006a5ec00 09 CHARSXP g0c1 [MARK,REF(5),gp=0x61] [ASCII] [cached] \"d\"\r\n.Internal(inspect(y))\r\n## @0x0000000006f84868 16 STRSXP g0c3 [REF(1)] (len=3, tl=0)\r\n##  @0x0000000006589e38 09 CHARSXP g0c1 [MARK,REF(10),gp=0x61] [ASCII] [cached] \"a\"\r\n##  @0x0000000006984360 09 CHARSXP g0c1 [REF(7),gp=0x60] [ASCII] [cached] \"abc\"\r\n##  @0x0000000000393188 09 CHARSXP g0c1 [MARK,REF(5),gp=0x61] [ASCII] [cached] \"e\"\r\n.Internal(inspect(z))\r\n## @0x0000000006f847c8 16 STRSXP g0c3 [REF(1)] (len=3, tl=0)\r\n##  @0x000000000641d518 09 CHARSXP g0c1 [MARK,REF(6),gp=0x61] [ASCII] [cached] \"f\"\r\n##  @0x0000000006984360 09 CHARSXP g0c1 [REF(7),gp=0x60] [ASCII] [cached] \"abc\"\r\n##  @0x0000000006c3d580 09 CHARSXP g0c1 [MARK,REF(14),gp=0x60] [ASCII] [cached] \"b\"\r\n# Se alterar apenas a 'string', ocorre apenas a mudanca do \r\n# apontamento com modificacao local\r\nx[2] <- \"f\"\r\n.Internal(inspect(x))\r\n## @0x0000000006f84908 16 STRSXP g0c3 [REF(1)] (len=3, tl=0)\r\n##  @0x0000000006589e38 09 CHARSXP g0c1 [MARK,REF(10),gp=0x61] [ASCII] [cached] \"a\"\r\n##  @0x000000000641d518 09 CHARSXP g0c1 [MARK,REF(9),gp=0x61] [ASCII] [cached] \"f\"\r\n##  @0x0000000006a5ec00 09 CHARSXP g0c1 [MARK,REF(5),gp=0x61] [ASCII] [cached] \"d\"\r\n# Alterando os elementos, bem como sua dimensao, ocorrera a copia \r\n# do objeto STRSXP, porem os elementos continuam apontando para as suas \r\n# respectivas 'strings' globais\r\nx[4] <- \"f\"\r\n.Internal(inspect(x))\r\n##@0x0000000006988190 16 STRSXP g0c3 [REF(1)] (len=4, tl=0)\r\n##  @0x0000000006589e38 09 CHARSXP g0c1 [MARK,REF(11),gp=0x61] [ASCII] [cached] \"a\"\r\n##  @0x000000000641d518 09 CHARSXP g0c1 [MARK,REF(13),gp=0x61] [ASCII] [cached] \"f\"\r\n##  @0x0000000006a5ec00 09 CHARSXP g0c1 [MARK,REF(6),gp=0x61] [ASCII] [cached] \"d\"\r\n##  @0x000000000641d518 09 CHARSXP g0c1 [MARK,REF(13),gp=0x61] [ASCII] [cached] \"f\"\r\n\r\n\r\n\r\nPela Figura 9, podemos entender o que ocorrer nesses objetos. Para a situação de cópia, isso ocorrerá apenas se houver a alteração da dimensão do vetor. Caso, contrário a modificação ocorre no local.\r\n\r\n\r\n\r\nFigure 9: Cópia de quadro de dados (data frames).\r\n\r\n\r\n\r\nTamanho de objetos\r\nQuando falamos sobre tamanho de objetos, estamos pensando no quanto de memória é preciso para armazenar o objeto em seu computador. Porém, em algumas situações pode ser questionável esse tamanho, quando temos objetos cujos elementos são referências para objetos já existentes ou objetos existentes propriamente dito. Outra forma, ocorre quando há o compartilhamento de objetos em objeto listas ou data frames. A forma de verificarmos esse tamanho, pode ser por meio das funções, object.size() e lobstr::obj_size(). A primeira função quando temos comportilhamento de objetos em listas ou quadro dados por exemplo, pode superestimar o tamanho de memória para o referido objeto. Vamos observar alguns casos como esses, a seguir.\r\nO tamanho dos objeto está relacionado com a cópia ou modificação no local. Além do mais, devemos notar também que listas e quadro de dados apontam para objetos que podem estar compartilhados, e algumas funções podem apresentar uma superestimativa do tamanho, que é o caso da função object.size(). Vamos comparar o resultado dessa função com lobstr::obj_size() na Figura 10.\r\n\r\n\r\n\r\nFigure 10: Tamanho de memória de listas.\r\n\r\n\r\n\r\nObservamos que o objeto z é uma lista com cinco elementos, em que as referências apontam para o mesmo objeto. A estimativa de object.size() considera que os elementos apontam para objetos diferentes, quando na realidade está havendo um compartilhamento. Desse modo, o resultado de lobstr::obj_size() é bem menor e mais próximo do tamanho real, aproximadamente cinco vezes menor que o tamanho encontrado por object.size().\r\nNo caso dos vetores tipo character como já falado anteriormente, iremos perceber que repetir uma string 1000 vezes, não significará multiplicar mil vezes o tamanho da memória reservada para essa string para armazenar esse objeto. O que ocorre é que o vetor armazena mil referências nos elementos para apontar para o mesmo objeto CHARSXP. Chamado uma vez uma determinada string em um objeto, poderemos observar que enquanto não fecharmos o nosso ambiente de trabalho, o espaço de memória alocada para essa string será sempre a mesma, seja usada nesse objeto ou em outros que possam ser de interesse. Nesse caso, percebamos que uma vez usada uma determinada string em um objeto, por ventura se for utilizada também em outros objetos, não estaremos ocupando mais memória específica para armazenar essa string, mas sim, se houver um acréscimo de memória para armazená-lo, será apenas para a referência que aponta para esse objeto (CHARSXP) no conjunto global de strings. Vejamos um exemplo para ilustrar.\r\n\r\n\r\nx <- \"ben\"\r\nlobstr::obj_size(x)\r\n\r\n\r\n112 B\r\n\r\nobject.size(x)\r\n\r\n\r\n112 bytes\r\n\r\ny <- rep(x, 1000); y\r\n\r\n\r\n   [1] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [11] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [21] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [31] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [41] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [51] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [61] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [71] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [81] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n  [91] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [101] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [111] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [121] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [131] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [141] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [151] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [161] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [171] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [181] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [191] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [201] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [211] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [221] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [231] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [241] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [251] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [261] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [271] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [281] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [291] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [301] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [311] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [321] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [331] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [341] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [351] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [361] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [371] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [381] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [391] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [401] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [411] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [421] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [431] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [441] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [451] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [461] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [471] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [481] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [491] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [501] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [511] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [521] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [531] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [541] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [551] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [561] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [571] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [581] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [591] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [601] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [611] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [621] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [631] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [641] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [651] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [661] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [671] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [681] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [691] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [701] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [711] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [721] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [731] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [741] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [751] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [761] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [771] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [781] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [791] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [801] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [811] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [821] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [831] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [841] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [851] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [861] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [871] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [881] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [891] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [901] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [911] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [921] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [931] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [941] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [951] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [961] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [971] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [981] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n [991] \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\" \"ben\"\r\n\r\nlobstr::obj_size(x)\r\n\r\n\r\n112 B\r\n\r\nobject.size(x)\r\n\r\n\r\n112 bytes\r\n\r\nUma outra situação que vale a pena discutirmos é quando armazenamos objetos em listas, cujos os objetos são existentes com a inicialização do ambiente R, apresentado no código a seguir.\r\n\r\n\r\n# Objeto lista\r\nl1 <- list(median, range)\r\n# Quanto de memoria?\r\nlobstr::obj_size(l1)\r\n\r\n\r\n1,360 B\r\n\r\nA pergunta é, será que estamos utilizando, aproximadamente, toda essa memória para o objeto l1? Sabemos que as funções median() e range são do pacote base e com a inicialização do ambiente R, todos os objetos desse pacote são carregados, isto implica em um espaço de memória para alocar esses objetos. Podemos perceber também que o espaço de memória para armazenar esses objetos, são respectivamente, 1296 e 0, aproximadamente. O que os elementos de l1 fizeram foi guardar a referência que aponta para esses objetos, e que muito provavelmente não precisaria de toda a memória para armazenar todo o objeto. De outro modo, percebemos que o tamanho real do objeto não é o que se apresenta, uma vez que os objetos apontados nas referências dos elementos das listas já existem, e desse modo, não foram necessários para armazenar todo o objeto, mas apenas o seu identificador de memória (referência). Vejamos o código a seguir, para confirmar o que acabamos de discutir.\r\n\r\n\r\n# Inspecionando as funcoes 'median' e 'range'\r\n.Internal(inspect(median))\r\n## @0x0000000006463210 03 CLOSXP g0c0 [MARK,REF(3)] \r\n## ...\r\n.Internal(inspect(range))\r\n## @0x0000000000368688 08 BUILTINSXP g0c0 [MARK,REF(65535)] \r\n# Inspecionando o objeto 'l1'\r\nl1 <- list(median, range)\r\n.Internal(inspect(l1))\r\n## @0x000000000038f300 19 VECSXP g0c2 [REF(1)] (len=2, tl=0)\r\n##  @0x0000000006463210 03 CLOSXP g0c0 [MARK,REF(4)] \r\n##   ...\r\n##  @0x0000000000368688 08 BUILTINSXP g0c0 [MARK,REF(65535)] \r\n\r\n\r\n\r\nO identificadores de memória quando inspecionamos as funções median e range, são os mesmos identificadores para onde os elementos de l1 apontam, confirmando assim, que esses espaços de memória já estavam reservados, e não foram alocados com a criação do objeto.\r\nPor fim, como já mencionado no módulo básico, a representação alternativa (ALTREP) de uma sequência de elementos, por meio de “:” pode nos causar expanto, porque independente do comprimento, é armazenado apenas o primeiro e o último elemento da sequência. Isso significa que os vetores criados a partir de :, terão mesmo tamanho. Contudo, quando falos\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n Aprofundamento sobre ambientes\r\n\r\nAntes de iniciarmos um aprofundamento sobre ambientes, sugerimos a revisão introdutório desse assunto, no módulo básico, na seção Ambientes e Caminho de busca. O que falaremos nessa seção, pressupomos o entendimento que foi estudado no módulo anterior.\r\nA primeira ideia ilustrada que iremos abordar é a hierarquização de ambientes pelo caminho de busca, usando search(). Sabemos que todo ambiente tem um pai ou ambiente superior, e que a única excessão é o ambiente vazio, emptyenv(). A representação dessa hierarquização pode ser observada na Figura 11.\r\n\r\n\r\n\r\nFigure 11: Caminho por onde os objetos serão procurados.\r\n\r\n\r\n\r\nPara sabermos os parentais de um determinado ambiente, podemos recorrer ao pacote rlang. Por exemplo, vamos criar um ambiente, e verificar seus parentais, a seguir.\r\n\r\n\r\n# Ambiente\r\namb1 <- new.env()\r\n# Verificando os seus parentais\r\nrlang::env_parents(amb1, last = emptyenv())\r\n\r\n\r\n [[1]] $ <env: global>\r\n [[2]] $ <env: package:midrangeMCP>\r\n [[3]] $ <env: package:SMR>\r\n [[4]] $ <env: package:magrittr>\r\n [[5]] $ <env: package:leaflet>\r\n [[6]] $ <env: package:stats>\r\n [[7]] $ <env: package:graphics>\r\n [[8]] $ <env: package:grDevices>\r\n [[9]] $ <env: package:utils>\r\n[[10]] $ <env: package:datasets>\r\n[[11]] $ <env: package:methods>\r\n[[12]] $ <env: Autoloads>\r\n[[13]] $ <env: package:base>\r\n[[14]] $ <env: empty>\r\n\r\nObservemos que os parentais presentes, apresentou alguns ambientes como tools:rstudio, Autoloads. O primeiro sempre aparece quando usamos a IDE RStudio. O ambiente Autoloads, que pode ser acessado por .AutoloadEnv, é um ambiente que armazena promessas de ligações. Por exemplo, podemos estar interessados em usar a função makeCluster do pacote parallel, porém, ao invés de carregar o pacote e alocar memória para armazenar todos o seus objetos, podemos deixar a função makeCluster como promessa no ambiente Autoloads, e caso seja utilizado em alguma linha de comando, uma outra função autoloader() é acionada, carregando o pacote parallel e a função de interesse e reavaliada no ambiente do pacote parallel. Qual a vantagem disso? Enquanto a função não é chamada, é como se o pacote estivesse carregado, porém sem ocupar nenhuma memória. Vejamos o exemplo a seguir.\r\n\r\n\r\n# Promessa makeCluster\r\nautoload(\"makeCluster\", \"parallel\")\r\n# Caminho de busca sem o pacote 'parallel'\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"package:midrangeMCP\" \"package:SMR\"        \r\n [4] \"package:magrittr\"    \"package:leaflet\"     \"package:stats\"      \r\n [7] \"package:graphics\"    \"package:grDevices\"   \"package:utils\"      \r\n[10] \"package:datasets\"    \"package:methods\"     \"Autoloads\"          \r\n[13] \"package:base\"       \r\n\r\n# Verificamos que 'makeCluster' esta como promessa\r\nls(\"Autoloads\")\r\n\r\n\r\n[1] \"makeCluster\"\r\n\r\n# Chamando a funcao\r\nmakeCluster\r\n\r\n\r\nfunction (spec, type = getClusterOption(\"type\"), ...) \r\n{\r\n    switch(type, PSOCK = makePSOCKcluster(names = spec, ...), \r\n        FORK = makeForkCluster(nnodes = spec, ...), SOCK = snow::makeSOCKcluster(names = spec, \r\n            ...), MPI = snow::makeMPIcluster(count = spec, ...), \r\n        NWS = snow::makeNWScluster(names = spec, ...), stop(\"unknown cluster type\"))\r\n}\r\n<bytecode: 0x000000002798f5d8>\r\n<environment: namespace:parallel>\r\n\r\n# Verificando novamente o Caminho de busca,\r\n# agora com o pacote 'parallel'\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"package:parallel\"    \"package:midrangeMCP\"\r\n [4] \"package:SMR\"         \"package:magrittr\"    \"package:leaflet\"    \r\n [7] \"package:stats\"       \"package:graphics\"    \"package:grDevices\"  \r\n[10] \"package:utils\"       \"package:datasets\"    \"package:methods\"    \r\n[13] \"Autoloads\"           \"package:base\"       \r\n\r\nQuando a função de interesse, que estava como promessa, é chamada, observamos que o pacote que contempla essa função é carregado e passa a ser anexado ao caminho de busca. Uma outra situação interessante é que ao anexar um pacote, o ambiente de pacote (package:nome_pacote), será o pai do ambiente global. Daremos mais detalhes sobre ambiente de pacote mais a frente.\r\nSabemos que o ambiente global é o ambiente corrente quando executamos a maioria de nossas linhas de comando, mas podemos também usar a chamada environment() para tal. Pelo caminho de busca ou caminho de pesquisa, o ambiente R procura pelos objetos. Assim, digitando alguma linha de comando no console, a primeira busca por um objeto, do qual um nome está associado a ele, se iniciará pelo ambiente global (.GlobalEnv), caso não encontre o nome específico no ambiente global, o ambiente R procurará pelo nome no ambiente pai, que no caso da Figura 11, será o ambiente package:stats, e assim por diante. Não encontrando o nome específico em algum dos ambientes, a execução do comando retornará um erro informando que o objeto não foi encontrado. Vejamos o código a seguir.\r\n\r\n\r\nx <- c(1, 2, 4)\r\nmean(x)\r\n\r\n\r\n[1] 2.333333\r\n\r\nObservemos que três chamadas de funções foram realizadas, <-, mean() e c(). Essas funções não estão no ambiente global, que poderiam ser inspecionadas por ls(). Desse modo, o ambiente R procurará por todo o caminho de busca, e os encontrará no ambiente package:base. Uma vez encontrado, as funções são chamadas e a execução das linhas ocorrem com sucesso, Figura 12.\r\n\r\n\r\n\r\nFigure 12: Procurando por funções.\r\n\r\n\r\n\r\nO que é interessantes em ambientes é que eles podem se conter, e ainda mais, as modificações ocorridas nos ambientes, modificam no local e não ocorrem cópias, como ocorre na maioria das situações com outros objetos, e algumas vezes isso é chamado de semâtica de referência, porque mesmo alterando o objeto as suas ligações continuam com as mesmas referências. Vejamos a Figura 13, como um exemplo, e seu respectivo código na sequência para inspeção do que acabamos de falar.\r\n\r\n\r\n\r\nFigure 13: Criando ambientes.\r\n\r\n\r\n\r\n\r\n\r\n# Ambiente\r\namb1 <- new.env(hash = FALSE)\r\n# Inserindo objetos nesse ambiente\r\namb1$a <- c(1, 2, 4); amb1$b <- \"a\"; amb1$d <- TRUE\r\n# Inspecao do objeto.\r\nInternal(inspect(amb1))\r\n## @0x000000000db22758 04 ENVSXP g0c0 [REF(1)] <0x000000000db22758>\r\n## FRAME:\r\n##  @0x000000000db213a8 02 LISTSXP g0c0 [REF(1)] \r\n##    TAG: @0x00000000078ebb28 01 SYMSXP g0c0 [MARK,REF(128)] \"d\"\r\n##    @0x000000000db1fa38 10 LGLSXP g0c1 [REF(3)] (len=1, tl=0) 1\r\n##    TAG: @0x000000000db1c4b8 01 SYMSXP g0c0 [REF(10)] \"b\"\r\n##    @0x000000000db1fae0 16 STRSXP g0c1 [REF(3)] (len=1, tl=0)\r\n##      @0x0000000006369e78 09 CHARSXP g0c1 [MARK,REF(14),gp=0x61] [ASCII] [cached] \"a\"\r\n##    TAG: @0x0000000006483320 01 SYMSXP g0c0 [MARK,REF(60)] \"a\"\r\n##    @0x000000000db186f8 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,2,4\r\nENCLOS:\r\n##  @0x0000000005fda628 04 ENVSXP g0c0 [MARK,REF(65535),GL,gp=0x8000] <R_GlobalEnv>\r\namb1$a[2] <- 10\r\n.Internal(inspect(amb1))\r\n## @0x000000000db22758 04 ENVSXP g0c0 [REF(1)] <0x000000000db22758>\r\n## FRAME:\r\n##  @0x000000000db213a8 02 LISTSXP g0c0 [REF(1)] \r\n##    TAG: @0x00000000078ebb28 01 SYMSXP g0c0 [MARK,REF(128)] \"d\"\r\n##    @0x000000000db1fa38 10 LGLSXP g0c1 [REF(3)] (len=1, tl=0) 1\r\n##    TAG: @0x000000000db1c4b8 01 SYMSXP g0c0 [REF(10)] \"b\"\r\n##    @0x000000000db1fae0 16 STRSXP g0c1 [REF(3)] (len=1, tl=0)\r\n##      @0x0000000006369e78 09 CHARSXP g0c1 [MARK,REF(16),gp=0x61] [ASCII] [cached] \"a\"\r\n##    TAG: @0x0000000006483320 01 SYMSXP g0c0 [MARK,REF(62)] \"a\"\r\n##    @0x000000000db186f8 14 REALSXP g0c3 [REF(1)] (len=3, tl=0) 1,10,4\r\n## ENCLOS:\r\n##  @0x0000000005fda628 04 ENVSXP g0c0 [MARK,REF(65535),GL,gp=0x8000] <R_GlobalEnv>\r\nparent.env(amb1)\r\n## <environment: R_GlobalEnv>\r\n\r\n\r\n\r\nDe um modo geral, apresentamos a Tabela 3 para mostrar as principais funções para manipulações com ambientes\r\nTable 3:  Funções para ambientes.\r\nFunção\r\nObjetivo\r\nglobalenv() ou .GlobalEnv\r\nAmbiente global\r\nbaseenv()\r\nAmbiente do pacote base\r\nemptyenv()\r\nAmbiente vazio\r\nenvironment()\r\nAmbiente corrente\r\nsearch()\r\nLista o caminho de busca\r\nnew.env()\r\nCriando um ambiente\r\nparent.env()\r\nIdentificando o ambiente pai\r\nparent.frame()\r\nAmbiente funcional de chamada\r\nls() ou ls.str()\r\nDescreve os objetos do ambiente\r\nget()\r\nAcessa o(s) valor(es) dos objetos de um ambiente\r\nexists()\r\nVerificando a existência de um objeto em um ambiente\r\nidentical()\r\nVerificando a equivalência de ambientes\r\nAmbientes especiais\r\nPrecisamos apresentar alguns ambientes especiais, importantes para o entendimento do ambiente R.\r\nAmbientes funcionais\r\nDistinguimos quatro tipos de ambientes funcionais, que são:\r\nAmbiente envolvente ou ambiente de função;\r\nAmbiente de ligação;\r\nAmbiente de execução;\r\nambiente de chamada;\r\nEsses ambientes são extremamente importantes, para o entendimento do escopo léxico do ambiente R, uma vez que tudo no R é uma chamada de função (Segundo princípio), de modo que, o ambiente envolvente, de execução e de chamada estarão relacionados a forma de como a função procurará pelos objetos, ao passo que o ambiente de ligação estará relacionado a forma de como os usuários procurarão pelas funções.\r\nNa Figura 14, apresentamos o ambiente envolvente e o ambiente de ligação, para o seguinte código:\r\n\r\n\r\n# Criando o ambiente 'amb1'\r\namb1 <- new.env()\r\n# Objeto x em 'amb1'\r\namb1$x <- 1\r\n# Objeto x no ambiente global\r\nx <- 2\r\n# Criando a funcao 'h' em 'amb1'\r\namb1$h <- function() x\r\n# chamando a funcao h()\r\namb1$h()\r\n\r\n\r\n[1] 2\r\n\r\n# vericando o id de memoria de amb1\r\namb1 # ou .Internal(address(amb1))\r\n\r\n\r\n<environment: 0x000000004212db70>\r\n\r\n# Ambiente envolvente de 'h'\r\nenvironment(amb1$h)\r\n\r\n\r\n<environment: R_GlobalEnv>\r\n\r\nNesse caso, observemos que para acessarmos a função h, precisamos saber qual o seu ambiente de ligação, por isso acessamos essa função por amb1$h. Ao chamarmos amb1$h(), foi retornado o valor 2, Por quê? Esse resultado ocorre, porque ao ser criação o ambiente de execução para armazenar as ligações que ocorrerão no corpo da função, foi observado que não existia um nome x associado a algum objeto, nesse caso, a função passa a procurar no ambiente pai, que é o ambiente envolvente, e lá é encontrado o nome x associado ao valor 2. Desse modo, conseguimos compreender que o ambiente de ligação serve apenas para nós usuários encontrarmos a função h(), mas em nada serve para que h() encontre os objetos.\r\n\r\n\r\n\r\nFigure 14: Ambiente envolvente e ambiente de ligação.\r\n\r\n\r\n\r\nA função vincula o ambiente corrente no momento de sua criação, e pode ser verificado por environment(). Vejamos o código a seguir.\r\n\r\n\r\n# Criando a funcao f1\r\nf1 <- function() 1\r\n# Verificando o ambiente envolvente de f1\r\nenvironment(f1)\r\n\r\n\r\n<environment: R_GlobalEnv>\r\n\r\n# Criando uma funcao f\r\nf <- function() {\r\n  # ambiente de execucao\r\n  cat(\"Ambiente de execucao de f: \\n\")\r\n  print(environment())\r\n  # Criando uma funcao f2\r\n  f2 <- function() 2\r\n  # Verificando o ambiente envolvente de f2\r\n  cat(\"Ambiente envolvente de f2:\\n\")\r\n  print(environment(f2))\r\n}\r\nf()\r\n\r\n\r\nAmbiente de execucao de f: \r\n<environment: 0x00000000430e0420>\r\nAmbiente envolvente de f2:\r\n<environment: 0x00000000430e0420>\r\n\r\nObservamos que a função f1 foi criada no ambiente global, e que a função f2 foi criada no ambiente de execução da função f, por isso a distinção dos ambientes envolventes dessas duas funções. Cada função terá apenas um ambiente envolvente.\r\nNo módulo básico, falamos sobre o ambiente de execução. Este ambiente é criado quando fazemos uma chamada de função. Após finalizado a chamada da referida função e retornado o valor desejado, este ambiente desaparece. O ambiente de execução tem como o pai o ambiente envolvente, e podemos representá-lo pela Figura 15, para o código a seguir.\r\n\r\n\r\n\r\nFigure 15: Ambiente envolvente e ambiente de execução.\r\n\r\n\r\n\r\nEsse ambiente, apresenta muitas características como a máscara de nome e o novo começo, apresentados na seção Escopo léxico, no módulo básico.\r\nPor fim, surge o último ambiente que é o ambiente de chamada, e está relacionado ao escopo dinâmico das funções em R, assunto também abordado na seção Escopo léxico, no módulo básico. Na realidade, diremos que os pais do ambiente de execução são o ambiente envolvente e o ambiente de chamada. Daí surge o escopo dinâmico, do qual a busca por objetos não sendo encontrado no ambiente de execução, será procurado no ambiente de chamada ao invés do ambiente envolvente. Apesar, de termos apresentado um exemplo no módulo básico sobre essa característica, vamos reforçar com um outro exemplo, no código a seguir.\r\n\r\n\r\n# Fabrica de funcoes\r\nh <- function() {\r\n  x <- 1\r\n  function() {\r\n    amb_envolvente <- get(\"x\", environment())\r\n    amb_chamada <- get(\"x\", parent.frame())\r\n    list(envolvente = amb_envolvente, chamada = amb_chamada)\r\n  }\r\n}\r\n# Funcao g\r\ng <- h()\r\n# Definindo 'x' no ambiente global\r\nx <- 20\r\n# Chamada de g(), e verificando 'x' no ambiente de envolvente e de chamada\r\ng()\r\n\r\n\r\n$envolvente\r\n[1] 1\r\n\r\n$chamada\r\n[1] 20\r\n\r\nAmbientes em pacotes\r\nUm detalhamento sobre ambientes em pacotes, bem como o desenvolvimento de pacotes, sugerimos acessar o projeto meupacoter, como também o livro Desenvolvimento de pacotes R.\r\nExistem dois ambientes em pacotes, quais sejam:\r\nAmbientes de pacotes,\r\nAmbientes namespace.\r\nDizemos que o ambiente de pacote é o local em que os usuários procuram pelos objetos. O ambiente de pacote estará disponível no ambiente de busca, e quando um pacote é anexado anexado, o ambiente de pacote do referido pacote, será o pai do ambiente global, e o pai do ambiente de pacote segue a hierarquia do caminho de busca. Vejamos o código a seguir.\r\n\r\n\r\n# Caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"package:parallel\"    \"package:midrangeMCP\"\r\n [4] \"package:SMR\"         \"package:magrittr\"    \"package:leaflet\"    \r\n [7] \"package:stats\"       \"package:graphics\"    \"package:grDevices\"  \r\n[10] \"package:utils\"       \"package:datasets\"    \"package:methods\"    \r\n[13] \"Autoloads\"           \"package:base\"       \r\n\r\n# Anexando o pacote 'parallel'\r\nlibrary(parallel)\r\n# Verificando novamente o caminho de busca\r\nsearch()\r\n\r\n\r\n [1] \".GlobalEnv\"          \"package:parallel\"    \"package:midrangeMCP\"\r\n [4] \"package:SMR\"         \"package:magrittr\"    \"package:leaflet\"    \r\n [7] \"package:stats\"       \"package:graphics\"    \"package:grDevices\"  \r\n[10] \"package:utils\"       \"package:datasets\"    \"package:methods\"    \r\n[13] \"Autoloads\"           \"package:base\"       \r\n\r\nVerifiquemos que o ambiente de pacote parallel passa a ser o pai do ambiente global, após a anexação ao caminho de busca. Uma outra forma de acessar uma função de um pacote sem anexá-lo, é por meio da chamada “::” Contudo, vale salientar que nessa última situação houve apenas o carregamento de uma determinada função, sem anexo ao caminho de busca, e isto significa a disponibilidade do pacote na memória ativa. No caso, da anexação de um pacote ao caminho de busca, além do carregamento ocorre a anexação do referido pacote. Após isso, podemos acessar as suas funções, digitando os nomes das referidas funções sem precisar mencionar o pacote em que estas estão disponíveis.\r\nO outro ambiente é fundamental para a procura interna dos objetos, e esse é o ambiente namespace. O ambiente de pacote é como uma cópia do ambiente namespace, porque as mesmas ligações encontradas em um ambiente, também está no outro. Por exemplo, vejamos o próximo código.\r\n\r\n\r\n# Veja como uma funcao capta a informacao do ambiente global\r\ny <- 2\r\naux <- function() {\r\n  return(y)\r\n}\r\naux()\r\n\r\n\r\n[1] 2\r\n\r\n# Testando a funcao sd(x)\r\n#------------------------\r\nx <- 1:3 # o resultado de sd(x) de ser 1!\r\n# Criar uma variavel no ambiente global, 'var = \"Nada\"'. \r\n# Isso, implica que se 'sd' usar essa informacao, devera retornar um erro, pq sd se baseia em um vetor numerico\r\nvar <- \"Nada\"\r\n\r\n# Verificando a funcao 'sd()' internamente\r\nsd\r\n\r\n\r\nfunction (x, na.rm = FALSE) \r\nsqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \r\n    na.rm = na.rm))\r\n<bytecode: 0x000000002ad2b308>\r\n<environment: namespace:stats>\r\n\r\n# Testando sd(x)\r\nsd(x)\r\n\r\n\r\n[1] 1\r\n\r\n# Agora veja uma outa situacao:\r\nx <- c(1, 2, 3)\r\n\r\n# Funcao 'var' que criamos, que nao calcula variancia de dados\r\nvar <- function(x) return(\"Nada\")\r\n\r\n# Funcao que depende de 'var' do pacote stats, e calcula a variancia \r\naux2 <- function(x) {\r\n  vari <- var(x)\r\n  return(vari)\r\n}\r\n# O resultado mostra, que a funcao aux como esta no ambiente global, ela não \r\n# tem um namespace porque nao esta em pacote algum. No caminho de busca, \r\n# o ambiente do pacote 'stats' estara na posicao 3, isso significa \r\n# que a funcao aux ao buscar por 'var', encontrarar primeiro no \r\n# ambiente global, que nao seria o objeto desejado.\r\naux2(x)\r\n\r\n\r\n[1] \"Nada\"\r\n\r\nAntes de detalharmos a ideia do ambiente de namespace, precisamos entender uma estrutura do pacote que é um arquivo chamado NAMESPACE. Esse arquivo é responsável para definir quais os objetos de outros pacotes iremos importar, quais os objetos do pacote em desenvolvimento desejamos disponibilizar. Alguns outros objetos, principalmente funções, estão disponíveis apenas internamente, por decisão do desenvolvedor, muitas vezes por questão de futuras atualizações, ou outras finalidades. Desse modo, é o ambiente namespace que armazena todas as ligações dos objetos exportados, objetos importados ou objetos interno ao referido pacote. Assim, mostraremos que é por causa desse ambiente, que alguns outros objetos que não pertencem ao pacote e que podem estar no ambiente global, com o mesmo nome, e não entram em conflito. No código anterior, temos um exemplo típico para justificar essa situação. A função var() calcula a variância de um conjunto de dados, do qual a função sd(), que calcula o desvio padrão, depende da função var(). Ao passo que, também criamos uma função var() no ambiente global, que em nada tem a ver com o cálculo da variância. Assim, veremos que a função sd() acessará corretamente a função var() do pacote stats, o que não ocorrerá com a função aux(), uma vez que esta função tem como ambiente envolvente o ambiente global. A explicação para isso se deve ao fato que as funções desenvolvidos e importadas para um pacote, segue uma hierarquia de ambientes iniciada pelo ambiente namespace, que segue:\r\nAmbiente namespace do referido pacote;\r\nAmbiente de importações do referido pacote;\r\nAmbiente namespace do pacote base;\r\nHierarquia de ambientes do caminho de busca.\r\nDesse modo, conseguimos entender o porquê a função sd() encontrar var() de forma correta, pela Figura 16.\r\n\r\n\r\n\r\nFigure 16: Mecanismo do ambiente namespace de um determinado pacote.\r\n\r\n\r\n\r\nObservemos que quando a função sd() é chamada, esta função não foi criada no ambiente global, mas no ambiente namespace:stats, cujas ligações também estão no ambiente package:stats. Assim, após o ambiente de execução dessa função ser criada temporariamente, todos os seus objetos se não encontrados nesse ambiente, partirão à procura no ambiente namespace do pacote. Desse modo, até chegar a busca pelo objeto no ambiente global, a função ainda procurará pelo ambiente imports:stats, se não encontrar segue para o ambiente namespace:base, e por fim entra no caminho de busca. Portanto, a função var() criada no ambiente global, para ter sido usada, em todos os ambientes anteriores não poderia ter existido esse objeto. Porém, como o desenvolvedor do pacote planeja todas as suas funções, certamente, isso nunca ocorrerá. Desse modo, o ambiente R evita que as funções desenvolvidas em um pacote tenham conflito com funções de outros pacotes.\r\n Programação funcional\r\nEnfim, chegamos propriamente dito ao segundo princípio do R, tudo nesse ambiente é uma chamada de função. Mas lembrando que uma função é também um objeto, com suas características (atribuições) assim como os vetores também apresentam.\r\nParece não ser evidente, mas já pensaram quantas chamadas de função ocorrem na linha de comando a seguir?\r\n\r\n\r\nx <- mean(1:10)\r\n\r\n\r\n\r\nApesar de intuitivo, mas o símbolo de atribuição (<-) é uma função, mean é outra função, : também, bem como (. Por fim, quando digitamos o nome x para verificar o resultado no console, por trás existe a função print trabalhando para isso. Por isso, dizemos que tudo no R é uma chamada de função.\r\nTanto no módulo básico quanto nesse módulo, já discutimos algumas propriedades importantes das funções, como o seu escopo léxico e dinâmico, a característica do ambiente R ter funções de primeira classe, os ambientes envolvidos em uma função, função anônima, dentre outros assuntos.\r\nDiscutimos também que uma função do tipo closure, apresenta três estruturas: os argumentos (formals()), o corpo (body()) e o ambiente (environment()). Porém, as funções primitivas, do tipo special ou buitin, fogem a essa regra porque foram implementadas em linguagem de baixo nível, isto é, em linguagem C. Já mostramos também como identificar essas funções nas seções anteriores, e todas elas se encontram no pacote base.\r\nCompreendemos também que uma função é chamada quando ditamos o seu nome e entre parênteses inserimos os seus argumentos. Podemos também por meio, da função do.call(), repassar os argumentos por meio de uma lista, que segue:\r\n\r\n\r\nargumentos <- list(x = 1:10, main = \"Gráfico\", \r\n                   xlab = \"Eixo X\", ylab = \"Eixo Y\")\r\ndo.call(plot, argumentos)\r\n\r\n\r\n\r\n\r\nComposição de funções\r\nNo módulo básico, também vimos a composição de funções, construídas em blocos, aninhadas, resultados intermediários como objetos. Mas, surge uma quarta via, implementada pelo pacote magrittr, que é o operador pipe. Essa ideia, segundo Wickham (2019), foi inspirada nas linguagens Haskell, F#, Julia, JavScript, um estilo baseado em pilhas como forth e Fator. Esse estilo apresenta uma estrutura mais fácil de sequências de operações da esquerda para direitra, evita funções aninhadas ou definição de funções. Para a análise de dados esse operador no ambiente R ganhou tanto respaldo, que foi implementado uma forma nativa na versão R 4.1. O operador pipe é binário, em que o primeiro operando (lhs) representa o valor do primeiro argumento do segundo operando (rhs), que representa uma função, isto é,\r\n\r\nlhs %>% rhs # Pipe do pacote 'magrittr'\r\nlhs |> rhs  # Pipe nativo do pacote 'base'\r\n\r\nUma tabulação básica para compreensão pode ser apresentada na Tabela\r\nTable 4:  Tabulação básica para o operador pipe.\r\nSintaxe\r\nEquivalência\r\nx %>% f ou x |> f\r\nf(x)\r\nx %>% f(y) ou x |> f(y)\r\nf(x, y)\r\nx %>% f %>% g %>% h ou x |> f |> g |> h\r\nh(g(f(x)))\r\nDesse modo, podemos pensar em uma sequencia de comandos mais simples, até algo mais complexo. Vejamos o código a seguir.\r\n\r\n\r\nmtcars |> head()  \r\n\r\n\r\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\r\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\r\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\r\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\r\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\r\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\r\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\r\n\r\nmtcars |> subset(cyl == 4) |> nrow()\r\n\r\n\r\n[1] 11\r\n\r\nmtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()\r\n\r\n\r\n\r\nCall:\r\nlm(formula = mpg ~ disp, data = d)\r\n\r\nCoefficients:\r\n(Intercept)         disp  \r\n    40.8720      -0.1351  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nOperadores binários ou unários\r\nNa seção Manipulando vetores (Módulo básico), falamos sobre alguns operadores: matemáticos, lógicos, booleanos. Todos estes são operadores binários ou unários, que na mais são do que funções. Dizemos que um operador é unário quando há apenas a exigência de um operando na operação. Quando há a existência de dois operandos, dizemos que o operador é binário. Por exemplo, o operador soma + pode ser unário ou binário, pois sintaticamente, podemos escrever a operação soma com um operando ou com dois operandos. Vejamos o código a seguir.\r\n\r\n\r\n# Como operador unario\r\n+2 # operador operando1\r\n\r\n\r\n[1] 2\r\n\r\n# Como operador binario\r\n2 + 5 # operando1 operador operando2\r\n\r\n\r\n[1] 7\r\n\r\nIsso significa dizer que o operador pipe é binário, em que o primeiro operando é um valor e o segundo operando é uma função. Alguns exemplos de operadores que também podem ser encontrados por ?Sintax, ::, :::, $, @, [, [[, ^, +, -, :, |>, %%, %/%, %*%, %x%, %o%, %in%, <, >, <=, =>, ==, !=, !, &, &&, |, ||, ~, ->, <-, <<-, =, ?, detre outros. Algumas dessas operações tem prevalência sobre outras, como por exemplo, no caso dos operadores matemáticos.\r\nPara sabermos o código interno de um operador, além do nome, escrevemos aspas invertidas envolta desse nome, isto é,\r\n\r\n[1] TRUE\r\nfunction (x, table) \r\nmatch(x, table, nomatch = 0L) > 0L\r\n<bytecode: 0x0000000006aff268>\r\n<environment: namespace:base>\r\n\r\nUma outra forma de identificarmos se um operador é binário ou unário, é verificando os seus argumentos. Por exemplo, o operador %in% apresenta os argumentos x e table, então no mínimo esse operador é binário. Isso ocorre porque quando verificamos os argumentos do operador soma,\r\n\r\n\r\n`+`\r\n\r\n\r\nfunction (e1, e2)  .Primitive(\"+\")\r\n\r\npercebemos que há dois argumentos, e1 e e2, mas este operador pode se comportar como operador unário, é como se e1 fosse NULL por padrão. Uma outra forma sintática de chamarmos um operador pode ser apresentado a seguir.\r\n\r\n\r\n`+`(e1 = 2, e2 = 5)\r\n\r\n\r\n[1] 7\r\n\r\nIsso é o mesmo de termos realizado a operação 2 + 5. Operadores criados pelos usuários sempre terão o símbolo de porcentagem (%) envolta dos nomes. Os demais operadores que não apresentam essa forma sintática são criados apenas pelo R Core Team.\r\nPara ilustrar a criação de um operador, vamos fazer o nosso próprio operador pipe.\r\n\r\n\r\n# Nosso operador pipe '%>>%'\r\n`%>>%` <- function(a, b) {\r\n  aux <- as.character(substitute(b))\r\n  exec <- call(aux, a)\r\n  eval(exec)\r\n}\r\n\r\n1:10 %>>% mean()\r\n\r\n\r\n[1] 5.5\r\n\r\nAvaliação preguiçosa dos argumentos de uma função\r\n\r\n\r\n\r\nOs argumentos em uma função são um tipo de objeto chamado pairlist, isto é,\r\n\r\n\r\n# Funcao f\r\nf <- function(x) 1\r\n# Tipo de objeto do argumento x\r\ntypeof(formals(f))\r\n\r\n\r\n[1] \"pairlist\"\r\n\r\nesse tipo de objeto é avaliado de forma “preguiçosa,” isto é, lentamente. Isso significa dizer computacionalmente, que enquanto esse argumento não for utilizado internamente na função, ele é tipo como uma promessa e não é avaliado. Vejamos um exemplo para entendermos melhor essa afirmação.\r\n\r\n\r\nf2 <- function(x = aux()) 10; f2()\r\n\r\n\r\n[1] 10\r\n\r\nA chamada f2() retorna o valor 10 sem erros, porque mesmo no argumento x recebendo uma função aux() que não existe, como internamente esse argumento não foi usado, x é apenas uma promessa. No ambiente R, não podemos manipular esse tipo de objeto, pois se assim fosse possível, o objeto deixaria de ser uma promessa.\r\nPor causa desse tipo de estrutura, que podemos ter outros argumentos padrão como função de outros argumentos ou até como função de outros objetos criados internamente a função. Vejamos,\r\n\r\n\r\nf3 <- function(a = 4, b = a + 2, c = x * y) {\r\n  x <- 10\r\n  y <- 100\r\n  list(a = a, # 4\r\n       b = b, # a + 2\r\n       c = c) # x * y\r\n}\r\nf3()\r\n\r\n\r\n$a\r\n[1] 4\r\n\r\n$b\r\n[1] 6\r\n\r\n$c\r\n[1] 1000\r\n\r\nNesse momento cabe enfatizarmos a diferença entre <- e =. Primeiro, devemos entender que qualquer um dos dois associam nomes a objetos, porém a primeira diferença existente entre os dois, é que o primeiro tem precedência superior. Vejamos o seguinte código:\r\n\r\n\r\ny <- x = 4\r\n\r\n\r\nError in y <- x = 4: não foi possível encontrar a função \"<-<-\"\r\n\r\nPor que esse exemplo gera um erro? Porque primeiro é executado y <- x (precedência superior de <- sobre =), em que x não é encontrado, e retorna um erro.\r\nUm outro ponto é que sintaticamente usamos o operador = para atribuir valores a argumentos de uma função, e <- para atribuir nomes a objetos, e este último deve ser a sintaxe recomendada para a atribuição de nomes a objetos.\r\nParece que semanticamente a atribuição de argumentos a valores são iguais, mas podemos ver que a seguir, apesar de sintaticamente as linhas de comando aparentemente idêntica, apresentam comportamentos e resultados diferentes\r\n\r\n\r\n\r\n\r\n\r\n# Funcao teste\r\nteste <- function(x = ls()) {\r\n  obj_ae <- \"Objeto_interno\"\r\n  x\r\n}\r\n# ls() avaliado dentro de teste():\r\nteste()\r\n\r\n\r\n[1] \"obj_ae\" \"x\"     \r\n\r\n# ls() avaliado no ambiente de chamada:\r\nteste(ls())\r\n\r\n\r\n[1] \"cran\"    \"github\"  \"rlink\"   \"rstudio\" \"teste\"  \r\n\r\nteste2 <- function(){\r\n  obj_teste2_1 <- \"primeiro\"\r\n  obj_teste2_2 <- \"segundo\"\r\n  obj_teste2_3 <- \"terceiro\"\r\n  teste(ls())\r\n}\r\nteste2()\r\n\r\n\r\n[1] \"obj_teste2_1\" \"obj_teste2_2\" \"obj_teste2_3\"\r\n\r\n# Objeto x avaliado no ambiente global\r\nteste((x <- ls()))\r\n\r\n\r\n[1] \"cran\"    \"github\"  \"rlink\"   \"rstudio\" \"teste\"   \"teste2\" \r\n\r\nteste((x <- ls()))\r\n\r\n\r\n[1] \"cran\"    \"github\"  \"rlink\"   \"rstudio\" \"teste\"   \"teste2\" \r\n[7] \"x\"      \r\n\r\nNa primeira situação temos a criação da função teste com um argumento padrão x = ls(). Nesse caso, ls() será avaliado no ambiente de execução da função, do qual pode ser confirmado com a chamada teste(). O segundo caso, a chamada teste(ls()) apresenta um resultado diferente, porque ls(), nesse caso, foi avaliado no ambiente de chamada, que pode também ser verificado na chamada teste2(). Por fim, a chamada teste((x <- ls())) apresenta um resultado diferente com relação ao caso anterior, pois x <- ls() é avaliado no ambiente global, nesse caso, e não como um promessa tal como x = ls() foi, sendo avaliado apenas internamente no ato de sua chamada.\r\nPor fim, podemos verificar se um argumento teve como entrada padrão, ou inserida pelo usuário, usando missing(). Vejamos o código, a seguir.\r\n\r\n\r\nteste <- function(arg = 5) {\r\n  list(\"argumento padrão?\" = missing(arg), valor = arg)\r\n}\r\n# Teste 1\r\nteste()\r\n\r\n\r\n$`argumento padrão?`\r\n[1] TRUE\r\n\r\n$valor\r\n[1] 5\r\n\r\n# Teste 2\r\nteste(4)\r\n\r\n\r\n$`argumento padrão?`\r\n[1] FALSE\r\n\r\n$valor\r\n[1] 4\r\n\r\nSaídas implícitas, explícitas, invisíveis de funções\r\nNo módulo Básico, mostramos a estrutura básica de como criar uma função, cujo corpo é delimitado por chaves, isto é,\r\n\r\n\r\nnova_funcao <- function(x) {\r\n  # Corpo da funcao\r\n  x\r\n}\r\n\r\n\r\n\r\nNesse caso, como a última linha de comando no corpo da função nova_funcao() a ser avaliada é x, então será esta o resultado da saída da função. Observamos que nesse caso, a última linha de comando imprime o valor de x. Dizemos nesse caso, que a função teve uma saída implícita. Se ao invés, a última linha de comando fosse a associação de um nome ao objeto, nada seria retornado após a chamada de função. Vejamos o próximo exemplo para o entendimento.\r\n\r\n\r\n# Funcao com saida implicita\r\nnova_funcao <- function(x) {\r\n  # Corpo da funcao\r\n  x\r\n}\r\nnova_funcao(2)\r\n\r\n\r\n[1] 2\r\n\r\n# Funcao com saida implicita sem resultado\r\nnova_funcao2 <- function(x) {\r\n  # Corpo da funcao\r\n  x <- x\r\n}\r\nnova_funcao2(4)\r\n\r\n\r\n\r\nEssa última chamada, acaba não aparecendo nada porque a avaliação x <- x, associa o nome x ao valor do argumento x, e isto não implica em imprimir esse valor. Contudo, podemos não necessariamente, apresentar como resultado de uma função, a sua última linha de comando. Nesse caso, usamos a função return(), para identificar qual objeto desejamos como saída para uma determinada função. Nesse caso, temos uma saída explícita.\r\n\r\n\r\nnum_par_ou_impar <- function(x) {\r\n  if (!is.numeric(x)) stop(\"o argumento x deve ser numerico\", call. = FALSE)\r\n  num <- as.integer(x)\r\n  if (num %% 2 == 0) {\r\n    return(\"Número par!\")\r\n  } else return(\"Número ímpar!\")\r\n}\r\n# Numero real eh coagido a inteiro sem arredondamento\r\nnum_par_ou_impar(1.6)\r\n\r\n\r\n[1] \"Número ímpar!\"\r\n\r\n# Programacao defensiva (x deve ser numerico)\r\nnum_par_ou_impar(TRUE)\r\n\r\n\r\nError: o argumento x deve ser numerico\r\n\r\n# Verificando se um numero eh par ou impar\r\nnum_par_ou_impar(6)\r\n\r\n\r\n[1] \"Número par!\"\r\n\r\nPercebemos que todas essas saídas implícita e explícita são saídas visíveis após a chamada da função. Porém, podemos ter saídas invisíveis, usando a função invisible(). Vejamos o código a seguir.\r\n\r\n\r\n# Funcao com saida invisivel\r\nestdes <- function(x) {\r\n  plot(x)\r\n  resumo <- summary(x)\r\n  invisible(resumo)\r\n}\r\n# Conjunto de dados\r\ny <- rexp(30)\r\n# Chamando estdes\r\nres <- estdes(y)\r\n# Imprimindo o resultado invisivel\r\nres\r\n\r\n\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \r\n 0.0224  0.2011  0.4991  0.9908  0.9524  7.8891 \r\n\r\n# Formas alternativas\r\nprint(estdes(y))\r\n\r\n\r\n\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \r\n 0.0224  0.2011  0.4991  0.9908  0.9524  7.8891 \r\n\r\n(estdes(y))\r\n\r\n\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \r\n 0.0224  0.2011  0.4991  0.9908  0.9524  7.8891 \r\n\r\n# Sinalizador de visibilidade\r\nwithVisible(estdes(y))\r\n\r\n\r\n$value\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \r\n 0.0224  0.2011  0.4991  0.9908  0.9524  7.8891 \r\n\r\n$visible\r\n[1] FALSE\r\n\r\nstr(withVisible(estdes(y)))\r\n\r\n\r\nList of 2\r\n $ value  : 'summaryDefault' Named num [1:6] 0.0224 0.2011 0.4991 0.9908 0.9524 ...\r\n  ..- attr(*, \"names\")= chr [1:6] \"Min.\" \"1st Qu.\" \"Median\" \"Mean\" ...\r\n $ visible: logi FALSE\r\n\r\nUm caso específico de função com resultado invisível é a atribuição (<-). Quando associamos um nome a um objeto, a saída dessa função é invisível, a menos que redigite o nome no console ou use entre parênteses essa linha de comando, isto é,\r\n\r\n\r\n# Funcao `<-`() com saida invisivel\r\nx <- 10\r\n# Acessando o valor do obj associado com o nome 'x'\r\nx\r\n\r\n\r\n[1] 10\r\n\r\n# Outra forma de acesso\r\n(x <- 10)\r\n\r\n\r\n[1] 10\r\n\r\nFunções de substituição\r\n\r\nMuito provavelmente, ao importar um banco de dados, armazenados em um objeto de classe data.frame, tivemos algum problema de erro em algum valor em nossas variáveis em estudo. Por exemplo, consideremos um banco de dados com informações de um grupo de pessoas, tais como o nome, altura (cm), peso (kg), idade (anos), que segue:\r\n\r\n\r\ndados <- data.frame(\r\n  nome = c(\"Paulo\", \"Maria\", \"Caio\"),\r\n  altura = c(175, 167, 172),\r\n  peso = c(70, 65, 7500),\r\n  idade = c(32, 26, 19)\r\n); dados\r\n\r\n\r\n   nome altura peso idade\r\n1 Paulo    175   70    32\r\n2 Maria    167   65    26\r\n3  Caio    172 7500    19\r\n\r\nSe esse banco foi importado, podemos alterar no próprio banco. Caso contrário, pode ser realizado uma substituição do valor no próprio ambiente R para o objeto específico, usando [, ou similares, dependendo do tipo de objeto. Para esse caso, percebemos que o peso de Caio (7500kg), muito provavelmente foi um erro de digitação, e e que na realidade seria 75kg como correção. Para fazermos essa alteração em dados, uma das possibilidades seria usar a função de substituição dados[3, 3] <- 75, em que a mudança ocorre na terceira linha e 3 coluna do data.frame. Como poderíamos criar uma função de substituição? Usando as mesmas ideias usadas nesse caso. A função de substituição para um caso geral, é dado da seguinte forma sintática:\r\n\r\n\r\n`[<-` <- function(x, i, value){\r\n  # Corpo da funcao\r\n}\r\n# Chamada de funcao\r\nx[i] <- value\r\n# Chamada de forma equivalente\r\n`[<-`(x, i, value)\r\n\r\n\r\n\r\nClaro que isso não é um padrão, mas uma ideia geral para a chamada [<-, que basicamente deve ter dois argumentos, x e value. O primeiro é o objeto em que há a necessidade de substituição de um de seus valores, e o segundo representa o valor para a substituição. Argumentos adicionais a estes, devem ser colocados entre esses argumentos, e à esquerda do argumento value, que foi o caso do argumento i, que representa a posição do elemento a ser substituído no objeto x. Por outro lado, devemos evitar a substituição de funções internas, como no caso da função (<-, por exemplo, uma vez que funções como essas usadas a todo momento em um código, pode trazer conflitos entre essas funções.\r\nVamos aprofundar um pouco mais essa questão, usando um exemplo mais simples para a compreensão, a seguir.\r\n\r\n\r\n# Vamos criar um vetor de comprimento 10\r\nx <- 1:10; x\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\n# Usando a funcao de substituicao, para alterar\r\n# dois valores na posicao 6 e 10\r\nx[c(6, 10)] <- c(100, 200); x\r\n\r\n\r\n [1]   1   2   3   4   5 100   7   8   9 200\r\n\r\nO que ocorre por trás, cuja referência pode ser confirmada no manual R Language Definition, seção 3.4.4, é que surge a criação de um nome temporário `*tmp*` que também se associa ao mesmo objeto associado ao nome x, cujas alterações são realizadas em `*tmp*`, e um novo objeto é criado e um novo nome se associa a ele, e para deixar a impressão de que a alteração é ocorrida no próprio objeto, esse novo nome é exatamente x, igual ao nome antigo.\r\n\r\n\r\n# Objeto x criado\r\nx <- 1:10\r\n# `*tmp*` temporariamente criado\r\n`*tmp*` <- x\r\n# Alteracoes realizadas\r\nx <- `[<-`(`*tmp*`, c(6, 10), valor = c(100, 200)); x\r\n\r\n\r\n [1]   1   2   3   4   5 100   7   8   9 200\r\n\r\n# Ao final se remove `*tmp*`\r\nrm(`*tmp*`)\r\n\r\n\r\n\r\nPor fim, `*tmp*` é removido, e nesse caso, ocorre a cópia do objeto, como pode ser verificado por meio chamada tracemen(), isto é,\r\n\r\n\r\n# Vamos criar um vetor de comprimento 10\r\nx <- 1:10; x\r\n## [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\n# Inspecionando o objeto\r\ntracemem(x)\r\n## [1] \"<000000965C8A97D8\"\r\n\r\n.Internal(inspect(x))\r\n## @0x000000965c8a97d8 13 INTSXP g0c0 [REF(65535),TR]  1 : 10 (compact)\r\n\r\n# Usando a funcao de substituicao, para alterar\r\n# dois valores na posicao 6 e 10\r\nx[c(6, 10)] <- c(100, 200); x\r\n## tracemem[0x000000965c8a97d8 - 0x000000965bdf6bc0]: \r\n## tracemem[0x000000965bdf6bc0 - 0x000000965f177418]: \r\n## [1]   1   2   3   4   5 100   7   8   9 200\r\n\r\n# Inspecionando novamente o objeto\r\n.Internal(inspect(x))\r\n## @0x000000965f177418 14 REALSXP g0c5 [REF(5),TR] (len=10, tl=0) 1,2,3,4,5,...\r\n\r\n\r\n\r\nObservamos inicialmente x (id 0x000000965c8a97d8), cujo nome `*tmp*` inicialmente se liga ao mesmo objeto, e após as substituições `*tmp*` passa a está alocado a um novo espaço de memória (id 0x000000965f177418), isto é ocorre uma cópia. A cópia intermediária (id 0x000000965bdf6bc0) que ocorre no processo é devido a chamada `:`(). Mas a pergunta que fica, como fica o entendimento da otimização de desempenho especial a modificação no local? Bem, o nosso entendimento para o caso de vetores, como já mostrado anteriormente, a ideia estará sempre na contagem de referência. Já vimos, que para a chamada `:`(), a primeira modificação realizada no objeto será modificação em cópia, pois REF(# > 1). Nesse caso, que foi o exemplo mostrado anteriormente, existe a presença de `*tmp*` por trás dos bastidores. Entretanto, quando o vetor é desenvolvido pela chamada c(), sabemos que a alteração do objeto ocorre em modificação no local, quando não alteraramos a dimensão do vetor, mas apenas os valores. Bem, o que indagamos é a existência ou não do nome temporário `*tmp*` no processo. Como falamos na seção em sobre cópia de objetos, afirmamos que um dos pré-requisitos para a modificação no local, é que o objeto só pode ter uma ligação, isto é, um nome associado ao objeto. E quando mostramos a forma sintática da função de substituição `[<- `(), percebemos que x e `*tmp*` se ligam ao mesmo objeto inicialmente, e assim, teoricamente deveria sempre haver cópia com a alteração de algum dos valores desse objeto. Desse modo, pressupomos que para esses casos de modificação no local, o processo seja um pouco diferente desse processo. Contudo, isso só ocorrerá para o caso da função de substituição primitiva ([<-), implementada em linguagem C. Quando desenvolvemos nossas próprias funções de substituição, aí sempre ocorrerá cópia na modificação.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nPara desenvolvermos as nossas próprias funções de substituição apresentamos um exemplo, criando a função `substextr<-`(), a seguir.\r\n\r\n\r\n# Funcao de substituicao de alterar os extremos\r\n`substextr<-` <- function(x, value) {\r\n  x <- sort(x)\r\n  x[1] <- x[length(x)] <- value\r\n  x\r\n}\r\n# Criando o vetor\r\nset.seed(10)\r\nx <- rnorm(10)\r\n# Inspecao\r\n.Internal(address(x))\r\n\r\n\r\n<pointer: 0x0000000044efd390>\r\n\r\n# Alterando o vetor\r\nsubstextr(x) <- 100\r\n# Inspecao\r\n.Internal(address(x))\r\n\r\n\r\n<pointer: 0x0000000044efc890>\r\n\r\nNesse caso, obrigatoriamente os dois argumentos básicos e com esses nomes são x e value, sendo que value deve ser sempre o último argumento. Caso, seja necessário adicionar mais argumentos, estes devem ser inseridos entre esses dois argumentos, como apresentado no código a seguir.\r\n\r\n\r\n`subst<-` <- function(x, i, value) {\r\n  x[i] <- value\r\n  x\r\n}\r\nset.seed(10)\r\n(x <- c(1, 2, 3))\r\n\r\n\r\n[1] 1 2 3\r\n\r\n# Inspecao\r\n.Internal(address(x))\r\n\r\n\r\n<pointer: 0x000000002d21aeb0>\r\n\r\n# subst(x, i) <- value\r\nsubst(x, 2) <- 100; x\r\n\r\n\r\n[1]   1 100   3\r\n\r\n# Inspecao\r\n.Internal(address(x))\r\n\r\n\r\n<pointer: 0x000000002d221570>\r\n\r\nVetorização de funções\r\nA vetorização de funções surge quando inserimos argumentos vetorizados, cuja saída dessas funções também são vetorizadas, de modo que não precisamos de loop para que a função retorne um valor de cada elemento do vetor de algum dos argumentos. Pensemos no operador soma (+), no seguinte código:\r\n\r\n\r\n# Vetorização da soma de vetores\r\n1:4 + 10:13\r\n\r\n\r\n[1] 11 13 15 17\r\n\r\nEssa função é vetorizada porque ela realizou, porque ela realizou a soma entre dois elementos de mesma posição nos vetores, isto é,\r\n\r\n1  2  3  4\r\n+  +  +  +\r\n10 11 12 13\r\n------------\r\n11 13 15 17\r\n\r\nIsso é como se tivéssemos realizado um loop para essa operação, da seguinte forma:\r\n\r\n\r\nx <- 1:4\r\ny <- 10:13\r\nfor (i in 1:4) {\r\n  print(x[i] + y[i])\r\n}\r\n\r\n\r\n[1] 11\r\n[1] 13\r\n[1] 15\r\n[1] 17\r\n\r\nGrande maioria das funções nativas do R, isto é, das funções desenvolvidas nos pacotes nativos são vetorizados. Vejamos alguns exemplos:\r\n\r\n\r\n# Funcao logaritmica\r\nlog(1:4)\r\n\r\n\r\n[1] 0.0000000 0.6931472 1.0986123 1.3862944\r\n\r\n# Multiplicacao\r\n10:20 * 5\r\n\r\n\r\n [1]  50  55  60  65  70  75  80  85  90  95 100\r\n\r\n# Operadores logicos\r\n1 == 1:4\r\n\r\n\r\n[1]  TRUE FALSE FALSE FALSE\r\n\r\n# Gerador de numeros aleatorios [0, 1]\r\nrunif(1:10)\r\n\r\n\r\n [1] 0.50747820 0.30676851 0.42690767 0.69310208 0.08513597 0.22543662\r\n [7] 0.27453052 0.27230507 0.61582931 0.42967153\r\n\r\nExistem diversos caminhos para se desenvolver uma função vetorizada. Caso as funções internas da função desenvolvida seja vetorizada, esta também será. Vejamos:\r\n\r\n\r\n`%soma%` <- function(e1, e2) {\r\n  e1 + e2\r\n}\r\n# Exemplo 1\r\n1:4 %soma% 10:13\r\n\r\n\r\n[1] 11 13 15 17\r\n\r\n# Exemplo 2\r\n1:4 %soma% 5\r\n\r\n\r\n[1] 6 7 8 9\r\n\r\nQuando temos funções escalares, podemos em uma das possibilidades, utilizar a função Vectorize() para vetorizar a função desejada. Essa função tem três argumentos importantes, FUN que representa a função a ser vetorizada vectorize.args que representa os argumentos da função vetorizado, que devem entrar como vetores caracteres nesse argumento, e SIMPLIFY que é um argumento lógico, cujo valor TRUE representa uma saída em forma de matriz, dependendo da situação, e FALSE representa a saída em forma de lista. Argumentos padrão não são vetorizados.\r\nVamos usar como exemplo, a função que gera números aleatórios de uma distribuição normal, rnorm(n, mean, sd, log). Vamos trabalhar apenas com os três primeiros argumentos, em que n representa o tamanho da amostra, mean o parâmetro média e sd o parâmetro desvio padrão. Vamos fixar n = 10 e sd = 1, e variar mean = 1:3. Isto significa que iremos ter valores baseados em uma distribuição normal, tal que os valores \\(X_i\\), para \\(i = 1, 2, \\ldots, 10\\), serão gerados de distribuições, tal que \\(X_i \\sim N(\\mu_j)\\), sequencialmente para \\(\\mu_1 = 1\\), \\(\\mu_2 = 2\\) e \\(\\mu_3\\), respectivamente. Assim, teremos uma amostra de tamanho 10, da seguinte forma: \\(X_1\\sim N(1,1)\\), \\(X_2\\sim N(2,1)\\), \\(X_3\\sim N(3,1)\\), \\(X_4\\sim N(1,1)\\), \\(X_5\\sim N(2,1)\\), \\(X_6\\sim N(3,1)\\), \\(X_7\\sim N(1,1)\\), \\(X_8\\sim N(2,1)\\), \\(X_9\\sim N(3,1)\\), \\(X_{10}\\sim N(1,1)\\). Vejamos o código a seguir.\r\n\r\n\r\n# Semente\r\nset.seed(10)\r\n# Gerando a amostra\r\nrnorm(10, 1:3, 1)\r\n\r\n\r\n [1]  1.0187462  1.8157475  1.6286695  0.4008323  2.2945451  3.3897943\r\n [7] -0.2080762  1.6363240  1.3733273  0.7435216\r\n\r\nVamos supor agora, que a ideia de vetorização para essa função, seja que quando assumimos mean = 1:3, ao invés de termos uma amostra como a anterior, teremos três amostras baseadas no comprimento do vetor em mean. Fixado os demais argumentos, teremos uma amostra de uma normal para \\(\\mu_1 = 1\\), \\(\\mu_2 = 2\\) e \\(\\mu_3 = 3\\), isto é,\r\n\\[\r\n\\left\\{\\begin{array}{ll}\r\nX_1, X_2, \\ldots, X_{10}, & X_i \\sim N(1,1), \\\\\r\nY_1, Y_2, \\ldots, Y_{10}, & Y_i \\sim N(2,1), \\\\\r\nZ_1, Z_2, \\ldots, Z_{10}, & Z_i \\sim N(3,1).\r\n\\end{array}\\right.\r\n\\] Para isso, iremos usar Vectorize() para rnorm(), vetorizando o argumento mean. Vejamos o código a seguir, para essa implementação.\r\n\r\n\r\n# Apos a vetorizacao, observe a diferenca entre\r\n# 'rnorm_vet1' e 'rnorm_vet2', devido ao argumento \r\n# 'SIMPLIFY'\r\nrnorm_vet1 <- Vectorize(rnorm, \"mean\", SIMPLIFY = FALSE)\r\nrnorm_vet2 <- Vectorize(rnorm, \"mean\", SIMPLIFY = TRUE)\r\n# Vetorizando\r\nset.seed(10) # semente para fixar os mesmos valores\r\nrnorm_vet1(n = 10, mean = 1:3)\r\n\r\n\r\n[[1]]\r\n [1]  1.0187462  0.8157475 -0.3713305  0.4008323  1.2945451  1.3897943\r\n [7] -0.2080762  0.6363240 -0.6266727  0.7435216\r\n\r\n[[2]]\r\n [1] 3.101780 2.755782 1.761766 2.987445 2.741390 2.089347 1.045056\r\n [8] 1.804850 2.925521 2.482979\r\n\r\n[[3]]\r\n [1] 2.4036894 0.8147132 2.3251341 0.8809388 1.7348020 2.6263384\r\n [7] 2.3124446 2.1278412 2.8982390 2.7462195\r\n\r\nset.seed(10) # semente para fixar os mesmos valores\r\nrnorm_vet2(n = 10, mean = 1:3)\r\n\r\n\r\n            [,1]     [,2]      [,3]\r\n [1,]  1.0187462 3.101780 2.4036894\r\n [2,]  0.8157475 2.755782 0.8147132\r\n [3,] -0.3713305 1.761766 2.3251341\r\n [4,]  0.4008323 2.987445 0.8809388\r\n [5,]  1.2945451 2.741390 1.7348020\r\n [6,]  1.3897943 2.089347 2.6263384\r\n [7,] -0.2080762 1.045056 2.3124446\r\n [8,]  0.6363240 1.804850 2.1278412\r\n [9,] -0.6266727 2.925521 2.8982390\r\n[10,]  0.7435216 2.482979 2.7462195\r\n\r\nAs únicas funções que não podem ser vetorizadas por Vectorize() são as funções primitivas que não tem um valor para formals().\r\nUma outra forma de vetorizar funções, por exemplo, bem como evitar loops no desenvolvimento de algoritmos, é utilizar um conjunto de funções da família apply implentadas no pacote base, que será vista a seguir.\r\nFunções da família apply\r\nApesar de uma das construções mais interessantes na programação, seja o loop, é bom observar que essas construções implementadas em diversas linguagens apresenta grandes diferenças, em termos de desempenho. Já vimos que as funções para loops no R pode demandar um gasto computacional dependendo de sua implementação, cópias na modificação, por ser uma linguagem interpretada, dentre outras características. Alternativamente, podemos usar uma série de funções implementadas no ambiente R, funções estas vetorizadas. Vamos nos concentrar nas funções disponíveis na Base R.\r\nIniciamos com a família de funções apply, pertencente ao pacote base, de modo que permite manipularmos estruturas de dados como vetores, matrizes, arrays, listas e quadro de dados (data frames) de maneira repetitiva sem a utilização de loop. Estas funções são: apply(), lapply(), sapply(), tapply(), mapply(), rapply() e eapply()\r\nA primeira função a ser discutida é apply(), que retorna um array ou uma lista obtida pela aplicação de uma função nas linhas ou colunas da entrada de um objeto seja matriz ou array. Vejamos a sintaxe dessa função:\r\n\r\napply(X, MARGIN, FUN, ..., simplify = TRUE),\r\n\r\nem que: - X argumento que recebe o objeto matriz ou array, - MARGIN argumento que recebe 1, se a função em FUN deve ser aplicado na linha, ou recebe 2 se FUN deve ser aplicado nas colunas, - FUN argumento que recebe a função desejada, - ... argumento que recebe argumentos adicionais para FUN, e - simplify argumento lógico para retorno de resultados simplificados (TRUE) ou não (FALSE).\r\nPor exemplo, supomos que temos 5 amostras de tamanho 10, com reposição, em um conjunto de valores de 1 a 1000, e desejamos computar a média aritmética dessas amostras, que serão inseridas em colunas num objeto matriz, isto é,\r\n\r\n\r\n# 5 amostras\r\n(am1 <- sample(x = 1:1000, size = 10, replace = TRUE))\r\n\r\n\r\n [1]  42 334  13 417 361 729 712 656 373  26\r\n\r\n(am2 <- sample(x = 1:1000, size = 10, replace = TRUE))\r\n\r\n\r\n [1] 857 209  48 663 527 958 878 536 482 317\r\n\r\n(am3 <- sample(x = 1:1000, size = 10, replace = TRUE))\r\n\r\n\r\n [1] 132 739 270 929  35 266  74 570 679 912\r\n\r\n(am4 <- sample(x = 1:1000, size = 10, replace = TRUE))\r\n\r\n\r\n [1] 271 543 906 101 435 437 959 613 621 943\r\n\r\nam5 <- sample(x = 1:1000, size = 10, replace = TRUE)\r\n# Amostras em colunas\r\namost_col <- matrix(c(am1, am2, am3, am4, am5), 10, 5); amost_col\r\n\r\n\r\n      [,1] [,2] [,3] [,4] [,5]\r\n [1,]   42  857  132  271   39\r\n [2,]  334  209  739  543  947\r\n [3,]   13   48  270  906  630\r\n [4,]  417  663  929  101   89\r\n [5,]  361  527   35  435  530\r\n [6,]  729  958  266  437  899\r\n [7,]  712  878   74  959  982\r\n [8,]  656  536  570  613  554\r\n [9,]  373  482  679  621  394\r\n[10,]   26  317  912  943  254\r\n\r\n# Calculando a media por coluna\r\napply(X = amost_col, MARGIN = 2, FUN = mean)\r\n\r\n\r\n[1] 366.3 547.5 460.6 582.9 531.8\r\n\r\n# Amostras em linhas\r\namost_lin <- matrix(c(am1, am2, am3, am4, am5), 5, 10, byrow = TRUE); amost_lin\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\r\n[1,]   42  334   13  417  361  729  712  656  373    26\r\n[2,]  857  209   48  663  527  958  878  536  482   317\r\n[3,]  132  739  270  929   35  266   74  570  679   912\r\n[4,]  271  543  906  101  435  437  959  613  621   943\r\n[5,]   39  947  630   89  530  899  982  554  394   254\r\n\r\n# Calculando a media por linhas\r\napply(X = amost_lin, MARGIN = 1, FUN = mean)\r\n\r\n\r\n[1] 366.3 547.5 460.6 582.9 531.8\r\n\r\n# Podemos tambem adicionar argumentos adicionais\r\n# em FUN (Media truncada em 10%)\r\napply(X = amost_lin, MARGIN = 1, FUN = mean, trim = 0.1)\r\n\r\n\r\n[1] 365.125 558.625 455.250 596.125 537.125\r\n\r\n# Usando o argumento simplify, o default: simplify = TRUE\r\napply(X = amost_lin, MARGIN = 1, FUN = mean, simplify = FALSE)\r\n\r\n\r\n[[1]]\r\n[1] 366.3\r\n\r\n[[2]]\r\n[1] 547.5\r\n\r\n[[3]]\r\n[1] 460.6\r\n\r\n[[4]]\r\n[1] 582.9\r\n\r\n[[5]]\r\n[1] 531.8\r\n\r\nA próxima função é lapply(), com sintaxe:\r\n\r\nlapply(X, FUN, ...),\r\n\r\nem que: - X argumento que recebe uma lista; - FUN argumento que recebe a função desejada, e - ... argumento que recebe argumentos adicionais para FUN.\r\nVejamos que a sintaxe desta função é muito parecido com apply(). Vejamos alguns exemplos, a seguir.\r\n\r\n\r\n# Vetor (nao faz muito sentido)\r\nlapply(1:10, mean)\r\n\r\n\r\n[[1]]\r\n[1] 1\r\n\r\n[[2]]\r\n[1] 2\r\n\r\n[[3]]\r\n[1] 3\r\n\r\n[[4]]\r\n[1] 4\r\n\r\n[[5]]\r\n[1] 5\r\n\r\n[[6]]\r\n[1] 6\r\n\r\n[[7]]\r\n[1] 7\r\n\r\n[[8]]\r\n[1] 8\r\n\r\n[[9]]\r\n[1] 9\r\n\r\n[[10]]\r\n[1] 10\r\n\r\n# Lista\r\nlapply(list(x = 1:10, y = 11:20), mean)\r\n\r\n\r\n$x\r\n[1] 5.5\r\n\r\n$y\r\n[1] 15.5\r\n\r\nlapply(list(x = 1:10, y = 11:20), \"[[\", 2)\r\n\r\n\r\n$x\r\n[1] 2\r\n\r\n$y\r\n[1] 12\r\n\r\nlapply(list(mat1 = matrix(1:12, 4, 3)), \"[\", , 2)\r\n\r\n\r\n$mat1\r\n[1] 5 6 7 8\r\n\r\nA função seguinte é sapply(), que é um invólucro (wrapper) da função lapply(), e o acréscimo sintátivo do argumento padrão simplify = TRUE. Assim, a forma sintática dessa função, segue:\r\n\r\nsapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE),\r\n\r\nem que: - X argumento que recebe uma lista; - FUN argumento que recebe a função desejada; - ... argumento que recebe argumentos adicionais para FUN; e - simplify, argumento lógico, se TRUE retorna o resultado de forma simplificada, sendo um vetor atoômico, matriz ou array; se FALSE o retorno é uma lista; - USE.NAMES, argumento lógico; se TRUE é retornado o nome inserido nos objetos da lista; se FALSE, caso contrário.\r\nNa realidade, o que essa função faz é melhorar a saída de lapply(), retornando um vetor, matriz ou array. Vejamos,\r\n\r\n\r\nlapply(list(1:10, 11:20), mean)\r\n\r\n\r\n[[1]]\r\n[1] 5.5\r\n\r\n[[2]]\r\n[1] 15.5\r\n\r\nsapply(list(1:10, 11:20), mean)\r\n\r\n\r\n[1]  5.5 15.5\r\n\r\n# 'simplify = FALSE' em 'sapply()' eh equivalente a 'lapply()'\r\nsapply(list(1:10, 11:20), mean, simplify = FALSE)\r\n\r\n\r\n[[1]]\r\n[1] 5.5\r\n\r\n[[2]]\r\n[1] 15.5\r\n\r\nUma forma multivariada da função apply, é a função mapply(), com sintaxe:\r\n\r\n\r\nmapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE,\r\n       USE.NAMES = TRUE)\r\n\r\n\r\n\r\nem que: - FUN argumentos que recebe a função desejada; - ... argumentos para vetorização; - MoreArgs uma lista com argumentos adicionais a FUN; - SIMPLIFY, argumento lógico, se TRUE retorna o resultado de forma simplificada, sendo um vetor atoômico, matriz ou array; se FALSE o retorno é uma lista; - USE.NAMES, argumento lógico; se TRUE é retornado o nome inserido nos objetos da lista; se FALSE, caso contrário.\r\nVejamos alguns exemplos de aplicação, a seguir.\r\n\r\n\r\nmapply(FUN = mean, list(x = 1:10, y = 11:20), USE.NAMES = TRUE)\r\n\r\n\r\n   x    y \r\n 5.5 15.5 \r\n\r\nmapply(FUN = mean, list(x = 1:10, y = 11:20), USE.NAMES = FALSE)\r\n\r\n\r\n[1]  5.5 15.5\r\n\r\nmapply(FUN = rep, x = 1:4,  times = 1:4)\r\n\r\n\r\n[[1]]\r\n[1] 1\r\n\r\n[[2]]\r\n[1] 2 2\r\n\r\n[[3]]\r\n[1] 3 3 3\r\n\r\n[[4]]\r\n[1] 4 4 4 4\r\n\r\nmapply(FUN = rep, x = 1:4,  times = 4)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    2    3    4\r\n[2,]    1    2    3    4\r\n[3,]    1    2    3    4\r\n[4,]    1    2    3    4\r\n\r\nmapply(rep, times = 1:4, MoreArgs = list(x = 4))\r\n\r\n\r\n[[1]]\r\n[1] 4\r\n\r\n[[2]]\r\n[1] 4 4\r\n\r\n[[3]]\r\n[1] 4 4 4\r\n\r\n[[4]]\r\n[1] 4 4 4 4\r\n\r\nUm outro exemplo interessante usando mapplay(), suponha que temos um conjunto de dados 1:38 e desejamos reamostrar com reposição 10 amostras de mesmo comprimento desses dados. Nesse caso, temos:\r\n\r\n\r\nmapply(sample, size = rep(38, 10), MoreArgs = list(x = 1:38))\r\n\r\n\r\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\r\n [1,]   15   13   14   31   23   29   18    1   32    25\r\n [2,]   13    6   30   17    1   24   31   37   36    35\r\n [3,]   26   37   27   37   37    5   37   21    7     7\r\n [4,]   14   12   10   24   19   25   33   22   25    10\r\n [5,]   28   32    8    7   25   32   20   26    3    23\r\n [6,]    4   31    6   27    6   14   35    4   31    15\r\n [7,]   31    4    5   14   33   13   19   35   37    28\r\n [8,]   20   24    9   10   14   11   27   18    9    14\r\n [9,]   29   21   18    6   30   22   25   12   11    24\r\n[10,]    3   18   15   34   15    1   17   24   18     6\r\n[11,]   23   38   16    4    7   28   21   36   15    37\r\n[12,]   17   23   17    1   10   19   10   30   16    18\r\n[13,]   16   17   23   20   31    7   13   27   21     5\r\n[14,]   32   11   38   13    2    4   34   38   29    32\r\n[15,]   22    1   32   21   17   20    5    2   35    11\r\n[16,]   30   34   33    8    4   33    6    6   38    12\r\n[17,]    9   14   13   35   22    2    4   20   30    21\r\n[18,]   36   15   21   32   35   16   23   33   20     4\r\n[19,]   21   28    3    2   28   15    9    8   23    19\r\n[20,]   24   36   25   38   11   21   29   17   28    29\r\n[21,]   38    7   12   30   34   23   36   29    2    33\r\n[22,]   27    2   34   18   29   27   28    7   17    36\r\n[23,]    6   20   29   15    5   31   14   28   13    27\r\n[24,]   10   33   36   22   24   35   22   13    5    26\r\n[25,]    7   35   26   12    9   17    8   32   34    13\r\n[26,]   19   22   22   28   36   10    2   15   26    17\r\n[27,]    8   30   37   16   38    9   24    9   24    38\r\n[28,]   37   25    2   36   26   12   12   16   10    30\r\n[29,]   33   29   24    9   12    8    3   31    8     3\r\n[30,]   34    8   31   11   18   38    7   34   14    31\r\n[31,]   11   27   35    3   16   30    1    3    1     9\r\n[32,]   25   19   19   23   27   36   26   14   19     1\r\n[33,]   12   10    7   25   13    3   11   25   12    34\r\n[34,]   35    3   28   29   21   37   32   10   27    20\r\n[35,]   18   16   20   33    3   34   30   23    6     8\r\n[36,]    2    5    4   26   32    6   38    5    4     2\r\n[37,]    5    9   11   19   20   18   15   11   22    22\r\n[38,]    1   26    1    5    8   26   16   19   33    16\r\n\r\nPoderíamos estar interessados também em gerar 10 amostras de tamanho \\(n = 30\\), de uma distribuição normal padrão, isto é,\r\n\r\n\r\nmapply(rnorm, n = rep(30, 10))\r\n\r\n\r\n             [,1]        [,2]         [,3]       [,4]        [,5]\r\n [1,]  0.97693997  1.02159557  0.128783463 -1.8656023 -1.70899030\r\n [2,]  0.79023781  0.35895923  1.972929865 -0.3264478  0.58183916\r\n [3,]  0.98468618  1.25387555 -0.071548470  0.4604034  0.36406946\r\n [4,]  1.72802155  0.70613372  0.662564612 -0.3511606  1.51223372\r\n [5,] -0.12590361 -1.94721263 -0.021996069  0.7167607  0.19003523\r\n [6,]  2.53435299 -0.11707933 -0.316477912 -0.2088030  0.57913457\r\n [7,] -0.43306272  0.17854140  0.002216812  1.2765002  0.05312193\r\n [8,]  0.05448099 -0.88326729  0.518168763 -1.1883914  0.92380619\r\n [9,]  0.21240835 -0.80757517  1.052712115 -1.7137380  0.14522949\r\n[10,] -0.89938361  0.10100343  1.860744440 -1.9561878 -0.88649435\r\n[11,] -1.37565361  1.46412309 -0.572562971 -1.3176539  0.37985772\r\n[12,] -0.72000035 -0.10547712 -1.116260285  0.4809290 -0.94199625\r\n[13,]  0.57103300 -1.79153520 -0.943473638  0.1418312 -0.48406717\r\n[14,] -2.22797642  0.54351301 -2.224035530 -0.2452919 -0.23334446\r\n[15,] -0.46067194  0.31409270  1.451927428 -1.0040025  0.51127182\r\n[16,]  0.28035150  0.50664013 -1.956099422  0.1515346  0.68847089\r\n[17,]  1.21989163 -0.86584165 -1.014548722 -0.5758454 -0.05936718\r\n[18,]  0.49560734  2.70818206  0.039335338 -0.9516940 -0.69619877\r\n[19,] -0.74053951 -0.88611149  0.806803554  0.6059419  1.95999846\r\n[20,]  0.10386793  0.52069801 -0.524917117 -0.5905524  0.15963178\r\n[21,]  0.77818514 -1.23173443  0.034003567  0.3728825 -0.65101808\r\n[22,] -0.35034355  0.80405233  0.529471098 -1.6821377 -0.16582689\r\n[23,] -1.18489995  1.17219691  1.580699421 -0.3354433  0.78029604\r\n[24,] -0.54906948  0.80655250 -0.097312740 -0.7440138  0.68289313\r\n[25,] -0.35041622 -1.72356712 -0.883009480  0.5024655 -0.93243155\r\n[26,] -0.03310228 -0.14579650  0.920582123 -0.3672830 -1.44286488\r\n[27,] -0.38794160 -1.80357911  0.023514388 -1.0183745 -0.15500192\r\n[28,] -0.48037026 -0.23600588 -0.909644168  0.7085347 -0.51796180\r\n[29,] -0.31829568 -1.18294347  0.423339689  1.4669889 -0.18665527\r\n[30,] -0.89372404 -0.07234726 -0.504172213  1.2324449  1.14898546\r\n             [,6]        [,7]        [,8]        [,9]       [,10]\r\n [1,] -0.76589869 -1.24022859  0.10728058 -0.39812103 -0.57176892\r\n [2,]  0.68909301 -0.43904601 -0.27361986  0.71432097 -2.16851673\r\n [3,] -0.47754641  0.92465389 -1.15852151 -0.80001178  0.17681026\r\n [4,]  1.74790082  0.48999988 -2.30646600  0.20796708  1.79055424\r\n [5,]  1.61613864 -0.12520464  2.05624855  1.30804130  0.59392193\r\n [6,] -0.67747280  1.90371182 -0.04554368 -0.46294655 -0.76027132\r\n [7,] -1.06211418  0.55390832  0.48959405 -0.56138541 -0.55642984\r\n [8,]  0.88842467  0.02452472  2.08249472 -0.74300563 -0.64327472\r\n [9,] -1.19553994 -0.43558701  2.15266415  0.56601182 -0.72255975\r\n[10,]  1.42369200 -0.84270375 -0.88377944  0.05779672  0.01210588\r\n[11,] -0.20078225  0.78824154 -0.29569873  0.26355651  0.96129385\r\n[12,]  1.32816470  0.30441382 -1.48067015 -0.42854656 -0.95542144\r\n[13,]  2.23539357 -0.73057805  0.71599300 -1.35961592  0.90466367\r\n[14,]  0.34765519  0.07554207 -0.32544876 -0.06506061  0.34902954\r\n[15,]  2.00349064  0.18755286 -0.48025235 -0.32217859  1.99607943\r\n[16,] -1.20741971  1.54888307 -0.40743851  0.65078507  0.22416550\r\n[17,] -0.11984656  0.73348814 -0.33567896  0.97817838 -0.05739319\r\n[18,]  1.23060416 -0.98774829  1.02588074  2.56431606  0.04200018\r\n[19,] -0.44432912 -1.34502211 -0.62750548 -0.69717728  0.59820545\r\n[20,]  0.06629581  1.12057047  0.14214881  0.84131378 -1.21963884\r\n[21,] -1.82850943  2.08816534  1.29126052  0.65903314  0.54559975\r\n[22,]  0.34204225 -0.76044637  0.31021144  0.64665078 -0.73589761\r\n[23,]  1.03675412 -0.21056316  0.33648561 -0.93036920 -2.43940646\r\n[24,]  0.24952543 -0.95743964 -0.86197071 -0.84909779 -1.04992151\r\n[25,]  0.19481959 -1.39402542 -0.36652510 -0.12281368  0.79303164\r\n[26,]  0.06435280  0.26600553 -0.40975408 -0.30369010 -0.72705396\r\n[27,] -0.59126036  0.58662393 -1.71986196 -0.91213787 -0.90122029\r\n[28,]  1.23259700  0.07286590  0.92255632 -0.44223852  0.25348310\r\n[29,]  0.50179363 -0.04643838  0.98709908 -1.78985673 -0.83447270\r\n[30,] -0.68551424 -0.14572402 -1.07541152  1.60283488 -0.74985132\r\n\r\nOutras funções: by(), aggregate(), simplify2array(), ave(), replicate(), outer()\r\nFunções recursivas\r\nRecall()\r\nlocal()\r\nProgramação defensiva\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nExemplo\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nFunção stop()\r\nFunção Warning()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nProjetos no RStudio\r\nProjetos R no Github\r\nIntrodução a desenvolvimento de pacotes\r\nBanco de dados e APIs, SQL\r\nCriação de documentações no R\r\nDocumentos Web (estatística e dinâmica)\r\nPáginas de pacote (pkgdown)\r\nLivros (bookdown)\r\nBlogs e websites (distill, blogdown)\r\nDocumentos (PDF, WORD, EPUB)\r\nDocumentos estatísticos\r\nDocumentos animados\r\nRelatórios dinâmicos\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChambers, John M. 2008. Software for Data Analysis: Programming with R. Statistics and Computing. New York: Springer.\r\n\r\n\r\n———. 2016. Extending R. The R Series. Boca Raton, Florida: Chapman; Hall/CRC.\r\n\r\n\r\nChambers, John M., and Trevor J. Hastie. 1991. Statistical Methods in S. London: Chapman & Hall.\r\n\r\n\r\n———. 1993. Statistical Models in S. London: Chapman & Hall.\r\n\r\n\r\nWickham, Hadley. 2019. Advanced R. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://adv-r.hadley.nz/.\r\n\r\n\r\nFunções primitivas chamam as funções em linguagem C, DispatchGroup() ou DispatchOrEval().↩︎\r\nFunção similar sprintf().↩︎\r\n",
      "last_modified": "2021-10-15T21:13:59-03:00"
    }
  ],
  "collections": []
}

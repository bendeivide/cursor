---
title: "Curso R: Programação em R (Nível Intermediário)"
subtitle: "Aula 61 - Programação funcional: programação defensiva"
author: "Ben Dêivide"
bibliography: biblio.bib
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  ioslides_presentation: 
    smaller: yes
    transition: slower
    logo: logo2.png
    css: style-cursor-ni2.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
# Links
rlink <- "[R](http://r-project.org/){target='_blank'}"
rstudio <- "[RStudio](http://rstudio.org/){target='_blank'}"
cran <- "[CRAN](http://cran.r-project.org/){target='_blank'}"
github <- "[GitHub](http://github.com/){target='_blank'}"
```


<!--
YAML:
date: "`r format(Sys.time(), '%d %B, %Y')`"
=====
APRESENTACAO:

Inserir nas secoes:
{data-background=boards.jpg data-background-size=cover}
-->


## Selo DC

<center>
[![](SeloDC-preto.png){height=300 width=300}](https://bendeivide.github.io/dc/){target="_blank"}
</center>

## Introdução

A ideia básica da programação defensiva é:

  - Evitar erros previsíveis, seja de ações incorretas dos usuários, ou condições adversas
  - Existem diversas técnicas para proteger as suas funções desses possíveis erros, mas vamos focar principalmente em duas funções: `stop()` e `warning()`.
  
  
## A sintaxe e semântica da função *stop()*

```{r echo=TRUE, include=TRUE, eval=FALSE}
stop(..., call. = TRUE, domain = NULL),
```
em que:

- `...` objeto a ser coagido a caractere;
- `call.` argumento lógico. Se `TRUE` chamará parte da mensagem de erro;
- `domain` argumento que representa o domínio, geralmente o nome do pacote em desenvolvimento. Esse argumento é utilizado juntamente com a função `gettext()` para a internacionalização do pacote.

**Semântica**: Chamado `stop()` no corpo de uma função, esta é encerrada e retornado a mensagem de erro, especificada na própria função.

## A sintaxe e semântica da função *warning()*

```{r echo=TRUE, include=TRUE, eval=FALSE}
warning(..., call. = TRUE, immediate. = FALSE, noBreaks. = FALSE,
        domain = NULL),
```
em que:

- `...` objeto a ser coagido a caractere;
- `call.` argumento lógico. Se `TRUE` chamará parte da mensagem de erro;
- `immediate.` argumento lógico indicando se a mensagem deve ser imediata (`TRUE`), ou apenas no final de toda a execução (`FALSE`);
- `noBreaks.` argumento lógico, apresentando o número de linhas para apresentar a mensagem de alerta (isso ocorre quando `options(warn = 1)`). Sem quebras `TRUE`, com quebras `FALSE`;
- `domain` argumento que representa o domínio, geralmente o nome do pacote em desenvolvimento. Esse argumento é utilizado juntamente com a função `gettext()` para a internacionalização do pacote.

## Aplicações

```{r echo=TRUE, include=TRUE, eval=FALSE}
prog_def <- function(teste = "tudo") {
  # Suponha que no corpo da funcao, as operacoes devem ser
  # realizadas apenas com um objeto sendo apenas caracter.
  cat("Ufa, cheguei até o final, com o objeto teste igual a", teste, "\n")
}
prog_def(teste = 1)
## Ufa, cheguei até o final, com o objeto teste igual a 1 
prog_def(teste = "nada")
## Ufa, cheguei até o final, com o objeto teste igual a nada 
prog_def(expression(x ~y))
## Ufa, cheguei até o final, com o objeto teste igual a 
## Error in cat("Ufa, cheguei até o final, com o objeto 
## teste igual a",  : argumento 2 (tipo 'expression') não 
## suportado por 'cat'
```

## Aplicações: *stop()*

```{r echo=TRUE, include=TRUE, eval=FALSE}
prog_def <- function(teste = "tudo") {
  if (!is.character(teste)) stop("O argumento 'teste' deve ser caractere! \n")
  # Suponha que no corpo da funcao, as operacoes devem ser
  # realizadas apenas com um objeto sendo apenas caracter.
  cat("Ufa, cheguei até o final, com o objeto teste igual a", teste, "\n")
}
prog_def(teste = 1)
## Error in prog_def(teste = 1) : O argumento 'teste' deve ser caractere! 
prog_def(teste = "nada")
## Ufa, cheguei até o final, com o objeto teste igual a nada 
prog_def(expression(x ~ y))
## Error in prog_def(expression(x ~ y)) : 
##  O argumento 'teste' deve ser caractere! 
```

## Aplicações: *stop()*

```{r echo=TRUE, include=TRUE, eval=FALSE}
prog_def <- function(teste = "tudo") {
  if (!is.character(teste)) stop("O argumento 'teste' deve ser caractere! \n", 
                                 call. = FALSE)
  # Suponha que no corpo da funcao, as operacoes devem ser
  # realizadas apenas com um objeto sendo apenas caracter.
  cat("Ufa, cheguei até o final, com o objeto teste igual a", teste, "\n")
}
prog_def(teste = 1)
## Error: O argumento 'teste' deve ser caractere! 
prog_def(teste = "nada")
## Ufa, cheguei até o final, com o objeto teste igual a nada 
prog_def(expression(x ~ y))
## Error: O argumento 'teste' deve ser caractere! 
```

## Aplicações: *warning()*

```{r echo=TRUE, include=TRUE, eval=FALSE}
prog_def <- function(teste = "tudo") {
  if (!is.character(teste)) stop("O argumento 'teste' deve ser caractere! \n", 
                                 call. = FALSE)
  cat("Executada linha de comando 1 \n")
  if (teste == "warning") {
    warning("Mensagem de alerta, sem quebra! \n")
    cat("Executada linha de comando após o \"warning()\"! \n")
  }
  if (teste == "stop") stop("Após o \"stop()\", nada será execudado! \n", 
                            call. = FALSE)
  if (!any(teste == c("warning", "stop"))) cat("Ufa, cheguei até o final! \n")
}
prog_def(teste = "warning")
## Executada linha de comando 1 
## Executada linha de comando após o "warning()"! 
## Warning message:
## In prog_def(teste = "warning") : Mensagem de alerta, sem quebra! 
```

## Aplicações: *warning()*

```{r echo=TRUE, include=TRUE, eval=FALSE}
prog_def <- function(teste = "tudo") {
  if (!is.character(teste)) stop("O argumento 'teste' deve ser caractere! \n", 
                                 call. = FALSE)
  cat("Executada linha de comando 1 \n")
  if (teste == "warning") {
    warning("Mensagem de alerta, sem quebra! \n", immediate. = TRUE)
    cat("Executada linha de comando após o \"warning()\"! \n")
  }
  if (teste == "stop") stop("Após o \"stop()\", nada será execudado! \n", 
                            call. = FALSE)
  if (!any(teste == c("warning", "stop"))) cat("Ufa, cheguei até o final! \n")
}
prog_def(teste = "warning")
## Executada linha de comando 1 
## Warning in prog_def(teste = "warning") :
##  Mensagem de alerta, sem quebra! 
## Executada linha de comando após o "warning()"! 
```

## Aplicações

```{r echo=TRUE, include=TRUE, eval=FALSE, collapse=TRUE}
prog_def <- function(teste = "tudo") {
  if (!is.character(teste)) stop("O argumento 'teste' deve ser caractere! \n", 
                                 call. = FALSE)
  cat("Executada linha de comando 1 \n")
  if (teste == "warning") {
    warning("Mensagem de alerta, sem quebra! \n", immediate. = TRUE, 
            call. = FALSE)
    cat("Executada linha de comando após o \"warning()\"! \n")
  }
  if (teste == "stop") stop("Após o \"stop()\", nada será execudado! \n", 
                            call. = FALSE)
  if (!any(teste == c("warning", "stop"))) cat("Ufa, cheguei até o final! \n")
}
```

## Aplicações

```{r echo=TRUE, include=TRUE, eval=FALSE, collapse=TRUE}
prog_def()
## Executada linha de comando 1 
## Ufa, cheguei até o final! 
prog_def(teste = "warning")
## Executada linha de comando 1 
## Warning: Mensagem de alerta, sem quebra! 
## Executada linha de comando após o "warning()"! 
prog_def(teste = "stop")
## Executada linha de comando 1 
## Error: Após o "stop()", nada será execudado! 
prog_def(teste = 1)
## Error: O argumento 'teste' deve ser caractere! 
prog_def(teste = "nada")
## Executada linha de comando 1 
## Ufa, cheguei até o final! 
prog_def(expression(x ~ y))
## Error: O argumento 'teste' deve ser caractere! 
```


## Bons estudos!

<center>
[![](logo2.png){height=500 width=500}](https://bendeivide.github.io/courses/cursor/){target="_blank"}
</center>
